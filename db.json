{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/blog.js","path":"js/blog.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/Anisina/README.md","hash":"6090746aeee0e5ad4ad0107b85e808e6f3937f98","modified":1589653314689},{"_id":"themes/Anisina/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1589653314689},{"_id":"themes/Anisina/.gitignore","hash":"7a2d5c9a8f18e75645eabbeacbf0ee83ba15e854","modified":1589653314689},{"_id":"themes/Anisina/_config.yml","hash":"5baf18c53f7635cd35aa5a8dab8abc08251023ce","modified":1589699399869},{"_id":"themes/Anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1589653314721},{"_id":"source/categories/index.md","hash":"d0b7145a7592ad02fdc8cd7c52ac4b287c710045","modified":1589698714969},{"_id":"source/tags/index.md","hash":"5d041400f798de850b8400958e1dee8d0484d735","modified":1592743775977},{"_id":"themes/Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1589653314705},{"_id":"themes/Anisina/layout/.DS_Store","hash":"fd623c7cbe0d8fd902f6ca242127fd8db7da6c18","modified":1589653314721},{"_id":"themes/Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1589653314721},{"_id":"themes/Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1589653314721},{"_id":"themes/Anisina/layout/categories.ejs","hash":"055ac64a3ba036e29ff984fd886d57d580bbbff6","modified":1589653314721},{"_id":"themes/Anisina/layout/index.ejs","hash":"a0eaee13571e79c3632e23a9e94ccc991761d1f5","modified":1589653314721},{"_id":"themes/Anisina/layout/layout.ejs","hash":"b728827bf3ec55baf96a882032397e6c74c65f34","modified":1589653314721},{"_id":"themes/Anisina/layout/page.ejs","hash":"39be778a184118ed222f071f73c928e1ef3aea03","modified":1589731474262},{"_id":"themes/Anisina/layout/poetry.ejs","hash":"0a5ac641e4b5ca8ec0ea3a47cf31a1c73604cd26","modified":1589729040019},{"_id":"themes/Anisina/layout/post.ejs","hash":"1a7d9837be94f32080ff3877d5e2bec3913b6d4f","modified":1589729075462},{"_id":"themes/Anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1589653314721},{"_id":"themes/Anisina/layout/tags.ejs","hash":"a5b73e70540e12532aa92f12609b3a937a8bc28b","modified":1589653314721},{"_id":"themes/Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1589653314689},{"_id":"source/_posts/page/typescript函数.md","hash":"0affaa963fe89bfe02febd5bdba26860c764c728","modified":1592743684185},{"_id":"source/_posts/page/typescript基本数据类型.md","hash":"903e55337d42038658e62b9a408721ac2c855988","modified":1592743689437},{"_id":"themes/Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1589653314689},{"_id":"themes/Anisina/layout/_partial/footer.ejs","hash":"e9be0ad317f608b96c11acf7cb432fa6afa2da11","modified":1589695454245},{"_id":"themes/Anisina/layout/_partial/head.ejs","hash":"4e0d96cac503d4e3a5b254d8b8175c392971ce38","modified":1589653314721},{"_id":"themes/Anisina/layout/_partial/nav.ejs","hash":"1341f0c6b5527e30f418a37134cb0aa63be1e936","modified":1589698219457},{"_id":"themes/Anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1589653314721},{"_id":"themes/Anisina/source/css/blog-style.css","hash":"e5880351fdf2c2222a3e5415a47f406fcc0eecc5","modified":1589696777102},{"_id":"themes/Anisina/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1589653314721},{"_id":"themes/Anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1589653314736},{"_id":"themes/Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1589653314736},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1589653314736},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1589653314736},{"_id":"themes/Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1589653314736},{"_id":"themes/Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1589653314705},{"_id":"themes/Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1589653314721},{"_id":"themes/Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1589653314736},{"_id":"themes/Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1589653314705},{"_id":"themes/Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1589653314736},{"_id":"themes/Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1589653314705},{"_id":"themes/Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1589653314705},{"_id":"public/tags/index.html","hash":"88747305c5cd8eff3e47c64c429cbe07df37be19","modified":1592748848699},{"_id":"public/categories/index.html","hash":"f06e4d63f26697848624da41e5ea13c4a5d7ee06","modified":1592748848699},{"_id":"public/archives/index.html","hash":"14efef5c19f4778de292f8b11c699084b63633a2","modified":1592748848699},{"_id":"public/archives/2019/index.html","hash":"fdbf6491599861801458bf00007e4f7b45d72d76","modified":1592748848699},{"_id":"public/archives/2019/05/index.html","hash":"045442d2ebd4e34aa059117c34a9497fd04939c6","modified":1592748848699},{"_id":"public/2019/05/17/page/typescript函数/index.html","hash":"0e56cb6d3f4bb3e2db7f5558af0a6176cbda99b3","modified":1592748848699},{"_id":"public/2019/05/17/page/typescript基本数据类型/index.html","hash":"1735984e1a2c0336d8716fa1c7fde2a1341e51ce","modified":1592748848699},{"_id":"public/categories/web前端/index.html","hash":"2438dd9670e2e3cfe8c7d69718e4b59dcd2aa77b","modified":1592748848699},{"_id":"public/tags/typescript/index.html","hash":"3886fdcd7f2a93cfc4c274cd81408e10464dde0b","modified":1592748848699},{"_id":"public/index.html","hash":"185859e3b16a926f0c0feb28fb3636bead39ee48","modified":1592748848699},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1592748848699},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1592748848699},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1592748848699},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1592748848699},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1592748848699},{"_id":"public/css/syntax.css","hash":"4616879fec214c9cc4f5835615348f0bbeabf2a9","modified":1592748848699},{"_id":"public/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1592748848699},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1592748848699},{"_id":"public/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1592748848699},{"_id":"public/css/blog-style.css","hash":"e5880351fdf2c2222a3e5415a47f406fcc0eecc5","modified":1592748848699},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1592748848699},{"_id":"public/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1592748848699},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1592748848699},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1592748848699}],"Category":[{"name":"web前端","_id":"ckbp5jhtv0003w8sxhevn4xs1"}],"Data":[],"Page":[{"title":"标签","date":"2020-06-21T12:49:20.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-06-21 20:49:20\nlayout: tags\n---\n","updated":"2020-06-21T12:49:35.977Z","path":"tags/index.html","comments":1,"_id":"ckbp5jhtd0000w8sxe3s182l4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章分类","date":"2020-05-17T06:55:09.000Z","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2020-05-17 14:55:09\nlayout: categories\n---\n","updated":"2020-05-17T06:58:34.969Z","path":"categories/index.html","comments":1,"_id":"ckbp5jhtg0001w8sxdx41glf1","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"TypeScript函数","date":"2019-05-17T07:19:26.000Z","_content":"## 1. 函数\n\n### 1.1 函数的定义\n\n可以指定参数的类型和返回值的类型\n\n```javascript\nfunction hello(name:string):void {\n    console.log('hello',name);\n}\nhello('zf');\n```\n\n### 1.2 函数表达式\n\n```javascript\n定义函数类型\ntype GetUsernameFunction = (x:string,y:string)=>string;\nlet getUsername:GetUsernameFunction = function(firstName,lastName){\n  return firstName + lastName;\n}\n```\n\n### 1.3 没有返回值\n\n```javascript\nlet hello2 = function (name:string):void {\n    console.log('hello2',name);\n    return undefined;\n}\nhello2('zf');\n```\n\n### 1.4 可选参数\n\n```javascript\n在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数\n\nfunction print(name:string,age?:number):void {\n    console.log(name,age);\n}\nprint('zf');\n```\n\n### 1.5 默认参数\n\n```javascript\nfunction ajax(url:string,method:string='GET') {\n    console.log(url,method);\n}\najax('/users');\n```\n\n### 1.6 剩余参数\n\n```javascript\nfunction sum(...numbers:number[]) {\n    return numbers.reduce((val,item)=>val+=item,0);\n}\nconsole.log(sum(1,2,3));\n```\n\n### 1.7 函数重载\n\n在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样\n在TypeScript中，表现为给同一个函数提供多个函数类型定义\n\n```javascript\nlet obj: any={};\nfunction attr(val: string): void;\nfunction attr(val: number): void;\nfunction attr(val:any):void {\n    if (typeof val === 'string') {\n        obj.name=val;\n    } else {\n        obj.age=val;\n    }\n}\nattr('zf');\nattr(9);\nattr(true);\nconsole.log(obj);\n```\n","source":"_posts/page/typescript函数.md","raw":"---\ntitle: TypeScript函数\ntags:\n  - typescript\ncategories: web前端\ndate: 2019-05-17 15:19:26\n---\n## 1. 函数\n\n### 1.1 函数的定义\n\n可以指定参数的类型和返回值的类型\n\n```javascript\nfunction hello(name:string):void {\n    console.log('hello',name);\n}\nhello('zf');\n```\n\n### 1.2 函数表达式\n\n```javascript\n定义函数类型\ntype GetUsernameFunction = (x:string,y:string)=>string;\nlet getUsername:GetUsernameFunction = function(firstName,lastName){\n  return firstName + lastName;\n}\n```\n\n### 1.3 没有返回值\n\n```javascript\nlet hello2 = function (name:string):void {\n    console.log('hello2',name);\n    return undefined;\n}\nhello2('zf');\n```\n\n### 1.4 可选参数\n\n```javascript\n在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数\n\nfunction print(name:string,age?:number):void {\n    console.log(name,age);\n}\nprint('zf');\n```\n\n### 1.5 默认参数\n\n```javascript\nfunction ajax(url:string,method:string='GET') {\n    console.log(url,method);\n}\najax('/users');\n```\n\n### 1.6 剩余参数\n\n```javascript\nfunction sum(...numbers:number[]) {\n    return numbers.reduce((val,item)=>val+=item,0);\n}\nconsole.log(sum(1,2,3));\n```\n\n### 1.7 函数重载\n\n在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样\n在TypeScript中，表现为给同一个函数提供多个函数类型定义\n\n```javascript\nlet obj: any={};\nfunction attr(val: string): void;\nfunction attr(val: number): void;\nfunction attr(val:any):void {\n    if (typeof val === 'string') {\n        obj.name=val;\n    } else {\n        obj.age=val;\n    }\n}\nattr('zf');\nattr(9);\nattr(true);\nconsole.log(obj);\n```\n","slug":"page/typescript函数","published":1,"updated":"2020-06-21T12:48:04.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbp5jhts0002w8sx3x2zfre7","content":"<h2 id=\"1-函数\"><a href=\"#1-函数\" class=\"headerlink\" title=\"1. 函数\"></a>1. 函数</h2><h3 id=\"1-1-函数的定义\"><a href=\"#1-1-函数的定义\" class=\"headerlink\" title=\"1.1 函数的定义\"></a>1.1 函数的定义</h3><p>可以指定参数的类型和返回值的类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-函数表达式\"><a href=\"#1-2-函数表达式\" class=\"headerlink\" title=\"1.2 函数表达式\"></a>1.2 函数表达式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">定义函数类型</span><br><span class=\"line\">type GetUsernameFunction = <span class=\"function\">(<span class=\"params\">x:string,y:string</span>)=&gt;</span>string;</span><br><span class=\"line\"><span class=\"keyword\">let</span> getUsername:GetUsernameFunction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">firstName,lastName</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-没有返回值\"><a href=\"#1-3-没有返回值\" class=\"headerlink\" title=\"1.3 没有返回值\"></a>1.3 没有返回值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello2'</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello2(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-可选参数\"><a href=\"#1-4-可选参数\" class=\"headerlink\" title=\"1.4 可选参数\"></a>1.4 可选参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\">name:string,age?:number</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name,age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-默认参数\"><a href=\"#1-5-默认参数\" class=\"headerlink\" title=\"1.5 默认参数\"></a>1.5 默认参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url:string,method:string=<span class=\"string\">'GET'</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(url,method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ajax(<span class=\"string\">'/users'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-剩余参数\"><a href=\"#1-6-剩余参数\" class=\"headerlink\" title=\"1.6 剩余参数\"></a>1.6 剩余参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">...numbers:number[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numbers.reduce(<span class=\"function\">(<span class=\"params\">val,item</span>)=&gt;</span>val+=item,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-函数重载\"><a href=\"#1-7-函数重载\" class=\"headerlink\" title=\"1.7 函数重载\"></a>1.7 函数重载</h3><p>在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样<br>在TypeScript中，表现为给同一个函数提供多个函数类型定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj: any=&#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: string</span>): <span class=\"title\">void</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: number</span>): <span class=\"title\">void</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val:any</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        obj.name=val;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        obj.age=val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">attr(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">attr(<span class=\"number\">9</span>);</span><br><span class=\"line\">attr(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-函数\"><a href=\"#1-函数\" class=\"headerlink\" title=\"1. 函数\"></a>1. 函数</h2><h3 id=\"1-1-函数的定义\"><a href=\"#1-1-函数的定义\" class=\"headerlink\" title=\"1.1 函数的定义\"></a>1.1 函数的定义</h3><p>可以指定参数的类型和返回值的类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-函数表达式\"><a href=\"#1-2-函数表达式\" class=\"headerlink\" title=\"1.2 函数表达式\"></a>1.2 函数表达式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">定义函数类型</span><br><span class=\"line\">type GetUsernameFunction = <span class=\"function\">(<span class=\"params\">x:string,y:string</span>)=&gt;</span>string;</span><br><span class=\"line\"><span class=\"keyword\">let</span> getUsername:GetUsernameFunction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">firstName,lastName</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-没有返回值\"><a href=\"#1-3-没有返回值\" class=\"headerlink\" title=\"1.3 没有返回值\"></a>1.3 没有返回值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello2'</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello2(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-可选参数\"><a href=\"#1-4-可选参数\" class=\"headerlink\" title=\"1.4 可选参数\"></a>1.4 可选参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\">name:string,age?:number</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name,age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-默认参数\"><a href=\"#1-5-默认参数\" class=\"headerlink\" title=\"1.5 默认参数\"></a>1.5 默认参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url:string,method:string=<span class=\"string\">'GET'</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(url,method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ajax(<span class=\"string\">'/users'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-剩余参数\"><a href=\"#1-6-剩余参数\" class=\"headerlink\" title=\"1.6 剩余参数\"></a>1.6 剩余参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">...numbers:number[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numbers.reduce(<span class=\"function\">(<span class=\"params\">val,item</span>)=&gt;</span>val+=item,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-函数重载\"><a href=\"#1-7-函数重载\" class=\"headerlink\" title=\"1.7 函数重载\"></a>1.7 函数重载</h3><p>在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样<br>在TypeScript中，表现为给同一个函数提供多个函数类型定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj: any=&#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: string</span>): <span class=\"title\">void</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: number</span>): <span class=\"title\">void</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val:any</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        obj.name=val;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        obj.age=val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">attr(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">attr(<span class=\"number\">9</span>);</span><br><span class=\"line\">attr(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br></pre></td></tr></table></figure>\n"},{"title":"TypeScript基本数据类型","date":"2019-05-17T07:19:26.000Z","_content":"\n## 数据类型\n\n### 1.布尔类型(boolean)\n\n```javascript\n\nlet isLzf: boolean=false;\n\n```\n\n### 1.2数字类型(number)\n\n```javascript\nlet age: number=10;\n```\n\n### 1.3 字符串类型(string)\n\n```javascript\nlet firstname: string='lzf';\n```\n\n### 1.4 数组类型(array)\n\n```javascript\nlet arr2: number[]=[4,5,6];\nlet arr3: Array<number>=[7,8,9];\n```\n\n### 1.5 元组类型(tuple)\n\n在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组\n\n```javascript\nlet zf:[string,number] = ['zf',5];\nzf[0].length;\nzf[1].toFixed(2);\n```\n\n元组\t数组\n每一项可以是不同的类型\t每一项都是同一种类型\n有预定义的长度\t没有长度限制\n用于表示一个固定的结构\t用于表示一个列表\n\n```javascript\nconst animal:[string,number,boolean] = ['zf',10,true];\n```\n\n### 1.6 枚举类型(enum)\n\n事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值\n比如性别、月份、星期、颜色、单位、学历\n\n#### 1.6.1 普通枚举\n\n```javascript\nenum Gender{\n    GIRL,\n    BOY\n}\nconsole.log(`lzf是${Gender.BOY}`);\nconsole.log(`zf${Gender.GIRL}`);\n\nenum Week{\n    MONDAY=1,\n    TUESDAY=2\n}\nconsole.log(`今天是星期${Week.MONDAY}`);\n```\n\n#### 1.6.2 常数枚举\n\n常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n假如包含了计算成员，则会在编译阶段报错\n\n```javascript\nconst enum Colors {\n    Red,\n    Yellow,\n    Blue\n}\n\nlet myColors = [Colors.Red, Colors.Yellow, Colors.Blue];\nconst enum Color {Red, Yellow, Blue = \"blue\".length};\n```\n\n### 1.7 任意类型(any)\n\nany就是可以赋值给任意类型\n第三方库没有提供类型文件时可以使用any\n类型转换遇到困难时\n数据结构太复杂难以定义\n\n```javascript\nlet root:any=document.getElementById('root');\nroot.style.color='red';\nlet root:(HTMLElement|null)=document.getElementById('root');\nroot!.style.color='red';//非空断言操作符\n```\n\n### 1.8 null 和 undefined\n\nnull 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined\nstrictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any\n\n```javascript\nlet x: number;\nx = 1;\nx = undefined;\nx = null;\n\nlet y: number | null | undefined;\ny = 1;\ny = undefined;\ny = null;\n```\n\n### 1.9 void 类型\n\nvoid 表示没有任何类型\n当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。\n\n```javascript\nfunction greeting(name:string):void {\n    console.log('hello',name);\n    //当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined\n    //严格模式(strictNullChecks:true)下只能返回undefined\n    //return null;\n    //return undefined;\n}\n```\n\n### 1.10 never类型\n\nnever是其它类型(null undefined)的子类型，代表不会出现的值\n作为不会返回（ return ）的函数的返回值类型\n\n```javascript\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\nlet result1 = error('hello');\n// 由类型推论得到返回值为 never\nfunction fail() {\n    return error(\"Something failed\");\n}\nlet result = fail();\n\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction infiniteLoop(): never {\n    while (true) {}\n}\n```\n\n#### 1.10.1 strictNullChecks\n\n在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 --strictNullChecks 这一种检查模式\n由于引入了 --strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。\n\n```javascript\n// Compiled with --strictNullChecks\nfunction fn(x: number | string) {\n  if (typeof x === 'number') {\n    // x: number 类型\n  } else if (typeof x === 'string') {\n    // x: string 类型\n  } else {\n    // x: never 类型\n    // --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察\n  }\n}\n```\n\n#### 1.10.2 never 和 void 的区别、\n\nvoid 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。\n拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。\n1.11 类型推论\n是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性\n定义时未赋值就会推论成any类型\n如果定义的时候就赋值就能利用到类型推论\n\n```javascript\nlet username2;\nusername2 = 10;\nusername2 = 'zf';\nusername2 = null;\n```\n\n### 1.12 包装对象（Wrapper Object）\n\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n所有的原始数据类型都没有属性（property）\n原始数据类型\n布尔值\n数值\n字符串\n\n```javascript\nnull\nundefined\nSymbol\nlet name = 'zf';\nconsole.log(name.toUpperCase());\nconsole.log((new String('zf')).toUpperCase());\n当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换\nlet isOK: boolean = true; // 编译通过\nlet isOK: boolean = Boolean(1) // 编译通过\nlet isOK: boolean = new Boolean(1); // 编译失败   期望的 isOK 是一个原始数据类型\n```\n\n### 1.13 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种\n未赋值时联合类型上只能访问两个类型共有的属性和方法\n\n```javascript\nlet name: string | number;\nconsole.log(name.toString());\nname = 3;\nconsole.log(name.toFixed(2));\nname = 'zf';\nconsole.log(name.length);\n\nexport {};\n```\n\n### 1.14 类型断言\n\n类型断言可以将一个联合类型的变量，指定为一个更加具体的类型\n不能将联合类型断言为不存在的类型\n\n```javascript\nlet name: string | number;\nconsole.log((name as string).length);\nconsole.log((name as number).toFixed(2));\nconsole.log((name as boolean));\n```\n\n### 1.15 字面量类型\n\n可以把字符串、数字、布尔值字面量组成一个联合类型\n\n```javascript\ntype ZType = 1 | 'One'|true;\nlet t1:ZType = 1;\nlet t2:ZType = 'One';\nlet t3:ZType = true;\n```\n\n### 1.16 字符串字面量 vs 联合类型\n\n字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种\n字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致\n","source":"_posts/page/typescript基本数据类型.md","raw":"---\ntitle: TypeScript基本数据类型\ntags:\n  - typescript\ncategories: web前端\ndate: 2019-05-17 15:19:26\n---\n\n## 数据类型\n\n### 1.布尔类型(boolean)\n\n```javascript\n\nlet isLzf: boolean=false;\n\n```\n\n### 1.2数字类型(number)\n\n```javascript\nlet age: number=10;\n```\n\n### 1.3 字符串类型(string)\n\n```javascript\nlet firstname: string='lzf';\n```\n\n### 1.4 数组类型(array)\n\n```javascript\nlet arr2: number[]=[4,5,6];\nlet arr3: Array<number>=[7,8,9];\n```\n\n### 1.5 元组类型(tuple)\n\n在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组\n\n```javascript\nlet zf:[string,number] = ['zf',5];\nzf[0].length;\nzf[1].toFixed(2);\n```\n\n元组\t数组\n每一项可以是不同的类型\t每一项都是同一种类型\n有预定义的长度\t没有长度限制\n用于表示一个固定的结构\t用于表示一个列表\n\n```javascript\nconst animal:[string,number,boolean] = ['zf',10,true];\n```\n\n### 1.6 枚举类型(enum)\n\n事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值\n比如性别、月份、星期、颜色、单位、学历\n\n#### 1.6.1 普通枚举\n\n```javascript\nenum Gender{\n    GIRL,\n    BOY\n}\nconsole.log(`lzf是${Gender.BOY}`);\nconsole.log(`zf${Gender.GIRL}`);\n\nenum Week{\n    MONDAY=1,\n    TUESDAY=2\n}\nconsole.log(`今天是星期${Week.MONDAY}`);\n```\n\n#### 1.6.2 常数枚举\n\n常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n假如包含了计算成员，则会在编译阶段报错\n\n```javascript\nconst enum Colors {\n    Red,\n    Yellow,\n    Blue\n}\n\nlet myColors = [Colors.Red, Colors.Yellow, Colors.Blue];\nconst enum Color {Red, Yellow, Blue = \"blue\".length};\n```\n\n### 1.7 任意类型(any)\n\nany就是可以赋值给任意类型\n第三方库没有提供类型文件时可以使用any\n类型转换遇到困难时\n数据结构太复杂难以定义\n\n```javascript\nlet root:any=document.getElementById('root');\nroot.style.color='red';\nlet root:(HTMLElement|null)=document.getElementById('root');\nroot!.style.color='red';//非空断言操作符\n```\n\n### 1.8 null 和 undefined\n\nnull 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined\nstrictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any\n\n```javascript\nlet x: number;\nx = 1;\nx = undefined;\nx = null;\n\nlet y: number | null | undefined;\ny = 1;\ny = undefined;\ny = null;\n```\n\n### 1.9 void 类型\n\nvoid 表示没有任何类型\n当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。\n\n```javascript\nfunction greeting(name:string):void {\n    console.log('hello',name);\n    //当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined\n    //严格模式(strictNullChecks:true)下只能返回undefined\n    //return null;\n    //return undefined;\n}\n```\n\n### 1.10 never类型\n\nnever是其它类型(null undefined)的子类型，代表不会出现的值\n作为不会返回（ return ）的函数的返回值类型\n\n```javascript\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\nlet result1 = error('hello');\n// 由类型推论得到返回值为 never\nfunction fail() {\n    return error(\"Something failed\");\n}\nlet result = fail();\n\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction infiniteLoop(): never {\n    while (true) {}\n}\n```\n\n#### 1.10.1 strictNullChecks\n\n在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 --strictNullChecks 这一种检查模式\n由于引入了 --strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。\n\n```javascript\n// Compiled with --strictNullChecks\nfunction fn(x: number | string) {\n  if (typeof x === 'number') {\n    // x: number 类型\n  } else if (typeof x === 'string') {\n    // x: string 类型\n  } else {\n    // x: never 类型\n    // --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察\n  }\n}\n```\n\n#### 1.10.2 never 和 void 的区别、\n\nvoid 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。\n拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。\n1.11 类型推论\n是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性\n定义时未赋值就会推论成any类型\n如果定义的时候就赋值就能利用到类型推论\n\n```javascript\nlet username2;\nusername2 = 10;\nusername2 = 'zf';\nusername2 = null;\n```\n\n### 1.12 包装对象（Wrapper Object）\n\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n所有的原始数据类型都没有属性（property）\n原始数据类型\n布尔值\n数值\n字符串\n\n```javascript\nnull\nundefined\nSymbol\nlet name = 'zf';\nconsole.log(name.toUpperCase());\nconsole.log((new String('zf')).toUpperCase());\n当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换\nlet isOK: boolean = true; // 编译通过\nlet isOK: boolean = Boolean(1) // 编译通过\nlet isOK: boolean = new Boolean(1); // 编译失败   期望的 isOK 是一个原始数据类型\n```\n\n### 1.13 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种\n未赋值时联合类型上只能访问两个类型共有的属性和方法\n\n```javascript\nlet name: string | number;\nconsole.log(name.toString());\nname = 3;\nconsole.log(name.toFixed(2));\nname = 'zf';\nconsole.log(name.length);\n\nexport {};\n```\n\n### 1.14 类型断言\n\n类型断言可以将一个联合类型的变量，指定为一个更加具体的类型\n不能将联合类型断言为不存在的类型\n\n```javascript\nlet name: string | number;\nconsole.log((name as string).length);\nconsole.log((name as number).toFixed(2));\nconsole.log((name as boolean));\n```\n\n### 1.15 字面量类型\n\n可以把字符串、数字、布尔值字面量组成一个联合类型\n\n```javascript\ntype ZType = 1 | 'One'|true;\nlet t1:ZType = 1;\nlet t2:ZType = 'One';\nlet t3:ZType = true;\n```\n\n### 1.16 字符串字面量 vs 联合类型\n\n字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种\n字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致\n","slug":"page/typescript基本数据类型","published":1,"updated":"2020-06-21T12:48:09.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbp5jhu00007w8sx3rksaqov","content":"<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"1-布尔类型-boolean\"><a href=\"#1-布尔类型-boolean\" class=\"headerlink\" title=\"1.布尔类型(boolean)\"></a>1.布尔类型(boolean)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> isLzf: boolean=<span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2数字类型-number\"><a href=\"#1-2数字类型-number\" class=\"headerlink\" title=\"1.2数字类型(number)\"></a>1.2数字类型(number)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> age: number=<span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-字符串类型-string\"><a href=\"#1-3-字符串类型-string\" class=\"headerlink\" title=\"1.3 字符串类型(string)\"></a>1.3 字符串类型(string)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> firstname: string=<span class=\"string\">'lzf'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-数组类型-array\"><a href=\"#1-4-数组类型-array\" class=\"headerlink\" title=\"1.4 数组类型(array)\"></a>1.4 数组类型(array)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr2: number[]=[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3: <span class=\"built_in\">Array</span>&lt;number&gt;=[<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-元组类型-tuple\"><a href=\"#1-5-元组类型-tuple\" class=\"headerlink\" title=\"1.5 元组类型(tuple)\"></a>1.5 元组类型(tuple)</h3><p>在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zf:[string,number] = [<span class=\"string\">'zf'</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">zf[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">zf[<span class=\"number\">1</span>].toFixed(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>元组    数组<br>每一项可以是不同的类型    每一项都是同一种类型<br>有预定义的长度    没有长度限制<br>用于表示一个固定的结构    用于表示一个列表</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> animal:[string,number,boolean] = [<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-枚举类型-enum\"><a href=\"#1-6-枚举类型-enum\" class=\"headerlink\" title=\"1.6 枚举类型(enum)\"></a>1.6 枚举类型(enum)</h3><p>事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值<br>比如性别、月份、星期、颜色、单位、学历</p>\n<h4 id=\"1-6-1-普通枚举\"><a href=\"#1-6-1-普通枚举\" class=\"headerlink\" title=\"1.6.1 普通枚举\"></a>1.6.1 普通枚举</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Gender&#123;</span><br><span class=\"line\">    GIRL,</span><br><span class=\"line\">    BOY</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`lzf是<span class=\"subst\">$&#123;Gender.BOY&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`zf<span class=\"subst\">$&#123;Gender.GIRL&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">enum Week&#123;</span><br><span class=\"line\">    MONDAY=<span class=\"number\">1</span>,</span><br><span class=\"line\">    TUESDAY=<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`今天是星期<span class=\"subst\">$&#123;Week.MONDAY&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-6-2-常数枚举\"><a href=\"#1-6-2-常数枚举\" class=\"headerlink\" title=\"1.6.2 常数枚举\"></a>1.6.2 常数枚举</h4><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。<br>假如包含了计算成员，则会在编译阶段报错</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> enum Colors &#123;</span><br><span class=\"line\">    Red,</span><br><span class=\"line\">    Yellow,</span><br><span class=\"line\">    Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myColors = [Colors.Red, Colors.Yellow, Colors.Blue];</span><br><span class=\"line\"><span class=\"keyword\">const</span> enum Color &#123;Red, Yellow, Blue = <span class=\"string\">\"blue\"</span>.length&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-任意类型-any\"><a href=\"#1-7-任意类型-any\" class=\"headerlink\" title=\"1.7 任意类型(any)\"></a>1.7 任意类型(any)</h3><p>any就是可以赋值给任意类型<br>第三方库没有提供类型文件时可以使用any<br>类型转换遇到困难时<br>数据结构太复杂难以定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> root:any=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root.style.color=<span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> root:(HTMLElement|<span class=\"literal\">null</span>)=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root!.style.color=<span class=\"string\">'red'</span>;<span class=\"comment\">//非空断言操作符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-8-null-和-undefined\"><a href=\"#1-8-null-和-undefined\" class=\"headerlink\" title=\"1.8 null 和 undefined\"></a>1.8 null 和 undefined</h3><p>null 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined<br>strictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: number;</span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\">x = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> y: number | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"number\">1</span>;</span><br><span class=\"line\">y = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-void-类型\"><a href=\"#1-9-void-类型\" class=\"headerlink\" title=\"1.9 void 类型\"></a>1.9 void 类型</h3><p>void 表示没有任何类型<br>当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeting</span>(<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">    <span class=\"comment\">//当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//严格模式(strictNullChecks:true)下只能返回undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//return null;</span></span><br><span class=\"line\">    <span class=\"comment\">//return undefined;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-10-never类型\"><a href=\"#1-10-never类型\" class=\"headerlink\" title=\"1.10 never类型\"></a>1.10 never类型</h3><p>never是其它类型(null undefined)的子类型，代表不会出现的值<br>作为不会返回（ return ）的函数的返回值类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: string</span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = error(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 由类型推论得到返回值为 never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = fail();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-1-strictNullChecks\"><a href=\"#1-10-1-strictNullChecks\" class=\"headerlink\" title=\"1.10.1 strictNullChecks\"></a>1.10.1 strictNullChecks</h4><p>在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 –strictNullChecks 这一种检查模式<br>由于引入了 –strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Compiled with --strictNullChecks</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">x: number | string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: number 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: string 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: never 类型</span></span><br><span class=\"line\">    <span class=\"comment\">// --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-2-never-和-void-的区别、\"><a href=\"#1-10-2-never-和-void-的区别、\" class=\"headerlink\" title=\"1.10.2 never 和 void 的区别、\"></a>1.10.2 never 和 void 的区别、</h4><p>void 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。<br>拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。<br>1.11 类型推论<br>是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性<br>定义时未赋值就会推论成any类型<br>如果定义的时候就赋值就能利用到类型推论</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username2;</span><br><span class=\"line\">username2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">username2 = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">username2 = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-12-包装对象（Wrapper-Object）\"><a href=\"#1-12-包装对象（Wrapper-Object）\" class=\"headerlink\" title=\"1.12 包装对象（Wrapper Object）\"></a>1.12 包装对象（Wrapper Object）</h3><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>所有的原始数据类型都没有属性（property）<br>原始数据类型<br>布尔值<br>数值<br>字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toUpperCase());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'zf'</span>)).toUpperCase());</span><br><span class=\"line\">当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换</span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"literal\">true</span>; <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>) <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>); <span class=\"comment\">// 编译失败   期望的 isOK 是一个原始数据类型</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-13-联合类型\"><a href=\"#1-13-联合类型\" class=\"headerlink\" title=\"1.13 联合类型\"></a>1.13 联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种<br>未赋值时联合类型上只能访问两个类型共有的属性和方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: string | number;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toString());</span><br><span class=\"line\">name = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\">name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-14-类型断言\"><a href=\"#1-14-类型断言\" class=\"headerlink\" title=\"1.14 类型断言\"></a>1.14 类型断言</h3><p>类型断言可以将一个联合类型的变量，指定为一个更加具体的类型<br>不能将联合类型断言为不存在的类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: string | number;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> string).length);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> number).toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> boolean));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-15-字面量类型\"><a href=\"#1-15-字面量类型\" class=\"headerlink\" title=\"1.15 字面量类型\"></a>1.15 字面量类型</h3><p>可以把字符串、数字、布尔值字面量组成一个联合类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">type ZType = <span class=\"number\">1</span> | <span class=\"string\">'One'</span>|<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t1:ZType = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t2:ZType = <span class=\"string\">'One'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t3:ZType = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-16-字符串字面量-vs-联合类型\"><a href=\"#1-16-字符串字面量-vs-联合类型\" class=\"headerlink\" title=\"1.16 字符串字面量 vs 联合类型\"></a>1.16 字符串字面量 vs 联合类型</h3><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种<br>字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"1-布尔类型-boolean\"><a href=\"#1-布尔类型-boolean\" class=\"headerlink\" title=\"1.布尔类型(boolean)\"></a>1.布尔类型(boolean)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> isLzf: boolean=<span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2数字类型-number\"><a href=\"#1-2数字类型-number\" class=\"headerlink\" title=\"1.2数字类型(number)\"></a>1.2数字类型(number)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> age: number=<span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-字符串类型-string\"><a href=\"#1-3-字符串类型-string\" class=\"headerlink\" title=\"1.3 字符串类型(string)\"></a>1.3 字符串类型(string)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> firstname: string=<span class=\"string\">'lzf'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-数组类型-array\"><a href=\"#1-4-数组类型-array\" class=\"headerlink\" title=\"1.4 数组类型(array)\"></a>1.4 数组类型(array)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr2: number[]=[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3: <span class=\"built_in\">Array</span>&lt;number&gt;=[<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-元组类型-tuple\"><a href=\"#1-5-元组类型-tuple\" class=\"headerlink\" title=\"1.5 元组类型(tuple)\"></a>1.5 元组类型(tuple)</h3><p>在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zf:[string,number] = [<span class=\"string\">'zf'</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">zf[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">zf[<span class=\"number\">1</span>].toFixed(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>元组    数组<br>每一项可以是不同的类型    每一项都是同一种类型<br>有预定义的长度    没有长度限制<br>用于表示一个固定的结构    用于表示一个列表</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> animal:[string,number,boolean] = [<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-枚举类型-enum\"><a href=\"#1-6-枚举类型-enum\" class=\"headerlink\" title=\"1.6 枚举类型(enum)\"></a>1.6 枚举类型(enum)</h3><p>事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值<br>比如性别、月份、星期、颜色、单位、学历</p>\n<h4 id=\"1-6-1-普通枚举\"><a href=\"#1-6-1-普通枚举\" class=\"headerlink\" title=\"1.6.1 普通枚举\"></a>1.6.1 普通枚举</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Gender&#123;</span><br><span class=\"line\">    GIRL,</span><br><span class=\"line\">    BOY</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`lzf是<span class=\"subst\">$&#123;Gender.BOY&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`zf<span class=\"subst\">$&#123;Gender.GIRL&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">enum Week&#123;</span><br><span class=\"line\">    MONDAY=<span class=\"number\">1</span>,</span><br><span class=\"line\">    TUESDAY=<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`今天是星期<span class=\"subst\">$&#123;Week.MONDAY&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-6-2-常数枚举\"><a href=\"#1-6-2-常数枚举\" class=\"headerlink\" title=\"1.6.2 常数枚举\"></a>1.6.2 常数枚举</h4><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。<br>假如包含了计算成员，则会在编译阶段报错</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> enum Colors &#123;</span><br><span class=\"line\">    Red,</span><br><span class=\"line\">    Yellow,</span><br><span class=\"line\">    Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myColors = [Colors.Red, Colors.Yellow, Colors.Blue];</span><br><span class=\"line\"><span class=\"keyword\">const</span> enum Color &#123;Red, Yellow, Blue = <span class=\"string\">\"blue\"</span>.length&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-任意类型-any\"><a href=\"#1-7-任意类型-any\" class=\"headerlink\" title=\"1.7 任意类型(any)\"></a>1.7 任意类型(any)</h3><p>any就是可以赋值给任意类型<br>第三方库没有提供类型文件时可以使用any<br>类型转换遇到困难时<br>数据结构太复杂难以定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> root:any=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root.style.color=<span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> root:(HTMLElement|<span class=\"literal\">null</span>)=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root!.style.color=<span class=\"string\">'red'</span>;<span class=\"comment\">//非空断言操作符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-8-null-和-undefined\"><a href=\"#1-8-null-和-undefined\" class=\"headerlink\" title=\"1.8 null 和 undefined\"></a>1.8 null 和 undefined</h3><p>null 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined<br>strictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: number;</span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\">x = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> y: number | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"number\">1</span>;</span><br><span class=\"line\">y = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-void-类型\"><a href=\"#1-9-void-类型\" class=\"headerlink\" title=\"1.9 void 类型\"></a>1.9 void 类型</h3><p>void 表示没有任何类型<br>当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeting</span>(<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">    <span class=\"comment\">//当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//严格模式(strictNullChecks:true)下只能返回undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//return null;</span></span><br><span class=\"line\">    <span class=\"comment\">//return undefined;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-10-never类型\"><a href=\"#1-10-never类型\" class=\"headerlink\" title=\"1.10 never类型\"></a>1.10 never类型</h3><p>never是其它类型(null undefined)的子类型，代表不会出现的值<br>作为不会返回（ return ）的函数的返回值类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: string</span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = error(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 由类型推论得到返回值为 never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = fail();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-1-strictNullChecks\"><a href=\"#1-10-1-strictNullChecks\" class=\"headerlink\" title=\"1.10.1 strictNullChecks\"></a>1.10.1 strictNullChecks</h4><p>在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 –strictNullChecks 这一种检查模式<br>由于引入了 –strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Compiled with --strictNullChecks</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">x: number | string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: number 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: string 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: never 类型</span></span><br><span class=\"line\">    <span class=\"comment\">// --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-2-never-和-void-的区别、\"><a href=\"#1-10-2-never-和-void-的区别、\" class=\"headerlink\" title=\"1.10.2 never 和 void 的区别、\"></a>1.10.2 never 和 void 的区别、</h4><p>void 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。<br>拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。<br>1.11 类型推论<br>是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性<br>定义时未赋值就会推论成any类型<br>如果定义的时候就赋值就能利用到类型推论</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username2;</span><br><span class=\"line\">username2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">username2 = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">username2 = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-12-包装对象（Wrapper-Object）\"><a href=\"#1-12-包装对象（Wrapper-Object）\" class=\"headerlink\" title=\"1.12 包装对象（Wrapper Object）\"></a>1.12 包装对象（Wrapper Object）</h3><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>所有的原始数据类型都没有属性（property）<br>原始数据类型<br>布尔值<br>数值<br>字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toUpperCase());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'zf'</span>)).toUpperCase());</span><br><span class=\"line\">当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换</span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"literal\">true</span>; <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>) <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>); <span class=\"comment\">// 编译失败   期望的 isOK 是一个原始数据类型</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-13-联合类型\"><a href=\"#1-13-联合类型\" class=\"headerlink\" title=\"1.13 联合类型\"></a>1.13 联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种<br>未赋值时联合类型上只能访问两个类型共有的属性和方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: string | number;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toString());</span><br><span class=\"line\">name = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\">name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-14-类型断言\"><a href=\"#1-14-类型断言\" class=\"headerlink\" title=\"1.14 类型断言\"></a>1.14 类型断言</h3><p>类型断言可以将一个联合类型的变量，指定为一个更加具体的类型<br>不能将联合类型断言为不存在的类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: string | number;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> string).length);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> number).toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> boolean));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-15-字面量类型\"><a href=\"#1-15-字面量类型\" class=\"headerlink\" title=\"1.15 字面量类型\"></a>1.15 字面量类型</h3><p>可以把字符串、数字、布尔值字面量组成一个联合类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">type ZType = <span class=\"number\">1</span> | <span class=\"string\">'One'</span>|<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t1:ZType = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t2:ZType = <span class=\"string\">'One'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t3:ZType = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-16-字符串字面量-vs-联合类型\"><a href=\"#1-16-字符串字面量-vs-联合类型\" class=\"headerlink\" title=\"1.16 字符串字面量 vs 联合类型\"></a>1.16 字符串字面量 vs 联合类型</h3><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种<br>字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckbp5jhts0002w8sx3x2zfre7","category_id":"ckbp5jhtv0003w8sxhevn4xs1","_id":"ckbp5jhtx0006w8sxgx7f4o8v"},{"post_id":"ckbp5jhu00007w8sx3rksaqov","category_id":"ckbp5jhtv0003w8sxhevn4xs1","_id":"ckbp5jhu10009w8sxg9892mg0"}],"PostTag":[{"post_id":"ckbp5jhts0002w8sx3x2zfre7","tag_id":"ckbp5jhtw0004w8sxhy1h9dsc","_id":"ckbp5jhtx0005w8sx14ir5xzf"},{"post_id":"ckbp5jhu00007w8sx3rksaqov","tag_id":"ckbp5jhtw0004w8sxhy1h9dsc","_id":"ckbp5jhu10008w8sx935oh7fx"}],"Tag":[{"name":"typescript","_id":"ckbp5jhtw0004w8sxhy1h9dsc"}]}}