{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":0,"renderable":1},{"_id":"themes/Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/blog.js","path":"js/blog.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Anisina/.gitignore","hash":"7a2d5c9a8f18e75645eabbeacbf0ee83ba15e854","modified":1589653314689},{"_id":"themes/Anisina/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1589653314689},{"_id":"themes/Anisina/README.md","hash":"6090746aeee0e5ad4ad0107b85e808e6f3937f98","modified":1589653314689},{"_id":"themes/Anisina/_config.yml","hash":"5baf18c53f7635cd35aa5a8dab8abc08251023ce","modified":1589699399869},{"_id":"themes/Anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1589653314721},{"_id":"source/about/index.md","hash":"fa7843d236147bbeb738bdee72321e71e3f839b4","modified":1592758290915},{"_id":"source/categories/index.md","hash":"d0b7145a7592ad02fdc8cd7c52ac4b287c710045","modified":1589698714969},{"_id":"source/tags/index.md","hash":"5d041400f798de850b8400958e1dee8d0484d735","modified":1592743775977},{"_id":"themes/Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1589653314689},{"_id":"themes/Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1589653314721},{"_id":"themes/Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1589653314721},{"_id":"themes/Anisina/layout/.DS_Store","hash":"fd623c7cbe0d8fd902f6ca242127fd8db7da6c18","modified":1589653314721},{"_id":"themes/Anisina/layout/layout.ejs","hash":"b728827bf3ec55baf96a882032397e6c74c65f34","modified":1589653314721},{"_id":"themes/Anisina/layout/categories.ejs","hash":"055ac64a3ba036e29ff984fd886d57d580bbbff6","modified":1589653314721},{"_id":"themes/Anisina/layout/index.ejs","hash":"a0eaee13571e79c3632e23a9e94ccc991761d1f5","modified":1589653314721},{"_id":"themes/Anisina/layout/poetry.ejs","hash":"ef66c2e1b5139f9049fdd7e1d994ede8cd648334","modified":1592753405183},{"_id":"themes/Anisina/layout/tags.ejs","hash":"a5b73e70540e12532aa92f12609b3a937a8bc28b","modified":1589653314721},{"_id":"themes/Anisina/layout/post.ejs","hash":"1a7d9837be94f32080ff3877d5e2bec3913b6d4f","modified":1589729075462},{"_id":"themes/Anisina/layout/page.ejs","hash":"e32025f588c77976100ff1aaa8d0c0490536616b","modified":1592750989081},{"_id":"themes/Anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1589653314721},{"_id":"themes/Anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1589653314705},{"_id":"source/_posts/page/typescript函数.md","hash":"0affaa963fe89bfe02febd5bdba26860c764c728","modified":1592743684185},{"_id":"source/_posts/page/typescript基本数据类型.md","hash":"903e55337d42038658e62b9a408721ac2c855988","modified":1592743689437},{"_id":"source/_posts/page/typescript开发自动修复.md","hash":"6fe799d1ab05261f37f4f8a513cfa8c9fc62ddd5","modified":1592757661450},{"_id":"source/_posts/page/typescript类.md","hash":"3f4832e1520f5c282be0e6fb9ab521bade7b07ce","modified":1592757199833},{"_id":"themes/Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1589653314689},{"_id":"themes/Anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1589653314721},{"_id":"themes/Anisina/source/css/blog-style.css","hash":"e5880351fdf2c2222a3e5415a47f406fcc0eecc5","modified":1589696777102},{"_id":"themes/Anisina/layout/_partial/head.ejs","hash":"4e0d96cac503d4e3a5b254d8b8175c392971ce38","modified":1589653314721},{"_id":"themes/Anisina/layout/_partial/nav.ejs","hash":"1341f0c6b5527e30f418a37134cb0aa63be1e936","modified":1589698219457},{"_id":"themes/Anisina/layout/_partial/footer.ejs","hash":"f0f10f570abce5408d0742ab01a770fe72e1cc87","modified":1592750978636},{"_id":"themes/Anisina/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1589653314736},{"_id":"themes/Anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1589653314736},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1589653314721},{"_id":"themes/Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1589653314736},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1589653314736},{"_id":"themes/Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1589653314736},{"_id":"themes/Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1589653314705},{"_id":"themes/Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1589653314721},{"_id":"themes/Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1589653314736},{"_id":"themes/Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1589653314736},{"_id":"themes/Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1589653314705},{"_id":"themes/Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1589653314705},{"_id":"themes/Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1589653314705},{"_id":"public/about/index.html","hash":"91cd9ebb927369777ba0bc2776f71d0e13ee35c3","modified":1593174717876},{"_id":"public/tags/index.html","hash":"3a12cc9988f7462fa4ecce3ce4852f0c1b05f472","modified":1593174717876},{"_id":"public/categories/index.html","hash":"1cd387952d0c2948ec6dfd842a914d5d2da22443","modified":1593174717876},{"_id":"public/archives/2019/index.html","hash":"c3f8e4b779ad3a2e86794c91a3a818bbf4ce0b46","modified":1593174717876},{"_id":"public/archives/2019/05/index.html","hash":"37b6e517beeac917241f638604882f98a26d1427","modified":1593174717876},{"_id":"public/archives/2020/index.html","hash":"fa28d0af7f30f5c3403d16c8840e45dd3e5b4b61","modified":1593174717876},{"_id":"public/archives/2020/05/index.html","hash":"ad9b342b7d1b576bd6edefdd188471d07ba1502d","modified":1593174717876},{"_id":"public/2020/05/22/page/typescript类/index.html","hash":"f6161635bc5e0cde25a3bd83a6ca5561c3c05007","modified":1593174717876},{"_id":"public/2019/05/21/page/typescript开发自动修复/index.html","hash":"001b08db78ff706fdc0e9852e5715b85a0fb2852","modified":1593174717876},{"_id":"public/2019/05/17/page/typescript基本数据类型/index.html","hash":"ade6027a7489cb0cd6f6b1d121c7f786f8357de6","modified":1593174717876},{"_id":"public/2019/05/17/page/typescript函数/index.html","hash":"51fa53d5bd37eb0318f19736d6a87927dd1ee443","modified":1593174717876},{"_id":"public/archives/index.html","hash":"b0f8dc51d7a78ac865f1f04aa177f7395219dc89","modified":1593174717876},{"_id":"public/categories/web前端/index.html","hash":"cfc109774501109a631966da127f9781c630684c","modified":1593174717876},{"_id":"public/tags/typescript/index.html","hash":"abbf110a47a8b5a565e87ef6e8ba303b3a48de26","modified":1593174717876},{"_id":"public/index.html","hash":"a0a51bf13b911e10dc2e224dbe7363e62a369c66","modified":1593174717876},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1593174717876},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1593174717876},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1593174717876},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1593174717876},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1593174717876},{"_id":"public/css/syntax.css","hash":"4616879fec214c9cc4f5835615348f0bbeabf2a9","modified":1593174717876},{"_id":"public/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1593174717876},{"_id":"public/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1593174717876},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1593174717876},{"_id":"public/css/blog-style.css","hash":"e5880351fdf2c2222a3e5415a47f406fcc0eecc5","modified":1593174717876},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1593174717876},{"_id":"public/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1593174717876},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1593174717876},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1593174717876}],"Category":[{"name":"web前端","_id":"ckbw73ckg00051gsxftz9g4v0"}],"Data":[],"Page":[{"title":"关于","date":"2020-06-21T15:05:47.000Z","layout":"poetry","_content":"\n## 个人信息\n\n- 龙兆峰/男\n- 本科/计算机科学与技术\n- 工作年限：4年\n- 技术博客：<https://lz-allen.github.io>\n- Github：<http://github.com/easychen>\n- 期望职位：高级前端工程师\n- 电话：13381678729\n\n## 技能清单\n\n- 熟练掌握 HTML，CSS ，熟练运用弹性盒子模型及 rem 布局\n- 掌握 HTML5+CSS3 新特性，根据设计图完成页面设计\n- 熟练掌握 JavaScript 语言，熟悉 ES5/ES6\n- 熟练使用第三方 JavaScript 库，比如 jQuery, Moment.js, lodash.js 等\n- 熟练 ajax、fetch 前端交互技术，熟悉 jsonp,cors,nginx 反向代理跨域，并且解决常见的跨域问题\n- 熟练掌握 Vue 并有基于 Vue + Vuex + Webpack + ES6 + Vue-Router 项目架构经验\n- 熟练掌握 React+ Redux + Router + JSX + dva\n- 熟悉 Node.js,Koa,Express 搭建后台服务端，进行前后端的数据交互\n- 熟悉 Nginx 配置，Pm2 服务部署，linux 环境的配置\n- 能熟练运用 Element,Antd ui 库，搭建后台管理系统\n- 熟悉 Less 预编译，Css 模块化，能在项目中熟练的运用\n\n## 致谢\n\n感谢您花时间阅读我的简历，期待能有机会和您共事\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2020-06-21 23:05:47\nlayout: poetry\n---\n\n## 个人信息\n\n- 龙兆峰/男\n- 本科/计算机科学与技术\n- 工作年限：4年\n- 技术博客：<https://lz-allen.github.io>\n- Github：<http://github.com/easychen>\n- 期望职位：高级前端工程师\n- 电话：13381678729\n\n## 技能清单\n\n- 熟练掌握 HTML，CSS ，熟练运用弹性盒子模型及 rem 布局\n- 掌握 HTML5+CSS3 新特性，根据设计图完成页面设计\n- 熟练掌握 JavaScript 语言，熟悉 ES5/ES6\n- 熟练使用第三方 JavaScript 库，比如 jQuery, Moment.js, lodash.js 等\n- 熟练 ajax、fetch 前端交互技术，熟悉 jsonp,cors,nginx 反向代理跨域，并且解决常见的跨域问题\n- 熟练掌握 Vue 并有基于 Vue + Vuex + Webpack + ES6 + Vue-Router 项目架构经验\n- 熟练掌握 React+ Redux + Router + JSX + dva\n- 熟悉 Node.js,Koa,Express 搭建后台服务端，进行前后端的数据交互\n- 熟悉 Nginx 配置，Pm2 服务部署，linux 环境的配置\n- 能熟练运用 Element,Antd ui 库，搭建后台管理系统\n- 熟悉 Less 预编译，Css 模块化，能在项目中熟练的运用\n\n## 致谢\n\n感谢您花时间阅读我的简历，期待能有机会和您共事\n","updated":"2020-06-21T16:51:30.915Z","path":"about/index.html","comments":1,"_id":"ckbw73ck300001gsxcund9se3","content":"<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>龙兆峰/男</li>\n<li>本科/计算机科学与技术</li>\n<li>工作年限：4年</li>\n<li>技术博客：<a href=\"https://lz-allen.github.io\">https://lz-allen.github.io</a></li>\n<li>Github：<a href=\"http://github.com/easychen\" target=\"_blank\" rel=\"noopener\">http://github.com/easychen</a></li>\n<li>期望职位：高级前端工程师</li>\n<li>电话：13381678729</li>\n</ul>\n<h2 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\"技能清单\"></a>技能清单</h2><ul>\n<li>熟练掌握 HTML，CSS ，熟练运用弹性盒子模型及 rem 布局</li>\n<li>掌握 HTML5+CSS3 新特性，根据设计图完成页面设计</li>\n<li>熟练掌握 JavaScript 语言，熟悉 ES5/ES6</li>\n<li>熟练使用第三方 JavaScript 库，比如 jQuery, Moment.js, lodash.js 等</li>\n<li>熟练 ajax、fetch 前端交互技术，熟悉 jsonp,cors,nginx 反向代理跨域，并且解决常见的跨域问题</li>\n<li>熟练掌握 Vue 并有基于 Vue + Vuex + Webpack + ES6 + Vue-Router 项目架构经验</li>\n<li>熟练掌握 React+ Redux + Router + JSX + dva</li>\n<li>熟悉 Node.js,Koa,Express 搭建后台服务端，进行前后端的数据交互</li>\n<li>熟悉 Nginx 配置，Pm2 服务部署，linux 环境的配置</li>\n<li>能熟练运用 Element,Antd ui 库，搭建后台管理系统</li>\n<li>熟悉 Less 预编译，Css 模块化，能在项目中熟练的运用</li>\n</ul>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>感谢您花时间阅读我的简历，期待能有机会和您共事</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>龙兆峰/男</li>\n<li>本科/计算机科学与技术</li>\n<li>工作年限：4年</li>\n<li>技术博客：<a href=\"https://lz-allen.github.io\">https://lz-allen.github.io</a></li>\n<li>Github：<a href=\"http://github.com/easychen\" target=\"_blank\" rel=\"noopener\">http://github.com/easychen</a></li>\n<li>期望职位：高级前端工程师</li>\n<li>电话：13381678729</li>\n</ul>\n<h2 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\"技能清单\"></a>技能清单</h2><ul>\n<li>熟练掌握 HTML，CSS ，熟练运用弹性盒子模型及 rem 布局</li>\n<li>掌握 HTML5+CSS3 新特性，根据设计图完成页面设计</li>\n<li>熟练掌握 JavaScript 语言，熟悉 ES5/ES6</li>\n<li>熟练使用第三方 JavaScript 库，比如 jQuery, Moment.js, lodash.js 等</li>\n<li>熟练 ajax、fetch 前端交互技术，熟悉 jsonp,cors,nginx 反向代理跨域，并且解决常见的跨域问题</li>\n<li>熟练掌握 Vue 并有基于 Vue + Vuex + Webpack + ES6 + Vue-Router 项目架构经验</li>\n<li>熟练掌握 React+ Redux + Router + JSX + dva</li>\n<li>熟悉 Node.js,Koa,Express 搭建后台服务端，进行前后端的数据交互</li>\n<li>熟悉 Nginx 配置，Pm2 服务部署，linux 环境的配置</li>\n<li>能熟练运用 Element,Antd ui 库，搭建后台管理系统</li>\n<li>熟悉 Less 预编译，Css 模块化，能在项目中熟练的运用</li>\n</ul>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>感谢您花时间阅读我的简历，期待能有机会和您共事</p>\n"},{"title":"标签","date":"2020-06-21T12:49:20.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-06-21 20:49:20\nlayout: tags\n---\n","updated":"2020-06-21T12:49:35.977Z","path":"tags/index.html","comments":1,"_id":"ckbw73ck600011gsx6tjt8y0v","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章分类","date":"2020-05-17T06:55:09.000Z","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2020-05-17 14:55:09\nlayout: categories\n---\n","updated":"2020-05-17T06:58:34.969Z","path":"categories/index.html","comments":1,"_id":"ckbw73ck600021gsxh8m5gjqp","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ESLint自动修复","author":"lz_allen","date":"2019-05-21T15:59:31.000Z","_content":"\n## 模块安装\n\n```javascript\ncnpm i eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev\n```\n\n## eslintrc配置文件\n\n- .eslintrc.js\n\n```javascript\nmodule.exports = {\n    \"parser\":\"@typescript-eslint/parser\",\n    \"plugins\":[\"@typescript-eslint\"],\n    \"rules\":{\n        \"no-var\":\"error\",\n        \"no-extra-semi\":\"error\",\n        \"@typescript-eslint/indent\":[\"error\",2]\n    },\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\",\n        \"ecmaFeatures\": {\n          \"modules\": true\n        }\n    }\n}\n```\n\n## ESLint自动修复\n\n安装vscode的eslint插件\n配置参数 .vscode\\settings.json\n\n```javascript\n{\n  \"eslint.autoFixOnSave\": true,\n  \"eslint.validate\": [\n      \"javascript\",\n      \"javascriptreact\",\n      {\n          \"language\": \"typescript\",\n          \"autoFix\": true\n      },\n       {\n          \"language\": \"typescriptreact\",\n          \"autoFix\": true\n      }\n  ]\n}\n```\n\n## Git Hooks 检查\n\n- Git 基本已经成为项目开发中默认的版本管理软件，在使用 Git 的项目中，我们可以为项目设置 Git Hooks 来帮我们在提交代码的各个阶段做一些代码检查等工作\n- 钩子（Hooks） 都被存储在 Git 目录下的 hooks 子目录中。 也就是绝大部分项目中的 .git/hooks 目录\n- 钩子分为两大类，客户端的和服务器端的\n  - 客户端钩子主要被提交和合并这样的操作所调用\n  - 而服务器端钩子作用于接收被推送的提交这样的联网操作，这里我们主要介绍客户端钩子\n\n### pre-commit\n\n- pre-commit 就是在代码提交之前做些东西，比如代码打包，代码检测，称之为钩子（hook）\n- 在commit之前执行一个函数（callback）。这个函数成功执行完之后，再继续commit，但是失败之后就阻止commit\n- 在.git->hooks->下面有个pre-commit.sample*，这个里面就是默认的函数(脚本)样本\n\n### 安装pre-commit、\n\n```javascript\nnpm install pre-commit --save-dev\n```\n\n### 脚本配置\n\n```javascript\n \"scripts\": {\n    \"build\": \"tsc\",\n    \"eslint\": \"eslint src --ext .ts\",\n    \"eslint:fix\": \"eslint src --ext .ts --fix\"\n  },\n  \"pre-commit\": [\n    \"eslint\"\n  ]\n```\n\n","source":"_posts/page/typescript开发自动修复.md","raw":"---\ntitle: ESLint自动修复\ncategories: web前端\nauthor: lz_allen\ntags:\n  - typescript\ndate: 2019-05-21 23:59:31\n---\n\n## 模块安装\n\n```javascript\ncnpm i eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev\n```\n\n## eslintrc配置文件\n\n- .eslintrc.js\n\n```javascript\nmodule.exports = {\n    \"parser\":\"@typescript-eslint/parser\",\n    \"plugins\":[\"@typescript-eslint\"],\n    \"rules\":{\n        \"no-var\":\"error\",\n        \"no-extra-semi\":\"error\",\n        \"@typescript-eslint/indent\":[\"error\",2]\n    },\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\",\n        \"ecmaFeatures\": {\n          \"modules\": true\n        }\n    }\n}\n```\n\n## ESLint自动修复\n\n安装vscode的eslint插件\n配置参数 .vscode\\settings.json\n\n```javascript\n{\n  \"eslint.autoFixOnSave\": true,\n  \"eslint.validate\": [\n      \"javascript\",\n      \"javascriptreact\",\n      {\n          \"language\": \"typescript\",\n          \"autoFix\": true\n      },\n       {\n          \"language\": \"typescriptreact\",\n          \"autoFix\": true\n      }\n  ]\n}\n```\n\n## Git Hooks 检查\n\n- Git 基本已经成为项目开发中默认的版本管理软件，在使用 Git 的项目中，我们可以为项目设置 Git Hooks 来帮我们在提交代码的各个阶段做一些代码检查等工作\n- 钩子（Hooks） 都被存储在 Git 目录下的 hooks 子目录中。 也就是绝大部分项目中的 .git/hooks 目录\n- 钩子分为两大类，客户端的和服务器端的\n  - 客户端钩子主要被提交和合并这样的操作所调用\n  - 而服务器端钩子作用于接收被推送的提交这样的联网操作，这里我们主要介绍客户端钩子\n\n### pre-commit\n\n- pre-commit 就是在代码提交之前做些东西，比如代码打包，代码检测，称之为钩子（hook）\n- 在commit之前执行一个函数（callback）。这个函数成功执行完之后，再继续commit，但是失败之后就阻止commit\n- 在.git->hooks->下面有个pre-commit.sample*，这个里面就是默认的函数(脚本)样本\n\n### 安装pre-commit、\n\n```javascript\nnpm install pre-commit --save-dev\n```\n\n### 脚本配置\n\n```javascript\n \"scripts\": {\n    \"build\": \"tsc\",\n    \"eslint\": \"eslint src --ext .ts\",\n    \"eslint:fix\": \"eslint src --ext .ts --fix\"\n  },\n  \"pre-commit\": [\n    \"eslint\"\n  ]\n```\n\n","slug":"page/typescript开发自动修复","published":1,"updated":"2020-06-21T16:41:01.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbw73ckc00031gsx2bqm6zwx","content":"<h2 id=\"模块安装\"><a href=\"#模块安装\" class=\"headerlink\" title=\"模块安装\"></a>模块安装</h2><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm i eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"eslintrc配置文件\"><a href=\"#eslintrc配置文件\" class=\"headerlink\" title=\"eslintrc配置文件\"></a>eslintrc配置文件</h2><ul>\n<li>.eslintrc.js</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"parser\"</span>:<span class=\"string\">\"@typescript-eslint/parser\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"plugins\"</span>:[<span class=\"string\">\"@typescript-eslint\"</span>],</span><br><span class=\"line\">    <span class=\"string\">\"rules\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"no-var\"</span>:<span class=\"string\">\"error\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"no-extra-semi\"</span>:<span class=\"string\">\"error\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"@typescript-eslint/indent\"</span>:[<span class=\"string\">\"error\"</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"parserOptions\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"ecmaVersion\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">        <span class=\"string\">\"sourceType\"</span>: <span class=\"string\">\"module\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"ecmaFeatures\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">\"modules\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ESLint自动修复\"><a href=\"#ESLint自动修复\" class=\"headerlink\" title=\"ESLint自动修复\"></a>ESLint自动修复</h2><p>安装vscode的eslint插件<br>配置参数 .vscode\\settings.json</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"eslint.autoFixOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"string\">\"eslint.validate\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"javascriptreact\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"string\">\"language\"</span>: <span class=\"string\">\"typescript\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"autoFix\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">          <span class=\"string\">\"language\"</span>: <span class=\"string\">\"typescriptreact\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"autoFix\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Git-Hooks-检查\"><a href=\"#Git-Hooks-检查\" class=\"headerlink\" title=\"Git Hooks 检查\"></a>Git Hooks 检查</h2><ul>\n<li>Git 基本已经成为项目开发中默认的版本管理软件，在使用 Git 的项目中，我们可以为项目设置 Git Hooks 来帮我们在提交代码的各个阶段做一些代码检查等工作</li>\n<li>钩子（Hooks） 都被存储在 Git 目录下的 hooks 子目录中。 也就是绝大部分项目中的 .git/hooks 目录</li>\n<li>钩子分为两大类，客户端的和服务器端的<ul>\n<li>客户端钩子主要被提交和合并这样的操作所调用</li>\n<li>而服务器端钩子作用于接收被推送的提交这样的联网操作，这里我们主要介绍客户端钩子</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"pre-commit\"><a href=\"#pre-commit\" class=\"headerlink\" title=\"pre-commit\"></a>pre-commit</h3><ul>\n<li>pre-commit 就是在代码提交之前做些东西，比如代码打包，代码检测，称之为钩子（hook）</li>\n<li>在commit之前执行一个函数（callback）。这个函数成功执行完之后，再继续commit，但是失败之后就阻止commit</li>\n<li>在.git-&gt;hooks-&gt;下面有个pre-commit.sample*，这个里面就是默认的函数(脚本)样本</li>\n</ul>\n<h3 id=\"安装pre-commit、\"><a href=\"#安装pre-commit、\" class=\"headerlink\" title=\"安装pre-commit、\"></a>安装pre-commit、</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install pre-commit --save-dev</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"脚本配置\"><a href=\"#脚本配置\" class=\"headerlink\" title=\"脚本配置\"></a>脚本配置</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">   <span class=\"string\">\"build\"</span>: <span class=\"string\">\"tsc\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"eslint\"</span>: <span class=\"string\">\"eslint src --ext .ts\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"eslint:fix\"</span>: <span class=\"string\">\"eslint src --ext .ts --fix\"</span></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> <span class=\"string\">\"pre-commit\"</span>: [</span><br><span class=\"line\">   <span class=\"string\">\"eslint\"</span></span><br><span class=\"line\"> ]</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"模块安装\"><a href=\"#模块安装\" class=\"headerlink\" title=\"模块安装\"></a>模块安装</h2><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm i eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"eslintrc配置文件\"><a href=\"#eslintrc配置文件\" class=\"headerlink\" title=\"eslintrc配置文件\"></a>eslintrc配置文件</h2><ul>\n<li>.eslintrc.js</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"parser\"</span>:<span class=\"string\">\"@typescript-eslint/parser\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"plugins\"</span>:[<span class=\"string\">\"@typescript-eslint\"</span>],</span><br><span class=\"line\">    <span class=\"string\">\"rules\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"no-var\"</span>:<span class=\"string\">\"error\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"no-extra-semi\"</span>:<span class=\"string\">\"error\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"@typescript-eslint/indent\"</span>:[<span class=\"string\">\"error\"</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"parserOptions\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"ecmaVersion\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">        <span class=\"string\">\"sourceType\"</span>: <span class=\"string\">\"module\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"ecmaFeatures\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">\"modules\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ESLint自动修复\"><a href=\"#ESLint自动修复\" class=\"headerlink\" title=\"ESLint自动修复\"></a>ESLint自动修复</h2><p>安装vscode的eslint插件<br>配置参数 .vscode\\settings.json</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"eslint.autoFixOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"string\">\"eslint.validate\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"javascriptreact\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"string\">\"language\"</span>: <span class=\"string\">\"typescript\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"autoFix\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">          <span class=\"string\">\"language\"</span>: <span class=\"string\">\"typescriptreact\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"autoFix\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Git-Hooks-检查\"><a href=\"#Git-Hooks-检查\" class=\"headerlink\" title=\"Git Hooks 检查\"></a>Git Hooks 检查</h2><ul>\n<li>Git 基本已经成为项目开发中默认的版本管理软件，在使用 Git 的项目中，我们可以为项目设置 Git Hooks 来帮我们在提交代码的各个阶段做一些代码检查等工作</li>\n<li>钩子（Hooks） 都被存储在 Git 目录下的 hooks 子目录中。 也就是绝大部分项目中的 .git/hooks 目录</li>\n<li>钩子分为两大类，客户端的和服务器端的<ul>\n<li>客户端钩子主要被提交和合并这样的操作所调用</li>\n<li>而服务器端钩子作用于接收被推送的提交这样的联网操作，这里我们主要介绍客户端钩子</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"pre-commit\"><a href=\"#pre-commit\" class=\"headerlink\" title=\"pre-commit\"></a>pre-commit</h3><ul>\n<li>pre-commit 就是在代码提交之前做些东西，比如代码打包，代码检测，称之为钩子（hook）</li>\n<li>在commit之前执行一个函数（callback）。这个函数成功执行完之后，再继续commit，但是失败之后就阻止commit</li>\n<li>在.git-&gt;hooks-&gt;下面有个pre-commit.sample*，这个里面就是默认的函数(脚本)样本</li>\n</ul>\n<h3 id=\"安装pre-commit、\"><a href=\"#安装pre-commit、\" class=\"headerlink\" title=\"安装pre-commit、\"></a>安装pre-commit、</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install pre-commit --save-dev</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"脚本配置\"><a href=\"#脚本配置\" class=\"headerlink\" title=\"脚本配置\"></a>脚本配置</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">   <span class=\"string\">\"build\"</span>: <span class=\"string\">\"tsc\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"eslint\"</span>: <span class=\"string\">\"eslint src --ext .ts\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"eslint:fix\"</span>: <span class=\"string\">\"eslint src --ext .ts --fix\"</span></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> <span class=\"string\">\"pre-commit\"</span>: [</span><br><span class=\"line\">   <span class=\"string\">\"eslint\"</span></span><br><span class=\"line\"> ]</span><br></pre></td></tr></table></figure>\n\n"},{"title":"TypeScript基本数据类型","date":"2019-05-17T07:19:26.000Z","_content":"\n## 数据类型\n\n### 1.布尔类型(boolean)\n\n```javascript\n\nlet isLzf: boolean=false;\n\n```\n\n### 1.2数字类型(number)\n\n```javascript\nlet age: number=10;\n```\n\n### 1.3 字符串类型(string)\n\n```javascript\nlet firstname: string='lzf';\n```\n\n### 1.4 数组类型(array)\n\n```javascript\nlet arr2: number[]=[4,5,6];\nlet arr3: Array<number>=[7,8,9];\n```\n\n### 1.5 元组类型(tuple)\n\n在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组\n\n```javascript\nlet zf:[string,number] = ['zf',5];\nzf[0].length;\nzf[1].toFixed(2);\n```\n\n元组\t数组\n每一项可以是不同的类型\t每一项都是同一种类型\n有预定义的长度\t没有长度限制\n用于表示一个固定的结构\t用于表示一个列表\n\n```javascript\nconst animal:[string,number,boolean] = ['zf',10,true];\n```\n\n### 1.6 枚举类型(enum)\n\n事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值\n比如性别、月份、星期、颜色、单位、学历\n\n#### 1.6.1 普通枚举\n\n```javascript\nenum Gender{\n    GIRL,\n    BOY\n}\nconsole.log(`lzf是${Gender.BOY}`);\nconsole.log(`zf${Gender.GIRL}`);\n\nenum Week{\n    MONDAY=1,\n    TUESDAY=2\n}\nconsole.log(`今天是星期${Week.MONDAY}`);\n```\n\n#### 1.6.2 常数枚举\n\n常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n假如包含了计算成员，则会在编译阶段报错\n\n```javascript\nconst enum Colors {\n    Red,\n    Yellow,\n    Blue\n}\n\nlet myColors = [Colors.Red, Colors.Yellow, Colors.Blue];\nconst enum Color {Red, Yellow, Blue = \"blue\".length};\n```\n\n### 1.7 任意类型(any)\n\nany就是可以赋值给任意类型\n第三方库没有提供类型文件时可以使用any\n类型转换遇到困难时\n数据结构太复杂难以定义\n\n```javascript\nlet root:any=document.getElementById('root');\nroot.style.color='red';\nlet root:(HTMLElement|null)=document.getElementById('root');\nroot!.style.color='red';//非空断言操作符\n```\n\n### 1.8 null 和 undefined\n\nnull 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined\nstrictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any\n\n```javascript\nlet x: number;\nx = 1;\nx = undefined;\nx = null;\n\nlet y: number | null | undefined;\ny = 1;\ny = undefined;\ny = null;\n```\n\n### 1.9 void 类型\n\nvoid 表示没有任何类型\n当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。\n\n```javascript\nfunction greeting(name:string):void {\n    console.log('hello',name);\n    //当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined\n    //严格模式(strictNullChecks:true)下只能返回undefined\n    //return null;\n    //return undefined;\n}\n```\n\n### 1.10 never类型\n\nnever是其它类型(null undefined)的子类型，代表不会出现的值\n作为不会返回（ return ）的函数的返回值类型\n\n```javascript\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\nlet result1 = error('hello');\n// 由类型推论得到返回值为 never\nfunction fail() {\n    return error(\"Something failed\");\n}\nlet result = fail();\n\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction infiniteLoop(): never {\n    while (true) {}\n}\n```\n\n#### 1.10.1 strictNullChecks\n\n在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 --strictNullChecks 这一种检查模式\n由于引入了 --strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。\n\n```javascript\n// Compiled with --strictNullChecks\nfunction fn(x: number | string) {\n  if (typeof x === 'number') {\n    // x: number 类型\n  } else if (typeof x === 'string') {\n    // x: string 类型\n  } else {\n    // x: never 类型\n    // --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察\n  }\n}\n```\n\n#### 1.10.2 never 和 void 的区别、\n\nvoid 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。\n拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。\n1.11 类型推论\n是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性\n定义时未赋值就会推论成any类型\n如果定义的时候就赋值就能利用到类型推论\n\n```javascript\nlet username2;\nusername2 = 10;\nusername2 = 'zf';\nusername2 = null;\n```\n\n### 1.12 包装对象（Wrapper Object）\n\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n所有的原始数据类型都没有属性（property）\n原始数据类型\n布尔值\n数值\n字符串\n\n```javascript\nnull\nundefined\nSymbol\nlet name = 'zf';\nconsole.log(name.toUpperCase());\nconsole.log((new String('zf')).toUpperCase());\n当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换\nlet isOK: boolean = true; // 编译通过\nlet isOK: boolean = Boolean(1) // 编译通过\nlet isOK: boolean = new Boolean(1); // 编译失败   期望的 isOK 是一个原始数据类型\n```\n\n### 1.13 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种\n未赋值时联合类型上只能访问两个类型共有的属性和方法\n\n```javascript\nlet name: string | number;\nconsole.log(name.toString());\nname = 3;\nconsole.log(name.toFixed(2));\nname = 'zf';\nconsole.log(name.length);\n\nexport {};\n```\n\n### 1.14 类型断言\n\n类型断言可以将一个联合类型的变量，指定为一个更加具体的类型\n不能将联合类型断言为不存在的类型\n\n```javascript\nlet name: string | number;\nconsole.log((name as string).length);\nconsole.log((name as number).toFixed(2));\nconsole.log((name as boolean));\n```\n\n### 1.15 字面量类型\n\n可以把字符串、数字、布尔值字面量组成一个联合类型\n\n```javascript\ntype ZType = 1 | 'One'|true;\nlet t1:ZType = 1;\nlet t2:ZType = 'One';\nlet t3:ZType = true;\n```\n\n### 1.16 字符串字面量 vs 联合类型\n\n字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种\n字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致\n","source":"_posts/page/typescript基本数据类型.md","raw":"---\ntitle: TypeScript基本数据类型\ntags:\n  - typescript\ncategories: web前端\ndate: 2019-05-17 15:19:26\n---\n\n## 数据类型\n\n### 1.布尔类型(boolean)\n\n```javascript\n\nlet isLzf: boolean=false;\n\n```\n\n### 1.2数字类型(number)\n\n```javascript\nlet age: number=10;\n```\n\n### 1.3 字符串类型(string)\n\n```javascript\nlet firstname: string='lzf';\n```\n\n### 1.4 数组类型(array)\n\n```javascript\nlet arr2: number[]=[4,5,6];\nlet arr3: Array<number>=[7,8,9];\n```\n\n### 1.5 元组类型(tuple)\n\n在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组\n\n```javascript\nlet zf:[string,number] = ['zf',5];\nzf[0].length;\nzf[1].toFixed(2);\n```\n\n元组\t数组\n每一项可以是不同的类型\t每一项都是同一种类型\n有预定义的长度\t没有长度限制\n用于表示一个固定的结构\t用于表示一个列表\n\n```javascript\nconst animal:[string,number,boolean] = ['zf',10,true];\n```\n\n### 1.6 枚举类型(enum)\n\n事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值\n比如性别、月份、星期、颜色、单位、学历\n\n#### 1.6.1 普通枚举\n\n```javascript\nenum Gender{\n    GIRL,\n    BOY\n}\nconsole.log(`lzf是${Gender.BOY}`);\nconsole.log(`zf${Gender.GIRL}`);\n\nenum Week{\n    MONDAY=1,\n    TUESDAY=2\n}\nconsole.log(`今天是星期${Week.MONDAY}`);\n```\n\n#### 1.6.2 常数枚举\n\n常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n假如包含了计算成员，则会在编译阶段报错\n\n```javascript\nconst enum Colors {\n    Red,\n    Yellow,\n    Blue\n}\n\nlet myColors = [Colors.Red, Colors.Yellow, Colors.Blue];\nconst enum Color {Red, Yellow, Blue = \"blue\".length};\n```\n\n### 1.7 任意类型(any)\n\nany就是可以赋值给任意类型\n第三方库没有提供类型文件时可以使用any\n类型转换遇到困难时\n数据结构太复杂难以定义\n\n```javascript\nlet root:any=document.getElementById('root');\nroot.style.color='red';\nlet root:(HTMLElement|null)=document.getElementById('root');\nroot!.style.color='red';//非空断言操作符\n```\n\n### 1.8 null 和 undefined\n\nnull 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined\nstrictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any\n\n```javascript\nlet x: number;\nx = 1;\nx = undefined;\nx = null;\n\nlet y: number | null | undefined;\ny = 1;\ny = undefined;\ny = null;\n```\n\n### 1.9 void 类型\n\nvoid 表示没有任何类型\n当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。\n\n```javascript\nfunction greeting(name:string):void {\n    console.log('hello',name);\n    //当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined\n    //严格模式(strictNullChecks:true)下只能返回undefined\n    //return null;\n    //return undefined;\n}\n```\n\n### 1.10 never类型\n\nnever是其它类型(null undefined)的子类型，代表不会出现的值\n作为不会返回（ return ）的函数的返回值类型\n\n```javascript\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\nlet result1 = error('hello');\n// 由类型推论得到返回值为 never\nfunction fail() {\n    return error(\"Something failed\");\n}\nlet result = fail();\n\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction infiniteLoop(): never {\n    while (true) {}\n}\n```\n\n#### 1.10.1 strictNullChecks\n\n在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 --strictNullChecks 这一种检查模式\n由于引入了 --strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。\n\n```javascript\n// Compiled with --strictNullChecks\nfunction fn(x: number | string) {\n  if (typeof x === 'number') {\n    // x: number 类型\n  } else if (typeof x === 'string') {\n    // x: string 类型\n  } else {\n    // x: never 类型\n    // --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察\n  }\n}\n```\n\n#### 1.10.2 never 和 void 的区别、\n\nvoid 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。\n拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。\n1.11 类型推论\n是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性\n定义时未赋值就会推论成any类型\n如果定义的时候就赋值就能利用到类型推论\n\n```javascript\nlet username2;\nusername2 = 10;\nusername2 = 'zf';\nusername2 = null;\n```\n\n### 1.12 包装对象（Wrapper Object）\n\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n所有的原始数据类型都没有属性（property）\n原始数据类型\n布尔值\n数值\n字符串\n\n```javascript\nnull\nundefined\nSymbol\nlet name = 'zf';\nconsole.log(name.toUpperCase());\nconsole.log((new String('zf')).toUpperCase());\n当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换\nlet isOK: boolean = true; // 编译通过\nlet isOK: boolean = Boolean(1) // 编译通过\nlet isOK: boolean = new Boolean(1); // 编译失败   期望的 isOK 是一个原始数据类型\n```\n\n### 1.13 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种\n未赋值时联合类型上只能访问两个类型共有的属性和方法\n\n```javascript\nlet name: string | number;\nconsole.log(name.toString());\nname = 3;\nconsole.log(name.toFixed(2));\nname = 'zf';\nconsole.log(name.length);\n\nexport {};\n```\n\n### 1.14 类型断言\n\n类型断言可以将一个联合类型的变量，指定为一个更加具体的类型\n不能将联合类型断言为不存在的类型\n\n```javascript\nlet name: string | number;\nconsole.log((name as string).length);\nconsole.log((name as number).toFixed(2));\nconsole.log((name as boolean));\n```\n\n### 1.15 字面量类型\n\n可以把字符串、数字、布尔值字面量组成一个联合类型\n\n```javascript\ntype ZType = 1 | 'One'|true;\nlet t1:ZType = 1;\nlet t2:ZType = 'One';\nlet t3:ZType = true;\n```\n\n### 1.16 字符串字面量 vs 联合类型\n\n字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种\n字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致\n","slug":"page/typescript基本数据类型","published":1,"updated":"2020-06-21T12:48:09.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbw73ckf00041gsx27ry2cni","content":"<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"1-布尔类型-boolean\"><a href=\"#1-布尔类型-boolean\" class=\"headerlink\" title=\"1.布尔类型(boolean)\"></a>1.布尔类型(boolean)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> isLzf: boolean=<span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2数字类型-number\"><a href=\"#1-2数字类型-number\" class=\"headerlink\" title=\"1.2数字类型(number)\"></a>1.2数字类型(number)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> age: number=<span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-字符串类型-string\"><a href=\"#1-3-字符串类型-string\" class=\"headerlink\" title=\"1.3 字符串类型(string)\"></a>1.3 字符串类型(string)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> firstname: string=<span class=\"string\">'lzf'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-数组类型-array\"><a href=\"#1-4-数组类型-array\" class=\"headerlink\" title=\"1.4 数组类型(array)\"></a>1.4 数组类型(array)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr2: number[]=[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3: <span class=\"built_in\">Array</span>&lt;number&gt;=[<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-元组类型-tuple\"><a href=\"#1-5-元组类型-tuple\" class=\"headerlink\" title=\"1.5 元组类型(tuple)\"></a>1.5 元组类型(tuple)</h3><p>在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zf:[string,number] = [<span class=\"string\">'zf'</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">zf[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">zf[<span class=\"number\">1</span>].toFixed(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>元组    数组<br>每一项可以是不同的类型    每一项都是同一种类型<br>有预定义的长度    没有长度限制<br>用于表示一个固定的结构    用于表示一个列表</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> animal:[string,number,boolean] = [<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-枚举类型-enum\"><a href=\"#1-6-枚举类型-enum\" class=\"headerlink\" title=\"1.6 枚举类型(enum)\"></a>1.6 枚举类型(enum)</h3><p>事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值<br>比如性别、月份、星期、颜色、单位、学历</p>\n<h4 id=\"1-6-1-普通枚举\"><a href=\"#1-6-1-普通枚举\" class=\"headerlink\" title=\"1.6.1 普通枚举\"></a>1.6.1 普通枚举</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Gender&#123;</span><br><span class=\"line\">    GIRL,</span><br><span class=\"line\">    BOY</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`lzf是<span class=\"subst\">$&#123;Gender.BOY&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`zf<span class=\"subst\">$&#123;Gender.GIRL&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">enum Week&#123;</span><br><span class=\"line\">    MONDAY=<span class=\"number\">1</span>,</span><br><span class=\"line\">    TUESDAY=<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`今天是星期<span class=\"subst\">$&#123;Week.MONDAY&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-6-2-常数枚举\"><a href=\"#1-6-2-常数枚举\" class=\"headerlink\" title=\"1.6.2 常数枚举\"></a>1.6.2 常数枚举</h4><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。<br>假如包含了计算成员，则会在编译阶段报错</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> enum Colors &#123;</span><br><span class=\"line\">    Red,</span><br><span class=\"line\">    Yellow,</span><br><span class=\"line\">    Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myColors = [Colors.Red, Colors.Yellow, Colors.Blue];</span><br><span class=\"line\"><span class=\"keyword\">const</span> enum Color &#123;Red, Yellow, Blue = <span class=\"string\">\"blue\"</span>.length&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-任意类型-any\"><a href=\"#1-7-任意类型-any\" class=\"headerlink\" title=\"1.7 任意类型(any)\"></a>1.7 任意类型(any)</h3><p>any就是可以赋值给任意类型<br>第三方库没有提供类型文件时可以使用any<br>类型转换遇到困难时<br>数据结构太复杂难以定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> root:any=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root.style.color=<span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> root:(HTMLElement|<span class=\"literal\">null</span>)=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root!.style.color=<span class=\"string\">'red'</span>;<span class=\"comment\">//非空断言操作符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-8-null-和-undefined\"><a href=\"#1-8-null-和-undefined\" class=\"headerlink\" title=\"1.8 null 和 undefined\"></a>1.8 null 和 undefined</h3><p>null 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined<br>strictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: number;</span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\">x = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> y: number | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"number\">1</span>;</span><br><span class=\"line\">y = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-void-类型\"><a href=\"#1-9-void-类型\" class=\"headerlink\" title=\"1.9 void 类型\"></a>1.9 void 类型</h3><p>void 表示没有任何类型<br>当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeting</span>(<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">    <span class=\"comment\">//当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//严格模式(strictNullChecks:true)下只能返回undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//return null;</span></span><br><span class=\"line\">    <span class=\"comment\">//return undefined;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-10-never类型\"><a href=\"#1-10-never类型\" class=\"headerlink\" title=\"1.10 never类型\"></a>1.10 never类型</h3><p>never是其它类型(null undefined)的子类型，代表不会出现的值<br>作为不会返回（ return ）的函数的返回值类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: string</span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = error(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 由类型推论得到返回值为 never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = fail();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-1-strictNullChecks\"><a href=\"#1-10-1-strictNullChecks\" class=\"headerlink\" title=\"1.10.1 strictNullChecks\"></a>1.10.1 strictNullChecks</h4><p>在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 –strictNullChecks 这一种检查模式<br>由于引入了 –strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Compiled with --strictNullChecks</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">x: number | string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: number 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: string 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: never 类型</span></span><br><span class=\"line\">    <span class=\"comment\">// --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-2-never-和-void-的区别、\"><a href=\"#1-10-2-never-和-void-的区别、\" class=\"headerlink\" title=\"1.10.2 never 和 void 的区别、\"></a>1.10.2 never 和 void 的区别、</h4><p>void 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。<br>拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。<br>1.11 类型推论<br>是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性<br>定义时未赋值就会推论成any类型<br>如果定义的时候就赋值就能利用到类型推论</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username2;</span><br><span class=\"line\">username2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">username2 = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">username2 = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-12-包装对象（Wrapper-Object）\"><a href=\"#1-12-包装对象（Wrapper-Object）\" class=\"headerlink\" title=\"1.12 包装对象（Wrapper Object）\"></a>1.12 包装对象（Wrapper Object）</h3><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>所有的原始数据类型都没有属性（property）<br>原始数据类型<br>布尔值<br>数值<br>字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toUpperCase());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'zf'</span>)).toUpperCase());</span><br><span class=\"line\">当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换</span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"literal\">true</span>; <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>) <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>); <span class=\"comment\">// 编译失败   期望的 isOK 是一个原始数据类型</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-13-联合类型\"><a href=\"#1-13-联合类型\" class=\"headerlink\" title=\"1.13 联合类型\"></a>1.13 联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种<br>未赋值时联合类型上只能访问两个类型共有的属性和方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: string | number;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toString());</span><br><span class=\"line\">name = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\">name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-14-类型断言\"><a href=\"#1-14-类型断言\" class=\"headerlink\" title=\"1.14 类型断言\"></a>1.14 类型断言</h3><p>类型断言可以将一个联合类型的变量，指定为一个更加具体的类型<br>不能将联合类型断言为不存在的类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: string | number;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> string).length);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> number).toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> boolean));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-15-字面量类型\"><a href=\"#1-15-字面量类型\" class=\"headerlink\" title=\"1.15 字面量类型\"></a>1.15 字面量类型</h3><p>可以把字符串、数字、布尔值字面量组成一个联合类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">type ZType = <span class=\"number\">1</span> | <span class=\"string\">'One'</span>|<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t1:ZType = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t2:ZType = <span class=\"string\">'One'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t3:ZType = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-16-字符串字面量-vs-联合类型\"><a href=\"#1-16-字符串字面量-vs-联合类型\" class=\"headerlink\" title=\"1.16 字符串字面量 vs 联合类型\"></a>1.16 字符串字面量 vs 联合类型</h3><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种<br>字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"1-布尔类型-boolean\"><a href=\"#1-布尔类型-boolean\" class=\"headerlink\" title=\"1.布尔类型(boolean)\"></a>1.布尔类型(boolean)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> isLzf: boolean=<span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2数字类型-number\"><a href=\"#1-2数字类型-number\" class=\"headerlink\" title=\"1.2数字类型(number)\"></a>1.2数字类型(number)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> age: number=<span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-字符串类型-string\"><a href=\"#1-3-字符串类型-string\" class=\"headerlink\" title=\"1.3 字符串类型(string)\"></a>1.3 字符串类型(string)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> firstname: string=<span class=\"string\">'lzf'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-数组类型-array\"><a href=\"#1-4-数组类型-array\" class=\"headerlink\" title=\"1.4 数组类型(array)\"></a>1.4 数组类型(array)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr2: number[]=[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3: <span class=\"built_in\">Array</span>&lt;number&gt;=[<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-元组类型-tuple\"><a href=\"#1-5-元组类型-tuple\" class=\"headerlink\" title=\"1.5 元组类型(tuple)\"></a>1.5 元组类型(tuple)</h3><p>在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zf:[string,number] = [<span class=\"string\">'zf'</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">zf[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">zf[<span class=\"number\">1</span>].toFixed(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>元组    数组<br>每一项可以是不同的类型    每一项都是同一种类型<br>有预定义的长度    没有长度限制<br>用于表示一个固定的结构    用于表示一个列表</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> animal:[string,number,boolean] = [<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-枚举类型-enum\"><a href=\"#1-6-枚举类型-enum\" class=\"headerlink\" title=\"1.6 枚举类型(enum)\"></a>1.6 枚举类型(enum)</h3><p>事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值<br>比如性别、月份、星期、颜色、单位、学历</p>\n<h4 id=\"1-6-1-普通枚举\"><a href=\"#1-6-1-普通枚举\" class=\"headerlink\" title=\"1.6.1 普通枚举\"></a>1.6.1 普通枚举</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Gender&#123;</span><br><span class=\"line\">    GIRL,</span><br><span class=\"line\">    BOY</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`lzf是<span class=\"subst\">$&#123;Gender.BOY&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`zf<span class=\"subst\">$&#123;Gender.GIRL&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">enum Week&#123;</span><br><span class=\"line\">    MONDAY=<span class=\"number\">1</span>,</span><br><span class=\"line\">    TUESDAY=<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`今天是星期<span class=\"subst\">$&#123;Week.MONDAY&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-6-2-常数枚举\"><a href=\"#1-6-2-常数枚举\" class=\"headerlink\" title=\"1.6.2 常数枚举\"></a>1.6.2 常数枚举</h4><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。<br>假如包含了计算成员，则会在编译阶段报错</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> enum Colors &#123;</span><br><span class=\"line\">    Red,</span><br><span class=\"line\">    Yellow,</span><br><span class=\"line\">    Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myColors = [Colors.Red, Colors.Yellow, Colors.Blue];</span><br><span class=\"line\"><span class=\"keyword\">const</span> enum Color &#123;Red, Yellow, Blue = <span class=\"string\">\"blue\"</span>.length&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-任意类型-any\"><a href=\"#1-7-任意类型-any\" class=\"headerlink\" title=\"1.7 任意类型(any)\"></a>1.7 任意类型(any)</h3><p>any就是可以赋值给任意类型<br>第三方库没有提供类型文件时可以使用any<br>类型转换遇到困难时<br>数据结构太复杂难以定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> root:any=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root.style.color=<span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> root:(HTMLElement|<span class=\"literal\">null</span>)=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root!.style.color=<span class=\"string\">'red'</span>;<span class=\"comment\">//非空断言操作符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-8-null-和-undefined\"><a href=\"#1-8-null-和-undefined\" class=\"headerlink\" title=\"1.8 null 和 undefined\"></a>1.8 null 和 undefined</h3><p>null 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined<br>strictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: number;</span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\">x = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> y: number | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"number\">1</span>;</span><br><span class=\"line\">y = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-void-类型\"><a href=\"#1-9-void-类型\" class=\"headerlink\" title=\"1.9 void 类型\"></a>1.9 void 类型</h3><p>void 表示没有任何类型<br>当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeting</span>(<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">    <span class=\"comment\">//当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//严格模式(strictNullChecks:true)下只能返回undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//return null;</span></span><br><span class=\"line\">    <span class=\"comment\">//return undefined;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-10-never类型\"><a href=\"#1-10-never类型\" class=\"headerlink\" title=\"1.10 never类型\"></a>1.10 never类型</h3><p>never是其它类型(null undefined)的子类型，代表不会出现的值<br>作为不会返回（ return ）的函数的返回值类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: string</span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = error(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 由类型推论得到返回值为 never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = fail();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-1-strictNullChecks\"><a href=\"#1-10-1-strictNullChecks\" class=\"headerlink\" title=\"1.10.1 strictNullChecks\"></a>1.10.1 strictNullChecks</h4><p>在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 –strictNullChecks 这一种检查模式<br>由于引入了 –strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Compiled with --strictNullChecks</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">x: number | string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: number 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: string 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: never 类型</span></span><br><span class=\"line\">    <span class=\"comment\">// --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-2-never-和-void-的区别、\"><a href=\"#1-10-2-never-和-void-的区别、\" class=\"headerlink\" title=\"1.10.2 never 和 void 的区别、\"></a>1.10.2 never 和 void 的区别、</h4><p>void 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。<br>拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。<br>1.11 类型推论<br>是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性<br>定义时未赋值就会推论成any类型<br>如果定义的时候就赋值就能利用到类型推论</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username2;</span><br><span class=\"line\">username2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">username2 = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">username2 = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-12-包装对象（Wrapper-Object）\"><a href=\"#1-12-包装对象（Wrapper-Object）\" class=\"headerlink\" title=\"1.12 包装对象（Wrapper Object）\"></a>1.12 包装对象（Wrapper Object）</h3><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>所有的原始数据类型都没有属性（property）<br>原始数据类型<br>布尔值<br>数值<br>字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toUpperCase());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'zf'</span>)).toUpperCase());</span><br><span class=\"line\">当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换</span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"literal\">true</span>; <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>) <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: boolean = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>); <span class=\"comment\">// 编译失败   期望的 isOK 是一个原始数据类型</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-13-联合类型\"><a href=\"#1-13-联合类型\" class=\"headerlink\" title=\"1.13 联合类型\"></a>1.13 联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种<br>未赋值时联合类型上只能访问两个类型共有的属性和方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: string | number;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toString());</span><br><span class=\"line\">name = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\">name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-14-类型断言\"><a href=\"#1-14-类型断言\" class=\"headerlink\" title=\"1.14 类型断言\"></a>1.14 类型断言</h3><p>类型断言可以将一个联合类型的变量，指定为一个更加具体的类型<br>不能将联合类型断言为不存在的类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: string | number;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> string).length);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> number).toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> boolean));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-15-字面量类型\"><a href=\"#1-15-字面量类型\" class=\"headerlink\" title=\"1.15 字面量类型\"></a>1.15 字面量类型</h3><p>可以把字符串、数字、布尔值字面量组成一个联合类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">type ZType = <span class=\"number\">1</span> | <span class=\"string\">'One'</span>|<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t1:ZType = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t2:ZType = <span class=\"string\">'One'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t3:ZType = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-16-字符串字面量-vs-联合类型\"><a href=\"#1-16-字符串字面量-vs-联合类型\" class=\"headerlink\" title=\"1.16 字符串字面量 vs 联合类型\"></a>1.16 字符串字面量 vs 联合类型</h3><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种<br>字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致</p>\n"},{"title":"TypeScript函数","date":"2019-05-17T07:19:26.000Z","_content":"## 1. 函数\n\n### 1.1 函数的定义\n\n可以指定参数的类型和返回值的类型\n\n```javascript\nfunction hello(name:string):void {\n    console.log('hello',name);\n}\nhello('zf');\n```\n\n### 1.2 函数表达式\n\n```javascript\n定义函数类型\ntype GetUsernameFunction = (x:string,y:string)=>string;\nlet getUsername:GetUsernameFunction = function(firstName,lastName){\n  return firstName + lastName;\n}\n```\n\n### 1.3 没有返回值\n\n```javascript\nlet hello2 = function (name:string):void {\n    console.log('hello2',name);\n    return undefined;\n}\nhello2('zf');\n```\n\n### 1.4 可选参数\n\n```javascript\n在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数\n\nfunction print(name:string,age?:number):void {\n    console.log(name,age);\n}\nprint('zf');\n```\n\n### 1.5 默认参数\n\n```javascript\nfunction ajax(url:string,method:string='GET') {\n    console.log(url,method);\n}\najax('/users');\n```\n\n### 1.6 剩余参数\n\n```javascript\nfunction sum(...numbers:number[]) {\n    return numbers.reduce((val,item)=>val+=item,0);\n}\nconsole.log(sum(1,2,3));\n```\n\n### 1.7 函数重载\n\n在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样\n在TypeScript中，表现为给同一个函数提供多个函数类型定义\n\n```javascript\nlet obj: any={};\nfunction attr(val: string): void;\nfunction attr(val: number): void;\nfunction attr(val:any):void {\n    if (typeof val === 'string') {\n        obj.name=val;\n    } else {\n        obj.age=val;\n    }\n}\nattr('zf');\nattr(9);\nattr(true);\nconsole.log(obj);\n```\n","source":"_posts/page/typescript函数.md","raw":"---\ntitle: TypeScript函数\ntags:\n  - typescript\ncategories: web前端\ndate: 2019-05-17 15:19:26\n---\n## 1. 函数\n\n### 1.1 函数的定义\n\n可以指定参数的类型和返回值的类型\n\n```javascript\nfunction hello(name:string):void {\n    console.log('hello',name);\n}\nhello('zf');\n```\n\n### 1.2 函数表达式\n\n```javascript\n定义函数类型\ntype GetUsernameFunction = (x:string,y:string)=>string;\nlet getUsername:GetUsernameFunction = function(firstName,lastName){\n  return firstName + lastName;\n}\n```\n\n### 1.3 没有返回值\n\n```javascript\nlet hello2 = function (name:string):void {\n    console.log('hello2',name);\n    return undefined;\n}\nhello2('zf');\n```\n\n### 1.4 可选参数\n\n```javascript\n在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数\n\nfunction print(name:string,age?:number):void {\n    console.log(name,age);\n}\nprint('zf');\n```\n\n### 1.5 默认参数\n\n```javascript\nfunction ajax(url:string,method:string='GET') {\n    console.log(url,method);\n}\najax('/users');\n```\n\n### 1.6 剩余参数\n\n```javascript\nfunction sum(...numbers:number[]) {\n    return numbers.reduce((val,item)=>val+=item,0);\n}\nconsole.log(sum(1,2,3));\n```\n\n### 1.7 函数重载\n\n在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样\n在TypeScript中，表现为给同一个函数提供多个函数类型定义\n\n```javascript\nlet obj: any={};\nfunction attr(val: string): void;\nfunction attr(val: number): void;\nfunction attr(val:any):void {\n    if (typeof val === 'string') {\n        obj.name=val;\n    } else {\n        obj.age=val;\n    }\n}\nattr('zf');\nattr(9);\nattr(true);\nconsole.log(obj);\n```\n","slug":"page/typescript函数","published":1,"updated":"2020-06-21T12:48:04.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbw73cki00071gsxe6bkg5j8","content":"<h2 id=\"1-函数\"><a href=\"#1-函数\" class=\"headerlink\" title=\"1. 函数\"></a>1. 函数</h2><h3 id=\"1-1-函数的定义\"><a href=\"#1-1-函数的定义\" class=\"headerlink\" title=\"1.1 函数的定义\"></a>1.1 函数的定义</h3><p>可以指定参数的类型和返回值的类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-函数表达式\"><a href=\"#1-2-函数表达式\" class=\"headerlink\" title=\"1.2 函数表达式\"></a>1.2 函数表达式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">定义函数类型</span><br><span class=\"line\">type GetUsernameFunction = <span class=\"function\">(<span class=\"params\">x:string,y:string</span>)=&gt;</span>string;</span><br><span class=\"line\"><span class=\"keyword\">let</span> getUsername:GetUsernameFunction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">firstName,lastName</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-没有返回值\"><a href=\"#1-3-没有返回值\" class=\"headerlink\" title=\"1.3 没有返回值\"></a>1.3 没有返回值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello2'</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello2(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-可选参数\"><a href=\"#1-4-可选参数\" class=\"headerlink\" title=\"1.4 可选参数\"></a>1.4 可选参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\">name:string,age?:number</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name,age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-默认参数\"><a href=\"#1-5-默认参数\" class=\"headerlink\" title=\"1.5 默认参数\"></a>1.5 默认参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url:string,method:string=<span class=\"string\">'GET'</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(url,method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ajax(<span class=\"string\">'/users'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-剩余参数\"><a href=\"#1-6-剩余参数\" class=\"headerlink\" title=\"1.6 剩余参数\"></a>1.6 剩余参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">...numbers:number[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numbers.reduce(<span class=\"function\">(<span class=\"params\">val,item</span>)=&gt;</span>val+=item,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-函数重载\"><a href=\"#1-7-函数重载\" class=\"headerlink\" title=\"1.7 函数重载\"></a>1.7 函数重载</h3><p>在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样<br>在TypeScript中，表现为给同一个函数提供多个函数类型定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj: any=&#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: string</span>): <span class=\"title\">void</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: number</span>): <span class=\"title\">void</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val:any</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        obj.name=val;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        obj.age=val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">attr(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">attr(<span class=\"number\">9</span>);</span><br><span class=\"line\">attr(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-函数\"><a href=\"#1-函数\" class=\"headerlink\" title=\"1. 函数\"></a>1. 函数</h2><h3 id=\"1-1-函数的定义\"><a href=\"#1-1-函数的定义\" class=\"headerlink\" title=\"1.1 函数的定义\"></a>1.1 函数的定义</h3><p>可以指定参数的类型和返回值的类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-函数表达式\"><a href=\"#1-2-函数表达式\" class=\"headerlink\" title=\"1.2 函数表达式\"></a>1.2 函数表达式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">定义函数类型</span><br><span class=\"line\">type GetUsernameFunction = <span class=\"function\">(<span class=\"params\">x:string,y:string</span>)=&gt;</span>string;</span><br><span class=\"line\"><span class=\"keyword\">let</span> getUsername:GetUsernameFunction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">firstName,lastName</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-没有返回值\"><a href=\"#1-3-没有返回值\" class=\"headerlink\" title=\"1.3 没有返回值\"></a>1.3 没有返回值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name:string</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello2'</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello2(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-可选参数\"><a href=\"#1-4-可选参数\" class=\"headerlink\" title=\"1.4 可选参数\"></a>1.4 可选参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\">name:string,age?:number</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name,age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-默认参数\"><a href=\"#1-5-默认参数\" class=\"headerlink\" title=\"1.5 默认参数\"></a>1.5 默认参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url:string,method:string=<span class=\"string\">'GET'</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(url,method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ajax(<span class=\"string\">'/users'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-剩余参数\"><a href=\"#1-6-剩余参数\" class=\"headerlink\" title=\"1.6 剩余参数\"></a>1.6 剩余参数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">...numbers:number[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numbers.reduce(<span class=\"function\">(<span class=\"params\">val,item</span>)=&gt;</span>val+=item,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-函数重载\"><a href=\"#1-7-函数重载\" class=\"headerlink\" title=\"1.7 函数重载\"></a>1.7 函数重载</h3><p>在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样<br>在TypeScript中，表现为给同一个函数提供多个函数类型定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj: any=&#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: string</span>): <span class=\"title\">void</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: number</span>): <span class=\"title\">void</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val:any</span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        obj.name=val;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        obj.age=val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">attr(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">attr(<span class=\"number\">9</span>);</span><br><span class=\"line\">attr(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br></pre></td></tr></table></figure>\n"},{"title":"typescript类","author":"lz_allen","date":"2020-05-22T00:16:28.000Z","_content":"\n## 类\n\n### 如何定义类\n\n\"strictPropertyInitialization\": true / 启用类属性初始化的严格检查/\nname!:string\n\n```javascript\nclass Person{\n    name:string;\n    getName():void{\n        console.log(this.name);\n    }\n}\nlet p1 = new Person();\np1.name = 'zhufeng';\np1.getName();\n```\n\n### 存取器\n\n- 在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为\n- 构造函数\n- 主要用于初始化类的成员变量属性\n- 类的对象创建时自动调用执行\n- 没有返回值\n\n```javascript\nclass User {\n    myname:string;\n    constructor(myname: string) {\n        this.myname = myname;\n    }\n    get name() {\n        return this.myname;\n    }\n    set name(value) {\n        this.myname = value;\n    }\n}\n\nlet user = new User('zhufeng');\nuser.name = 'jiagou'; \nconsole.log(user.name); \n\"use strict\";\nvar User = /** @class */ (function () {\n    function User(myname) {\n        this.myname = myname;\n    }\n    Object.defineProperty(User.prototype, \"name\", {\n        get: function () {\n            return this.myname;\n        },\n        set: function (value) {\n            this.myname = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return User;\n}());\nvar user = new User('zhufeng');\nuser.name = 'jiagou';\nconsole.log(user.name);\n```\n\n### 参数属性\n\n```javascript\nclass User {\n    constructor(public myname: string) {}\n    get name() {\n        return this.myname;\n    }\n    set name(value) {\n        this.myname = value;\n    }\n}\n\nlet user = new User('zhufeng');\nconsole.log(user.name); \nuser.name = 'jiagou'; \nconsole.log(user.name);\n```\n\n### readonly\n\n- readonly修饰的变量只能在构造函数中初始化\n- 在 TypeScript 中，const 是常量标志符，其值不能被重新分配\n- TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly\n- readonly 实际上只是在编译阶段进行代码检查。而 const 则会在运行时检查（在支持 const 语法的 JavaScript 运行时环境中）\n\n```javascript\nclass Animal {\n    public readonly name: string\n    constructor(name:string) {\n        this.name = name;\n    }\n    changeName(name:string){\n        this.name = name;\n    }\n}\n\nlet a = new Animal('zhufeng');\na.changeName('jiagou');\n```\n\n### 继承\n\n- 子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性\\\n- 将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑\n- super可以调用父类上的方法和属性\n\n```javascript\nclass Person {\n    name: string;//定义实例的属性，默认省略public修饰符\n    age: number;\n    constructor(name:string,age:number) {//构造函数\n        this.name=name;\n        this.age=age;\n    }\n    getName():string {\n        return this.name;\n    }\n    setName(name:string): void{\n        this.name=name;\n    }\n}\nclass Student extends Person{\n    no: number;\n    constructor(name:string,age:number,no:number) {\n        super(name,age);\n        this.no=no;\n    }\n    getNo():number {\n        return this.no;\n    }\n}\nlet s1=new Student('zf',10,1);\nconsole.log(s1);\n\n```\n\n### 类里面的修饰符\n\n```javascript\nclass Father {\n    public name: string;  //类里面 子类 其它任何地方外边都可以访问\n    protected age: number; //类里面 子类 都可以访问,其它任何地方不能访问\n    private money: number; //类里面可以访问， 子类和其它任何地方都不可以访问\n    constructor(name:string,age:number,money:number) {//构造函数\n        this.name=name;\n        this.age=age;\n        this.money=money;\n    }\n    getName():string {\n        return this.name;\n    }\n    setName(name:string): void{\n        this.name=name;\n    }\n}\nclass Child extends Father{\n    constructor(name:string,age:number,money:number) {\n        super(name,age,money);\n    }\n    desc() {\n        console.log(`${this.name} ${this.age} ${this.money}`);\n    }\n}\n\nlet child = new Child('zf',10,1000);\nconsole.log(child.name);\nconsole.log(child.age);\nconsole.log(child.money);\n```\n\n### 静态属性 静态方法\n\n```javascript\nclass Father {\n    static className='Father';\n    static getClassName() {\n        return Father.className;\n    }\n    public name: string;\n    constructor(name:string) {//构造函数\n        this.name=name;\n    }\n\n}\nconsole.log(Father.className);\nconsole.log(Father.getClassName());\n```\n\n### 装饰器\n\n- 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为\n- 常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器\n- 装饰器的写法分为普通装饰器和装饰器工厂\n\n#### 类装饰器\n\n类装饰器在类声明之前声明，用来监视、修改或替换类定义\n\n```javascript\nnamespace a {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(target: any) {\n        target.prototype.name = 'zhufeng';\n        target.prototype.eat = function () {\n            console.log('eat');\n        }\n    }\n    @enhancer\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n\nnamespace b {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(name: string) {\n        return function enhancer(target: any) {\n            target.prototype.name = name;\n            target.prototype.eat = function () {\n                console.log('eat');\n            }\n        }\n    }\n\n    @enhancer('zhufeng')\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n\nnamespace c {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(target: any) {\n        return class {\n            name: string = 'jiagou'\n            eat() {\n                console.log('吃饭饭');\n            }\n        }\n    }\n    @enhancer\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n```\n\n#### 属性装饰器\n\n- 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数\n- 属性装饰器用来装饰属性\n- 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n- 第二个参数是属性的名称\n- 方法装饰器用来装饰方法\n- 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n- 第二个参数是方法的名称\n- 第三个参数是方法描述符\n\n```javascript\nnamespace d {\n    function upperCase(target: any, propertyKey: string) {\n        let value = target[propertyKey];\n        const getter = function () {\n            return value;\n        }\n        // 用来替换的setter\n        const setter = function (newVal: string) {\n            value = newVal.toUpperCase()\n        };\n        // 替换属性，先删除原先的属性，再重新定义属性\n        if (delete target[propertyKey]) {\n            Object.defineProperty(target, propertyKey, {\n                get: getter,\n                set: setter,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    function noEnumerable(target: any, property: string, descriptor: PropertyDescriptor) {\n        console.log('target.getName', target.getName);\n        console.log('target.getAge', target.getAge);\n        descriptor.enumerable = true;\n    }\n    function toNumber(target: any, methodName: string, descriptor: PropertyDescriptor) {\n        let oldMethod = descriptor.value;\n        descriptor.value = function (...args: any[]) {\n            args = args.map(item => parseFloat(item));\n            return oldMethod.apply(this, args);\n        }\n    }\n    class Person {\n        @upperCase\n        name: string = 'zhufeng'\n        public static age: number = 10\n        constructor() { }\n        @noEnumerable\n        getName() {\n            console.log(this.name);\n        }\n        @toNumber\n        sum(...args: any[]) {\n            return args.reduce((accu: number, item: number) => accu + item, 0);\n        }\n    }\n    let p: Person = new Person();\n    for (let attr in p) {\n        console.log('attr=', attr);\n    }\n    p.name = 'jiagou';\n    p.getName();\n    console.log(p.sum(\"1\", \"2\", \"3\"));\n}\n```\n\n#### 参数装饰器\n\n- 会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据\n- 第1个参数对于静态成员是类的构造函数，对于实例成员是类的原型对象\n- 第2个参数的名称\n- 第3个参数在函数列表中的索引\n\n```javascript\nnamespace d {\n    interface Person {\n        age: number;\n    }\n    function addAge(target: any, methodName: string, paramsIndex: number) {\n        console.log(target);\n        console.log(methodName);\n        console.log(paramsIndex);\n        target.age = 10;\n    }\n    class Person {\n        login(username: string, @addAge password: string) {\n            console.log(this.age, username, password);\n        }\n    }\n    let p = new Person();\n    p.login('zhufeng', '123456')\n}\n```\n\n### 装饰器执行顺序\n\n- 有多个参数装饰器时：从最后一个参数依次向前执行\n- 方法和方法参数中参数装饰器先执行。\n- 类装饰器总是最后执行\n- 方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行\n\n```javascript\nnamespace e {\n    function Class1Decorator() {\n        return function (target: any) {\n            console.log(\"类1装饰器\");\n        }\n    }\n    function Class2Decorator() {\n        return function (target: any) {\n            console.log(\"类2装饰器\");\n        }\n    }\n    function MethodDecorator() {\n        return function (target: any, methodName: string, descriptor: PropertyDescriptor) {\n            console.log(\"方法装饰器\");\n        }\n    }\n    function Param1Decorator() {\n        return function (target: any, methodName: string, paramIndex: number) {\n            console.log(\"参数1装饰器\");\n        }\n    }\n    function Param2Decorator() {\n        return function (target: any, methodName: string, paramIndex: number) {\n            console.log(\"参数2装饰器\");\n        }\n    }\n    function PropertyDecorator(name: string) {\n        return function (target: any, propertyName: string) {\n            console.log(name + \"属性装饰器\");\n        }\n    }\n\n    @Class1Decorator()\n    @Class2Decorator()\n    class Person {\n        @PropertyDecorator('name')\n        name: string = 'zhufeng';\n        @PropertyDecorator('age')\n        age: number = 10;\n        @MethodDecorator()\n        greet(@Param1Decorator() p1: string, @Param2Decorator() p2: string) { }\n    }\n}\n```\n\n/**\nname属性装饰器\nage属性装饰器\n参数2装饰器\n参数1装饰器\n方法装饰器\n类2装饰器\n类1装饰器\n */\n\n### 抽象类\n\n- 抽象描述一种抽象的概念，无法被实例化，只能被继承\n- 无法创建抽象类的实例\\\n- 抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现，而且必须实现\n\n```javascript\nabstract class Animal {\n    name!:string;\n    abstract speak():void;\n}\nclass Cat extends Animal{\n    speak(){\n        console.log('喵喵喵');\n    }\n}\nlet animal = new Animal();//Cannot create an instance of an abstract class\nanimal.speak();\nlet cat = new Cat();\ncat.speak();\n```\n\n- 访问控制修饰符 private protected public\n- 只读属性 readonly\n- 静态属性 static\n- 抽象类、抽象方法 abstract\n  \n#### 抽象类 vs 接口\n\n- 不同类之间公有的属性或方法，可以抽象成一个接口（Interfaces）\n- 而抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n- 抽象类本质是一个无法被实例化的类，其中能够实现方法和初始化属性，而接口仅能够用于描述,既不提供方法的实现，也不为属性进行初始化\n- 一个类可以继承一个类或抽象类，但可以实现（implements）多个接口\n- 抽象类也可以实现接口\n\n```javascript\nabstract class Animal{\n    name:string;\n    constructor(name:string){\n      this.name = name;\n    }\n    abstract speak():void;\n  }\ninterface Flying{\n      fly():void\n}\nclass Duck extends Animal implements Flying{\n      speak(){\n          console.log('汪汪汪');\n      }\n      fly(){\n          console.log('我会飞');\n      }\n}\nlet duck = new Duck('zhufeng');\nduck.speak();\nduck.fly();\n```\n\n#### 抽象方法\n\n- 抽象类和方法不包含具体实现，必须在子类中实现\n- 抽象方法只能出现在抽象类中\n- 子类可以对抽象类进行不同的实现\n\n```javascript\nabstract class Animal{\n    abstract speak():void;\n}\nclass Dog extends  Animal{\n    speak(){\n        console.log('小狗汪汪汪');\n    }\n}\nclass Cat extends  Animal{\n    speak(){\n        console.log('小猫喵喵喵');\n    }\n}\nlet dog=new Dog();\nlet cat=new Cat();\ndog.speak();\ncat.speak();\n```\n\n### 重写(override) vs 重载(overload)\n\n- 重写是指子类重写继承自父类中的方法\n- 重载是指为同一个函数提供多个类型定义\n\n```javascript\nclass Animal{\n    speak(word:string):string{\n        return '动作叫:'+word;\n    }\n}\nclass Cat extends Animal{\n    speak(word:string):string{\n        return '猫叫:'+word;\n    }\n}\nlet cat = new Cat();\nconsole.log(cat.speak('hello'));\n//--------------------------------------------\nfunction double(val:number):number\nfunction double(val:string):string\nfunction double(val:any):any{\n  if(typeof val == 'number'){\n    return val *2;\n  }\n  return val + val;\n}\n\nlet r = double(1);\nconsole.log(r);\n```\n\n### 继承 vs 多态\n\n- 继承(Inheritance)子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n- 多态(Polymorphism)由继承而产生了相关的不同的类，对同一个方法可以有不同的行为\n  \n```javascript\nclass Animal{\n    speak(word:string):string{\n        return 'Animal: '+word;\n    }\n}\nclass Cat extends Animal{\n    speak(word:string):string{\n        return 'Cat:'+word;\n    }\n}\nclass Dog extends Animal{\n    speak(word:string):string{\n        return 'Dog:'+word;\n    }\n}\nlet cat = new Cat();\nconsole.log(cat.speak('hello'));\nlet dog = new Dog();\nconsole.log(dog.speak('hello'));\n```\n","source":"_posts/page/typescript类.md","raw":"---\ntitle: typescript类\ncategories: web前端\nauthor: lz_allen\ntags:\n  - typescript\ndate: 2020-05-22 08:16:28\n---\n\n## 类\n\n### 如何定义类\n\n\"strictPropertyInitialization\": true / 启用类属性初始化的严格检查/\nname!:string\n\n```javascript\nclass Person{\n    name:string;\n    getName():void{\n        console.log(this.name);\n    }\n}\nlet p1 = new Person();\np1.name = 'zhufeng';\np1.getName();\n```\n\n### 存取器\n\n- 在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为\n- 构造函数\n- 主要用于初始化类的成员变量属性\n- 类的对象创建时自动调用执行\n- 没有返回值\n\n```javascript\nclass User {\n    myname:string;\n    constructor(myname: string) {\n        this.myname = myname;\n    }\n    get name() {\n        return this.myname;\n    }\n    set name(value) {\n        this.myname = value;\n    }\n}\n\nlet user = new User('zhufeng');\nuser.name = 'jiagou'; \nconsole.log(user.name); \n\"use strict\";\nvar User = /** @class */ (function () {\n    function User(myname) {\n        this.myname = myname;\n    }\n    Object.defineProperty(User.prototype, \"name\", {\n        get: function () {\n            return this.myname;\n        },\n        set: function (value) {\n            this.myname = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return User;\n}());\nvar user = new User('zhufeng');\nuser.name = 'jiagou';\nconsole.log(user.name);\n```\n\n### 参数属性\n\n```javascript\nclass User {\n    constructor(public myname: string) {}\n    get name() {\n        return this.myname;\n    }\n    set name(value) {\n        this.myname = value;\n    }\n}\n\nlet user = new User('zhufeng');\nconsole.log(user.name); \nuser.name = 'jiagou'; \nconsole.log(user.name);\n```\n\n### readonly\n\n- readonly修饰的变量只能在构造函数中初始化\n- 在 TypeScript 中，const 是常量标志符，其值不能被重新分配\n- TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly\n- readonly 实际上只是在编译阶段进行代码检查。而 const 则会在运行时检查（在支持 const 语法的 JavaScript 运行时环境中）\n\n```javascript\nclass Animal {\n    public readonly name: string\n    constructor(name:string) {\n        this.name = name;\n    }\n    changeName(name:string){\n        this.name = name;\n    }\n}\n\nlet a = new Animal('zhufeng');\na.changeName('jiagou');\n```\n\n### 继承\n\n- 子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性\\\n- 将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑\n- super可以调用父类上的方法和属性\n\n```javascript\nclass Person {\n    name: string;//定义实例的属性，默认省略public修饰符\n    age: number;\n    constructor(name:string,age:number) {//构造函数\n        this.name=name;\n        this.age=age;\n    }\n    getName():string {\n        return this.name;\n    }\n    setName(name:string): void{\n        this.name=name;\n    }\n}\nclass Student extends Person{\n    no: number;\n    constructor(name:string,age:number,no:number) {\n        super(name,age);\n        this.no=no;\n    }\n    getNo():number {\n        return this.no;\n    }\n}\nlet s1=new Student('zf',10,1);\nconsole.log(s1);\n\n```\n\n### 类里面的修饰符\n\n```javascript\nclass Father {\n    public name: string;  //类里面 子类 其它任何地方外边都可以访问\n    protected age: number; //类里面 子类 都可以访问,其它任何地方不能访问\n    private money: number; //类里面可以访问， 子类和其它任何地方都不可以访问\n    constructor(name:string,age:number,money:number) {//构造函数\n        this.name=name;\n        this.age=age;\n        this.money=money;\n    }\n    getName():string {\n        return this.name;\n    }\n    setName(name:string): void{\n        this.name=name;\n    }\n}\nclass Child extends Father{\n    constructor(name:string,age:number,money:number) {\n        super(name,age,money);\n    }\n    desc() {\n        console.log(`${this.name} ${this.age} ${this.money}`);\n    }\n}\n\nlet child = new Child('zf',10,1000);\nconsole.log(child.name);\nconsole.log(child.age);\nconsole.log(child.money);\n```\n\n### 静态属性 静态方法\n\n```javascript\nclass Father {\n    static className='Father';\n    static getClassName() {\n        return Father.className;\n    }\n    public name: string;\n    constructor(name:string) {//构造函数\n        this.name=name;\n    }\n\n}\nconsole.log(Father.className);\nconsole.log(Father.getClassName());\n```\n\n### 装饰器\n\n- 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为\n- 常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器\n- 装饰器的写法分为普通装饰器和装饰器工厂\n\n#### 类装饰器\n\n类装饰器在类声明之前声明，用来监视、修改或替换类定义\n\n```javascript\nnamespace a {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(target: any) {\n        target.prototype.name = 'zhufeng';\n        target.prototype.eat = function () {\n            console.log('eat');\n        }\n    }\n    @enhancer\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n\nnamespace b {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(name: string) {\n        return function enhancer(target: any) {\n            target.prototype.name = name;\n            target.prototype.eat = function () {\n                console.log('eat');\n            }\n        }\n    }\n\n    @enhancer('zhufeng')\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n\nnamespace c {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(target: any) {\n        return class {\n            name: string = 'jiagou'\n            eat() {\n                console.log('吃饭饭');\n            }\n        }\n    }\n    @enhancer\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n```\n\n#### 属性装饰器\n\n- 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数\n- 属性装饰器用来装饰属性\n- 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n- 第二个参数是属性的名称\n- 方法装饰器用来装饰方法\n- 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n- 第二个参数是方法的名称\n- 第三个参数是方法描述符\n\n```javascript\nnamespace d {\n    function upperCase(target: any, propertyKey: string) {\n        let value = target[propertyKey];\n        const getter = function () {\n            return value;\n        }\n        // 用来替换的setter\n        const setter = function (newVal: string) {\n            value = newVal.toUpperCase()\n        };\n        // 替换属性，先删除原先的属性，再重新定义属性\n        if (delete target[propertyKey]) {\n            Object.defineProperty(target, propertyKey, {\n                get: getter,\n                set: setter,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    function noEnumerable(target: any, property: string, descriptor: PropertyDescriptor) {\n        console.log('target.getName', target.getName);\n        console.log('target.getAge', target.getAge);\n        descriptor.enumerable = true;\n    }\n    function toNumber(target: any, methodName: string, descriptor: PropertyDescriptor) {\n        let oldMethod = descriptor.value;\n        descriptor.value = function (...args: any[]) {\n            args = args.map(item => parseFloat(item));\n            return oldMethod.apply(this, args);\n        }\n    }\n    class Person {\n        @upperCase\n        name: string = 'zhufeng'\n        public static age: number = 10\n        constructor() { }\n        @noEnumerable\n        getName() {\n            console.log(this.name);\n        }\n        @toNumber\n        sum(...args: any[]) {\n            return args.reduce((accu: number, item: number) => accu + item, 0);\n        }\n    }\n    let p: Person = new Person();\n    for (let attr in p) {\n        console.log('attr=', attr);\n    }\n    p.name = 'jiagou';\n    p.getName();\n    console.log(p.sum(\"1\", \"2\", \"3\"));\n}\n```\n\n#### 参数装饰器\n\n- 会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据\n- 第1个参数对于静态成员是类的构造函数，对于实例成员是类的原型对象\n- 第2个参数的名称\n- 第3个参数在函数列表中的索引\n\n```javascript\nnamespace d {\n    interface Person {\n        age: number;\n    }\n    function addAge(target: any, methodName: string, paramsIndex: number) {\n        console.log(target);\n        console.log(methodName);\n        console.log(paramsIndex);\n        target.age = 10;\n    }\n    class Person {\n        login(username: string, @addAge password: string) {\n            console.log(this.age, username, password);\n        }\n    }\n    let p = new Person();\n    p.login('zhufeng', '123456')\n}\n```\n\n### 装饰器执行顺序\n\n- 有多个参数装饰器时：从最后一个参数依次向前执行\n- 方法和方法参数中参数装饰器先执行。\n- 类装饰器总是最后执行\n- 方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行\n\n```javascript\nnamespace e {\n    function Class1Decorator() {\n        return function (target: any) {\n            console.log(\"类1装饰器\");\n        }\n    }\n    function Class2Decorator() {\n        return function (target: any) {\n            console.log(\"类2装饰器\");\n        }\n    }\n    function MethodDecorator() {\n        return function (target: any, methodName: string, descriptor: PropertyDescriptor) {\n            console.log(\"方法装饰器\");\n        }\n    }\n    function Param1Decorator() {\n        return function (target: any, methodName: string, paramIndex: number) {\n            console.log(\"参数1装饰器\");\n        }\n    }\n    function Param2Decorator() {\n        return function (target: any, methodName: string, paramIndex: number) {\n            console.log(\"参数2装饰器\");\n        }\n    }\n    function PropertyDecorator(name: string) {\n        return function (target: any, propertyName: string) {\n            console.log(name + \"属性装饰器\");\n        }\n    }\n\n    @Class1Decorator()\n    @Class2Decorator()\n    class Person {\n        @PropertyDecorator('name')\n        name: string = 'zhufeng';\n        @PropertyDecorator('age')\n        age: number = 10;\n        @MethodDecorator()\n        greet(@Param1Decorator() p1: string, @Param2Decorator() p2: string) { }\n    }\n}\n```\n\n/**\nname属性装饰器\nage属性装饰器\n参数2装饰器\n参数1装饰器\n方法装饰器\n类2装饰器\n类1装饰器\n */\n\n### 抽象类\n\n- 抽象描述一种抽象的概念，无法被实例化，只能被继承\n- 无法创建抽象类的实例\\\n- 抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现，而且必须实现\n\n```javascript\nabstract class Animal {\n    name!:string;\n    abstract speak():void;\n}\nclass Cat extends Animal{\n    speak(){\n        console.log('喵喵喵');\n    }\n}\nlet animal = new Animal();//Cannot create an instance of an abstract class\nanimal.speak();\nlet cat = new Cat();\ncat.speak();\n```\n\n- 访问控制修饰符 private protected public\n- 只读属性 readonly\n- 静态属性 static\n- 抽象类、抽象方法 abstract\n  \n#### 抽象类 vs 接口\n\n- 不同类之间公有的属性或方法，可以抽象成一个接口（Interfaces）\n- 而抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n- 抽象类本质是一个无法被实例化的类，其中能够实现方法和初始化属性，而接口仅能够用于描述,既不提供方法的实现，也不为属性进行初始化\n- 一个类可以继承一个类或抽象类，但可以实现（implements）多个接口\n- 抽象类也可以实现接口\n\n```javascript\nabstract class Animal{\n    name:string;\n    constructor(name:string){\n      this.name = name;\n    }\n    abstract speak():void;\n  }\ninterface Flying{\n      fly():void\n}\nclass Duck extends Animal implements Flying{\n      speak(){\n          console.log('汪汪汪');\n      }\n      fly(){\n          console.log('我会飞');\n      }\n}\nlet duck = new Duck('zhufeng');\nduck.speak();\nduck.fly();\n```\n\n#### 抽象方法\n\n- 抽象类和方法不包含具体实现，必须在子类中实现\n- 抽象方法只能出现在抽象类中\n- 子类可以对抽象类进行不同的实现\n\n```javascript\nabstract class Animal{\n    abstract speak():void;\n}\nclass Dog extends  Animal{\n    speak(){\n        console.log('小狗汪汪汪');\n    }\n}\nclass Cat extends  Animal{\n    speak(){\n        console.log('小猫喵喵喵');\n    }\n}\nlet dog=new Dog();\nlet cat=new Cat();\ndog.speak();\ncat.speak();\n```\n\n### 重写(override) vs 重载(overload)\n\n- 重写是指子类重写继承自父类中的方法\n- 重载是指为同一个函数提供多个类型定义\n\n```javascript\nclass Animal{\n    speak(word:string):string{\n        return '动作叫:'+word;\n    }\n}\nclass Cat extends Animal{\n    speak(word:string):string{\n        return '猫叫:'+word;\n    }\n}\nlet cat = new Cat();\nconsole.log(cat.speak('hello'));\n//--------------------------------------------\nfunction double(val:number):number\nfunction double(val:string):string\nfunction double(val:any):any{\n  if(typeof val == 'number'){\n    return val *2;\n  }\n  return val + val;\n}\n\nlet r = double(1);\nconsole.log(r);\n```\n\n### 继承 vs 多态\n\n- 继承(Inheritance)子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n- 多态(Polymorphism)由继承而产生了相关的不同的类，对同一个方法可以有不同的行为\n  \n```javascript\nclass Animal{\n    speak(word:string):string{\n        return 'Animal: '+word;\n    }\n}\nclass Cat extends Animal{\n    speak(word:string):string{\n        return 'Cat:'+word;\n    }\n}\nclass Dog extends Animal{\n    speak(word:string):string{\n        return 'Dog:'+word;\n    }\n}\nlet cat = new Cat();\nconsole.log(cat.speak('hello'));\nlet dog = new Dog();\nconsole.log(dog.speak('hello'));\n```\n","slug":"page/typescript类","published":1,"updated":"2020-06-21T16:33:19.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbw73ckj00081gsx7k2s98b7","content":"<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"如何定义类\"><a href=\"#如何定义类\" class=\"headerlink\" title=\"如何定义类\"></a>如何定义类</h3><p>“strictPropertyInitialization”: true / 启用类属性初始化的严格检查/<br>name!:string</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    getName():<span class=\"keyword\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p1.name = <span class=\"string\">'zhufeng'</span>;</span><br><span class=\"line\">p1.getName();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存取器\"><a href=\"#存取器\" class=\"headerlink\" title=\"存取器\"></a>存取器</h3><ul>\n<li>在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为</li>\n<li>构造函数</li>\n<li>主要用于初始化类的成员变量属性</li>\n<li>类的对象创建时自动调用执行</li>\n<li>没有返回值</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    myname:string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(myname: string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zhufeng'</span>);</span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name); </span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> User = <span class=\"comment\">/** @class */</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">User</span>(<span class=\"params\">myname</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(User.prototype, <span class=\"string\">\"name\"</span>, &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>: function () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">set</span>: function (value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> User;</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"><span class=\"keyword\">var</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zhufeng'</span>);</span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数属性\"><a href=\"#参数属性\" class=\"headerlink\" title=\"参数属性\"></a>参数属性</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(public myname: string) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zhufeng'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name); </span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"readonly\"><a href=\"#readonly\" class=\"headerlink\" title=\"readonly\"></a>readonly</h3><ul>\n<li>readonly修饰的变量只能在构造函数中初始化</li>\n<li>在 TypeScript 中，const 是常量标志符，其值不能被重新分配</li>\n<li>TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly</li>\n<li>readonly 实际上只是在编译阶段进行代码检查。而 const 则会在运行时检查（在支持 const 语法的 JavaScript 运行时环境中）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    public readonly name: string</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    changeName(name:string)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'zhufeng'</span>);</span><br><span class=\"line\">a.changeName(<span class=\"string\">'jiagou'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><ul>\n<li>子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性\\</li>\n<li>将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑</li>\n<li>super可以调用父类上的方法和属性</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    name: string;<span class=\"comment\">//定义实例的属性，默认省略public修饰符</span></span><br><span class=\"line\">    age: number;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string,age:number) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName():string &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name:string): <span class=\"keyword\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    no: number;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string,age:number,no:number) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name,age);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.no=no;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getNo():number &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.no;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s1=<span class=\"keyword\">new</span> Student(<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s1);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类里面的修饰符\"><a href=\"#类里面的修饰符\" class=\"headerlink\" title=\"类里面的修饰符\"></a>类里面的修饰符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    public name: string;  <span class=\"comment\">//类里面 子类 其它任何地方外边都可以访问</span></span><br><span class=\"line\">    protected age: number; <span class=\"comment\">//类里面 子类 都可以访问,其它任何地方不能访问</span></span><br><span class=\"line\">    private money: number; <span class=\"comment\">//类里面可以访问， 子类和其它任何地方都不可以访问</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string,age:number,money:number) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.money=money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName():string &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name:string): <span class=\"keyword\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string,age:number,money:number) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name,age,money);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    desc() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.age&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.money&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.age);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.money);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态属性-静态方法\"><a href=\"#静态属性-静态方法\" class=\"headerlink\" title=\"静态属性 静态方法\"></a>静态属性 静态方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> className=<span class=\"string\">'Father'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> getClassName() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Father.className;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Father.className);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Father.getClassName());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><ul>\n<li>装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为</li>\n<li>常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器</li>\n<li>装饰器的写法分为普通装饰器和装饰器工厂</li>\n</ul>\n<h4 id=\"类装饰器\"><a href=\"#类装饰器\" class=\"headerlink\" title=\"类装饰器\"></a>类装饰器</h4><p>类装饰器在类声明之前声明，用来监视、修改或替换类定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">namespace a &#123;</span><br><span class=\"line\">    interface Person &#123;</span><br><span class=\"line\">        name: string;</span><br><span class=\"line\">        eat: any</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: any</span>) </span>&#123;</span><br><span class=\"line\">        target.prototype.name = <span class=\"string\">'zhufeng'</span>;</span><br><span class=\"line\">        target.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'eat'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @enhancer</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace b &#123;</span><br><span class=\"line\">    interface Person &#123;</span><br><span class=\"line\">        name: string;</span><br><span class=\"line\">        eat: any</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">name: string</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: any</span>) </span>&#123;</span><br><span class=\"line\">            target.prototype.name = name;</span><br><span class=\"line\">            target.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'eat'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @enhancer(<span class=\"string\">'zhufeng'</span>)</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace c &#123;</span><br><span class=\"line\">    interface Person &#123;</span><br><span class=\"line\">        name: string;</span><br><span class=\"line\">        eat: any</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: any</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;</span><br><span class=\"line\">            name: string = <span class=\"string\">'jiagou'</span></span><br><span class=\"line\">            eat() &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'吃饭饭'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @enhancer</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"属性装饰器\"><a href=\"#属性装饰器\" class=\"headerlink\" title=\"属性装饰器\"></a>属性装饰器</h4><ul>\n<li>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数</li>\n<li>属性装饰器用来装饰属性</li>\n<li>第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第二个参数是属性的名称</li>\n<li>方法装饰器用来装饰方法</li>\n<li>第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第二个参数是方法的名称</li>\n<li>第三个参数是方法描述符</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">namespace d &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upperCase</span>(<span class=\"params\">target: any, propertyKey: string</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = target[propertyKey];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> getter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 用来替换的setter</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> setter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal: string</span>) </span>&#123;</span><br><span class=\"line\">            value = newVal.toUpperCase()</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 替换属性，先删除原先的属性，再重新定义属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">delete</span> target[propertyKey]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(target, propertyKey, &#123;</span><br><span class=\"line\">                <span class=\"keyword\">get</span>: getter,</span><br><span class=\"line\">                <span class=\"keyword\">set</span>: setter,</span><br><span class=\"line\">                enumerable: true,</span><br><span class=\"line\">                configurable: true</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function noEnumerable(target: any, property: string, descriptor: PropertyDescriptor) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target.getName'</span>, target.getName);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target.getAge'</span>, target.getAge);</span><br><span class=\"line\">        descriptor.enumerable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toNumber</span>(<span class=\"params\">target: any, methodName: string, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> oldMethod = descriptor.value;</span><br><span class=\"line\">        descriptor.value = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...args: any[]</span>) </span>&#123;</span><br><span class=\"line\">            args = args.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">parseFloat</span>(item));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldMethod.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        @upperCase</span><br><span class=\"line\">        name: string = <span class=\"string\">'zhufeng'</span></span><br><span class=\"line\">        public <span class=\"keyword\">static</span> age: number = <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123; &#125;</span><br><span class=\"line\">        @noEnumerable</span><br><span class=\"line\">        getName() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @toNumber</span><br><span class=\"line\">        sum(...args: any[]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> args.reduce(<span class=\"function\">(<span class=\"params\">accu: number, item: number</span>) =&gt;</span> accu + item, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> attr <span class=\"keyword\">in</span> p) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'attr='</span>, attr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p.name = <span class=\"string\">'jiagou'</span>;</span><br><span class=\"line\">    p.getName();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.sum(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数装饰器\"><a href=\"#参数装饰器\" class=\"headerlink\" title=\"参数装饰器\"></a>参数装饰器</h4><ul>\n<li>会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据</li>\n<li>第1个参数对于静态成员是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第2个参数的名称</li>\n<li>第3个参数在函数列表中的索引</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">namespace d &#123;</span><br><span class=\"line\">    interface Person &#123;</span><br><span class=\"line\">        age: number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addAge</span>(<span class=\"params\">target: any, methodName: string, paramsIndex: number</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(target);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(methodName);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(paramsIndex);</span><br><span class=\"line\">        target.age = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        login(username: string, @addAge password: string) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age, username, password);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    p.login(<span class=\"string\">'zhufeng'</span>, <span class=\"string\">'123456'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器执行顺序\"><a href=\"#装饰器执行顺序\" class=\"headerlink\" title=\"装饰器执行顺序\"></a>装饰器执行顺序</h3><ul>\n<li>有多个参数装饰器时：从最后一个参数依次向前执行</li>\n<li>方法和方法参数中参数装饰器先执行。</li>\n<li>类装饰器总是最后执行</li>\n<li>方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">namespace e &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Class1Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"类1装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Class2Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"类2装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MethodDecorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any, methodName: string, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"方法装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Param1Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any, methodName: string, paramIndex: number</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"参数1装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Param2Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any, methodName: string, paramIndex: number</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"参数2装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">PropertyDecorator</span>(<span class=\"params\">name: string</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any, propertyName: string</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(name + <span class=\"string\">\"属性装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Class1Decorator()</span><br><span class=\"line\">    @Class2Decorator()</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        @PropertyDecorator(<span class=\"string\">'name'</span>)</span><br><span class=\"line\">        name: string = <span class=\"string\">'zhufeng'</span>;</span><br><span class=\"line\">        @PropertyDecorator(<span class=\"string\">'age'</span>)</span><br><span class=\"line\">        age: number = <span class=\"number\">10</span>;</span><br><span class=\"line\">        @MethodDecorator()</span><br><span class=\"line\">        greet(@Param1Decorator() p1: string, @Param2Decorator() p2: string) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>/**<br>name属性装饰器<br>age属性装饰器<br>参数2装饰器<br>参数1装饰器<br>方法装饰器<br>类2装饰器<br>类1装饰器<br> */</p>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>抽象描述一种抽象的概念，无法被实例化，只能被继承</li>\n<li>无法创建抽象类的实例\\</li>\n<li>抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现，而且必须实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    name!:string;</span><br><span class=\"line\">    abstract speak():<span class=\"keyword\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'喵喵喵'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal();<span class=\"comment\">//Cannot create an instance of an abstract class</span></span><br><span class=\"line\">animal.speak();</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">cat.speak();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>访问控制修饰符 private protected public</li>\n<li>只读属性 readonly</li>\n<li>静态属性 static</li>\n<li>抽象类、抽象方法 abstract</li>\n</ul>\n<h4 id=\"抽象类-vs-接口\"><a href=\"#抽象类-vs-接口\" class=\"headerlink\" title=\"抽象类 vs 接口\"></a>抽象类 vs 接口</h4><ul>\n<li>不同类之间公有的属性或方法，可以抽象成一个接口（Interfaces）</li>\n<li>而抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>\n<li>抽象类本质是一个无法被实例化的类，其中能够实现方法和初始化属性，而接口仅能够用于描述,既不提供方法的实现，也不为属性进行初始化</li>\n<li>一个类可以继承一个类或抽象类，但可以实现（implements）多个接口</li>\n<li>抽象类也可以实现接口</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    abstract speak():<span class=\"keyword\">void</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">interface Flying&#123;</span><br><span class=\"line\">      fly():<span class=\"keyword\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> <span class=\"title\">implements</span> <span class=\"title\">Flying</span></span>&#123;</span><br><span class=\"line\">      speak()&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'汪汪汪'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      fly()&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'我会飞'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> duck = <span class=\"keyword\">new</span> Duck(<span class=\"string\">'zhufeng'</span>);</span><br><span class=\"line\">duck.speak();</span><br><span class=\"line\">duck.fly();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"抽象方法\"><a href=\"#抽象方法\" class=\"headerlink\" title=\"抽象方法\"></a>抽象方法</h4><ul>\n<li>抽象类和方法不包含具体实现，必须在子类中实现</li>\n<li>抽象方法只能出现在抽象类中</li>\n<li>子类可以对抽象类进行不同的实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    abstract speak():<span class=\"keyword\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span>  <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'小狗汪汪汪'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span>  <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'小猫喵喵喵'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog=<span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat=<span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">dog.speak();</span><br><span class=\"line\">cat.speak();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重写-override-vs-重载-overload\"><a href=\"#重写-override-vs-重载-overload\" class=\"headerlink\" title=\"重写(override) vs 重载(overload)\"></a>重写(override) vs 重载(overload)</h3><ul>\n<li>重写是指子类重写继承自父类中的方法</li>\n<li>重载是指为同一个函数提供多个类型定义</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak(word:string):string&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'动作叫:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak(word:string):string&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'猫叫:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.speak(<span class=\"string\">'hello'</span>));</span><br><span class=\"line\"><span class=\"comment\">//--------------------------------------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:number</span>):<span class=\"title\">number</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:string</span>):<span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:any</span>):<span class=\"title\">any</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> val == <span class=\"string\">'number'</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val *<span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val + val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> r = double(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(r);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承-vs-多态\"><a href=\"#继承-vs-多态\" class=\"headerlink\" title=\"继承 vs 多态\"></a>继承 vs 多态</h3><ul>\n<li>继承(Inheritance)子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>\n<li>多态(Polymorphism)由继承而产生了相关的不同的类，对同一个方法可以有不同的行为</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak(word:string):string&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Animal: '</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak(word:string):string&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Cat:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak(word:string):string&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Dog:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.speak(<span class=\"string\">'hello'</span>));</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.speak(<span class=\"string\">'hello'</span>));</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"如何定义类\"><a href=\"#如何定义类\" class=\"headerlink\" title=\"如何定义类\"></a>如何定义类</h3><p>“strictPropertyInitialization”: true / 启用类属性初始化的严格检查/<br>name!:string</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    getName():<span class=\"keyword\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p1.name = <span class=\"string\">'zhufeng'</span>;</span><br><span class=\"line\">p1.getName();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存取器\"><a href=\"#存取器\" class=\"headerlink\" title=\"存取器\"></a>存取器</h3><ul>\n<li>在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为</li>\n<li>构造函数</li>\n<li>主要用于初始化类的成员变量属性</li>\n<li>类的对象创建时自动调用执行</li>\n<li>没有返回值</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    myname:string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(myname: string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zhufeng'</span>);</span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name); </span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> User = <span class=\"comment\">/** @class */</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">User</span>(<span class=\"params\">myname</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(User.prototype, <span class=\"string\">\"name\"</span>, &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>: function () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">set</span>: function (value) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> User;</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"><span class=\"keyword\">var</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zhufeng'</span>);</span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数属性\"><a href=\"#参数属性\" class=\"headerlink\" title=\"参数属性\"></a>参数属性</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(public myname: string) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zhufeng'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name); </span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"readonly\"><a href=\"#readonly\" class=\"headerlink\" title=\"readonly\"></a>readonly</h3><ul>\n<li>readonly修饰的变量只能在构造函数中初始化</li>\n<li>在 TypeScript 中，const 是常量标志符，其值不能被重新分配</li>\n<li>TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly</li>\n<li>readonly 实际上只是在编译阶段进行代码检查。而 const 则会在运行时检查（在支持 const 语法的 JavaScript 运行时环境中）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    public readonly name: string</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    changeName(name:string)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'zhufeng'</span>);</span><br><span class=\"line\">a.changeName(<span class=\"string\">'jiagou'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><ul>\n<li>子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性\\</li>\n<li>将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑</li>\n<li>super可以调用父类上的方法和属性</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    name: string;<span class=\"comment\">//定义实例的属性，默认省略public修饰符</span></span><br><span class=\"line\">    age: number;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string,age:number) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName():string &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name:string): <span class=\"keyword\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    no: number;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string,age:number,no:number) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name,age);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.no=no;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getNo():number &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.no;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s1=<span class=\"keyword\">new</span> Student(<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s1);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类里面的修饰符\"><a href=\"#类里面的修饰符\" class=\"headerlink\" title=\"类里面的修饰符\"></a>类里面的修饰符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    public name: string;  <span class=\"comment\">//类里面 子类 其它任何地方外边都可以访问</span></span><br><span class=\"line\">    protected age: number; <span class=\"comment\">//类里面 子类 都可以访问,其它任何地方不能访问</span></span><br><span class=\"line\">    private money: number; <span class=\"comment\">//类里面可以访问， 子类和其它任何地方都不可以访问</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string,age:number,money:number) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.money=money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName():string &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name:string): <span class=\"keyword\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string,age:number,money:number) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name,age,money);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    desc() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.age&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.money&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.age);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.money);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态属性-静态方法\"><a href=\"#静态属性-静态方法\" class=\"headerlink\" title=\"静态属性 静态方法\"></a>静态属性 静态方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> className=<span class=\"string\">'Father'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> getClassName() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Father.className;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public name: string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Father.className);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Father.getClassName());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><ul>\n<li>装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为</li>\n<li>常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器</li>\n<li>装饰器的写法分为普通装饰器和装饰器工厂</li>\n</ul>\n<h4 id=\"类装饰器\"><a href=\"#类装饰器\" class=\"headerlink\" title=\"类装饰器\"></a>类装饰器</h4><p>类装饰器在类声明之前声明，用来监视、修改或替换类定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">namespace a &#123;</span><br><span class=\"line\">    interface Person &#123;</span><br><span class=\"line\">        name: string;</span><br><span class=\"line\">        eat: any</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: any</span>) </span>&#123;</span><br><span class=\"line\">        target.prototype.name = <span class=\"string\">'zhufeng'</span>;</span><br><span class=\"line\">        target.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'eat'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @enhancer</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace b &#123;</span><br><span class=\"line\">    interface Person &#123;</span><br><span class=\"line\">        name: string;</span><br><span class=\"line\">        eat: any</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">name: string</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: any</span>) </span>&#123;</span><br><span class=\"line\">            target.prototype.name = name;</span><br><span class=\"line\">            target.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'eat'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @enhancer(<span class=\"string\">'zhufeng'</span>)</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace c &#123;</span><br><span class=\"line\">    interface Person &#123;</span><br><span class=\"line\">        name: string;</span><br><span class=\"line\">        eat: any</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: any</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;</span><br><span class=\"line\">            name: string = <span class=\"string\">'jiagou'</span></span><br><span class=\"line\">            eat() &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'吃饭饭'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @enhancer</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"属性装饰器\"><a href=\"#属性装饰器\" class=\"headerlink\" title=\"属性装饰器\"></a>属性装饰器</h4><ul>\n<li>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数</li>\n<li>属性装饰器用来装饰属性</li>\n<li>第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第二个参数是属性的名称</li>\n<li>方法装饰器用来装饰方法</li>\n<li>第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第二个参数是方法的名称</li>\n<li>第三个参数是方法描述符</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">namespace d &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upperCase</span>(<span class=\"params\">target: any, propertyKey: string</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = target[propertyKey];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> getter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 用来替换的setter</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> setter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal: string</span>) </span>&#123;</span><br><span class=\"line\">            value = newVal.toUpperCase()</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 替换属性，先删除原先的属性，再重新定义属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">delete</span> target[propertyKey]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(target, propertyKey, &#123;</span><br><span class=\"line\">                <span class=\"keyword\">get</span>: getter,</span><br><span class=\"line\">                <span class=\"keyword\">set</span>: setter,</span><br><span class=\"line\">                enumerable: true,</span><br><span class=\"line\">                configurable: true</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function noEnumerable(target: any, property: string, descriptor: PropertyDescriptor) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target.getName'</span>, target.getName);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target.getAge'</span>, target.getAge);</span><br><span class=\"line\">        descriptor.enumerable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toNumber</span>(<span class=\"params\">target: any, methodName: string, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> oldMethod = descriptor.value;</span><br><span class=\"line\">        descriptor.value = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...args: any[]</span>) </span>&#123;</span><br><span class=\"line\">            args = args.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">parseFloat</span>(item));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldMethod.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        @upperCase</span><br><span class=\"line\">        name: string = <span class=\"string\">'zhufeng'</span></span><br><span class=\"line\">        public <span class=\"keyword\">static</span> age: number = <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123; &#125;</span><br><span class=\"line\">        @noEnumerable</span><br><span class=\"line\">        getName() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @toNumber</span><br><span class=\"line\">        sum(...args: any[]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> args.reduce(<span class=\"function\">(<span class=\"params\">accu: number, item: number</span>) =&gt;</span> accu + item, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> attr <span class=\"keyword\">in</span> p) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'attr='</span>, attr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p.name = <span class=\"string\">'jiagou'</span>;</span><br><span class=\"line\">    p.getName();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.sum(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数装饰器\"><a href=\"#参数装饰器\" class=\"headerlink\" title=\"参数装饰器\"></a>参数装饰器</h4><ul>\n<li>会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据</li>\n<li>第1个参数对于静态成员是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第2个参数的名称</li>\n<li>第3个参数在函数列表中的索引</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">namespace d &#123;</span><br><span class=\"line\">    interface Person &#123;</span><br><span class=\"line\">        age: number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addAge</span>(<span class=\"params\">target: any, methodName: string, paramsIndex: number</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(target);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(methodName);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(paramsIndex);</span><br><span class=\"line\">        target.age = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        login(username: string, @addAge password: string) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age, username, password);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    p.login(<span class=\"string\">'zhufeng'</span>, <span class=\"string\">'123456'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器执行顺序\"><a href=\"#装饰器执行顺序\" class=\"headerlink\" title=\"装饰器执行顺序\"></a>装饰器执行顺序</h3><ul>\n<li>有多个参数装饰器时：从最后一个参数依次向前执行</li>\n<li>方法和方法参数中参数装饰器先执行。</li>\n<li>类装饰器总是最后执行</li>\n<li>方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">namespace e &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Class1Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"类1装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Class2Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"类2装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MethodDecorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any, methodName: string, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"方法装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Param1Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any, methodName: string, paramIndex: number</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"参数1装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Param2Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any, methodName: string, paramIndex: number</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"参数2装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">PropertyDecorator</span>(<span class=\"params\">name: string</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: any, propertyName: string</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(name + <span class=\"string\">\"属性装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Class1Decorator()</span><br><span class=\"line\">    @Class2Decorator()</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">        @PropertyDecorator(<span class=\"string\">'name'</span>)</span><br><span class=\"line\">        name: string = <span class=\"string\">'zhufeng'</span>;</span><br><span class=\"line\">        @PropertyDecorator(<span class=\"string\">'age'</span>)</span><br><span class=\"line\">        age: number = <span class=\"number\">10</span>;</span><br><span class=\"line\">        @MethodDecorator()</span><br><span class=\"line\">        greet(@Param1Decorator() p1: string, @Param2Decorator() p2: string) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>/**<br>name属性装饰器<br>age属性装饰器<br>参数2装饰器<br>参数1装饰器<br>方法装饰器<br>类2装饰器<br>类1装饰器<br> */</p>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>抽象描述一种抽象的概念，无法被实例化，只能被继承</li>\n<li>无法创建抽象类的实例\\</li>\n<li>抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现，而且必须实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">    name!:string;</span><br><span class=\"line\">    abstract speak():<span class=\"keyword\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'喵喵喵'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal();<span class=\"comment\">//Cannot create an instance of an abstract class</span></span><br><span class=\"line\">animal.speak();</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">cat.speak();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>访问控制修饰符 private protected public</li>\n<li>只读属性 readonly</li>\n<li>静态属性 static</li>\n<li>抽象类、抽象方法 abstract</li>\n</ul>\n<h4 id=\"抽象类-vs-接口\"><a href=\"#抽象类-vs-接口\" class=\"headerlink\" title=\"抽象类 vs 接口\"></a>抽象类 vs 接口</h4><ul>\n<li>不同类之间公有的属性或方法，可以抽象成一个接口（Interfaces）</li>\n<li>而抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>\n<li>抽象类本质是一个无法被实例化的类，其中能够实现方法和初始化属性，而接口仅能够用于描述,既不提供方法的实现，也不为属性进行初始化</li>\n<li>一个类可以继承一个类或抽象类，但可以实现（implements）多个接口</li>\n<li>抽象类也可以实现接口</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name:string)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    abstract speak():<span class=\"keyword\">void</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">interface Flying&#123;</span><br><span class=\"line\">      fly():<span class=\"keyword\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> <span class=\"title\">implements</span> <span class=\"title\">Flying</span></span>&#123;</span><br><span class=\"line\">      speak()&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'汪汪汪'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      fly()&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'我会飞'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> duck = <span class=\"keyword\">new</span> Duck(<span class=\"string\">'zhufeng'</span>);</span><br><span class=\"line\">duck.speak();</span><br><span class=\"line\">duck.fly();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"抽象方法\"><a href=\"#抽象方法\" class=\"headerlink\" title=\"抽象方法\"></a>抽象方法</h4><ul>\n<li>抽象类和方法不包含具体实现，必须在子类中实现</li>\n<li>抽象方法只能出现在抽象类中</li>\n<li>子类可以对抽象类进行不同的实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    abstract speak():<span class=\"keyword\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span>  <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'小狗汪汪汪'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span>  <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'小猫喵喵喵'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog=<span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat=<span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">dog.speak();</span><br><span class=\"line\">cat.speak();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重写-override-vs-重载-overload\"><a href=\"#重写-override-vs-重载-overload\" class=\"headerlink\" title=\"重写(override) vs 重载(overload)\"></a>重写(override) vs 重载(overload)</h3><ul>\n<li>重写是指子类重写继承自父类中的方法</li>\n<li>重载是指为同一个函数提供多个类型定义</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak(word:string):string&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'动作叫:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak(word:string):string&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'猫叫:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.speak(<span class=\"string\">'hello'</span>));</span><br><span class=\"line\"><span class=\"comment\">//--------------------------------------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:number</span>):<span class=\"title\">number</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:string</span>):<span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:any</span>):<span class=\"title\">any</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> val == <span class=\"string\">'number'</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val *<span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val + val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> r = double(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(r);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承-vs-多态\"><a href=\"#继承-vs-多态\" class=\"headerlink\" title=\"继承 vs 多态\"></a>继承 vs 多态</h3><ul>\n<li>继承(Inheritance)子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>\n<li>多态(Polymorphism)由继承而产生了相关的不同的类，对同一个方法可以有不同的行为</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak(word:string):string&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Animal: '</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak(word:string):string&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Cat:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    speak(word:string):string&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Dog:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.speak(<span class=\"string\">'hello'</span>));</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.speak(<span class=\"string\">'hello'</span>));</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckbw73ckj00081gsx7k2s98b7","category_id":"ckbw73ckg00051gsxftz9g4v0","_id":"ckbw73ckm000d1gsx0hz1gb9d"},{"post_id":"ckbw73ckc00031gsx2bqm6zwx","category_id":"ckbw73ckg00051gsxftz9g4v0","_id":"ckbw73cko000h1gsx33rbccd7"},{"post_id":"ckbw73ckf00041gsx27ry2cni","category_id":"ckbw73ckg00051gsxftz9g4v0","_id":"ckbw73cko000i1gsxh8dwgkss"},{"post_id":"ckbw73cki00071gsxe6bkg5j8","category_id":"ckbw73ckg00051gsxftz9g4v0","_id":"ckbw73ckp000k1gsx8zldf7ag"}],"PostTag":[{"post_id":"ckbw73ckj00081gsx7k2s98b7","tag_id":"ckbw73ckh00061gsx50zc7ift","_id":"ckbw73ckm000b1gsxb61u6myi"},{"post_id":"ckbw73ckc00031gsx2bqm6zwx","tag_id":"ckbw73ckh00061gsx50zc7ift","_id":"ckbw73ckm000c1gsxhx2naak4"},{"post_id":"ckbw73ckf00041gsx27ry2cni","tag_id":"ckbw73ckh00061gsx50zc7ift","_id":"ckbw73cko000g1gsx10ch57b5"},{"post_id":"ckbw73cki00071gsxe6bkg5j8","tag_id":"ckbw73ckh00061gsx50zc7ift","_id":"ckbw73ckp000j1gsx9qgn6fou"}],"Tag":[{"name":"typescript","_id":"ckbw73ckh00061gsx50zc7ift"}]}}