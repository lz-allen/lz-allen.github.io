{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":0,"renderable":1},{"_id":"themes/Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/blog.js","path":"js/blog.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Anisina/.gitignore","hash":"7a2d5c9a8f18e75645eabbeacbf0ee83ba15e854","modified":1589653314689},{"_id":"themes/Anisina/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1589653314689},{"_id":"themes/Anisina/README.md","hash":"6090746aeee0e5ad4ad0107b85e808e6f3937f98","modified":1589653314689},{"_id":"themes/Anisina/_config.yml","hash":"5baf18c53f7635cd35aa5a8dab8abc08251023ce","modified":1589699399869},{"_id":"themes/Anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1589653314721},{"_id":"source/about/index.md","hash":"fa7843d236147bbeb738bdee72321e71e3f839b4","modified":1592758290915},{"_id":"source/categories/index.md","hash":"d0b7145a7592ad02fdc8cd7c52ac4b287c710045","modified":1589698714969},{"_id":"source/tags/index.md","hash":"5d041400f798de850b8400958e1dee8d0484d735","modified":1592743775977},{"_id":"themes/Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1589653314689},{"_id":"themes/Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1589653314705},{"_id":"themes/Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1589653314721},{"_id":"themes/Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1589653314721},{"_id":"themes/Anisina/layout/.DS_Store","hash":"fd623c7cbe0d8fd902f6ca242127fd8db7da6c18","modified":1589653314721},{"_id":"themes/Anisina/layout/layout.ejs","hash":"b728827bf3ec55baf96a882032397e6c74c65f34","modified":1589653314721},{"_id":"themes/Anisina/layout/categories.ejs","hash":"055ac64a3ba036e29ff984fd886d57d580bbbff6","modified":1589653314721},{"_id":"themes/Anisina/layout/index.ejs","hash":"a0eaee13571e79c3632e23a9e94ccc991761d1f5","modified":1589653314721},{"_id":"themes/Anisina/layout/poetry.ejs","hash":"ef66c2e1b5139f9049fdd7e1d994ede8cd648334","modified":1592753405183},{"_id":"themes/Anisina/layout/tags.ejs","hash":"a5b73e70540e12532aa92f12609b3a937a8bc28b","modified":1589653314721},{"_id":"themes/Anisina/layout/post.ejs","hash":"1a7d9837be94f32080ff3877d5e2bec3913b6d4f","modified":1589729075462},{"_id":"themes/Anisina/layout/page.ejs","hash":"e32025f588c77976100ff1aaa8d0c0490536616b","modified":1592750989081},{"_id":"themes/Anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1589653314721},{"_id":"themes/Anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1589653314705},{"_id":"source/_posts/page/typescript函数.md","hash":"4927556cb28248a742111b922d047aef1583a0e0","modified":1597400418000},{"_id":"source/_posts/page/typescript基本数据类型.md","hash":"bcc67370856804b85881aa21ebbcfa60f323e53e","modified":1597400418000},{"_id":"source/_posts/page/typescript开发自动修复.md","hash":"9afca4063828416bb07b5ef15c8a089dcb6f2db1","modified":1597400418000},{"_id":"source/_posts/page/typescript类.md","hash":"3f4a81ed5a449f83847d269933c7b74e7fa6d7c3","modified":1597400418000},{"_id":"themes/Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1589653314689},{"_id":"themes/Anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1589653314721},{"_id":"themes/Anisina/source/css/blog-style.css","hash":"e5880351fdf2c2222a3e5415a47f406fcc0eecc5","modified":1589696777102},{"_id":"themes/Anisina/layout/_partial/head.ejs","hash":"4e0d96cac503d4e3a5b254d8b8175c392971ce38","modified":1589653314721},{"_id":"themes/Anisina/layout/_partial/nav.ejs","hash":"1341f0c6b5527e30f418a37134cb0aa63be1e936","modified":1589698219457},{"_id":"themes/Anisina/layout/_partial/footer.ejs","hash":"f0f10f570abce5408d0742ab01a770fe72e1cc87","modified":1592750978636},{"_id":"themes/Anisina/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1589653314736},{"_id":"themes/Anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1589653314736},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1589653314721},{"_id":"themes/Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1589653314736},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1589653314736},{"_id":"themes/Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1589653314736},{"_id":"themes/Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1589653314705},{"_id":"themes/Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1589653314721},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1589653314721},{"_id":"themes/Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1589653314736},{"_id":"themes/Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1589653314736},{"_id":"themes/Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1589653314705},{"_id":"themes/Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1589653314705},{"_id":"themes/Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1589653314705},{"_id":"public/about/index.html","hash":"91cd9ebb927369777ba0bc2776f71d0e13ee35c3","modified":1593174717876},{"_id":"public/tags/index.html","hash":"3a12cc9988f7462fa4ecce3ce4852f0c1b05f472","modified":1593174717876},{"_id":"public/categories/index.html","hash":"1cd387952d0c2948ec6dfd842a914d5d2da22443","modified":1593174717876},{"_id":"public/archives/2019/index.html","hash":"c3f8e4b779ad3a2e86794c91a3a818bbf4ce0b46","modified":1593174717876},{"_id":"public/archives/2019/05/index.html","hash":"37b6e517beeac917241f638604882f98a26d1427","modified":1593174717876},{"_id":"public/archives/2020/index.html","hash":"fa28d0af7f30f5c3403d16c8840e45dd3e5b4b61","modified":1593174717876},{"_id":"public/archives/2020/05/index.html","hash":"ad9b342b7d1b576bd6edefdd188471d07ba1502d","modified":1593174717876},{"_id":"public/2020/05/22/page/typescript类/index.html","hash":"f6161635bc5e0cde25a3bd83a6ca5561c3c05007","modified":1593174717876},{"_id":"public/2019/05/21/page/typescript开发自动修复/index.html","hash":"001b08db78ff706fdc0e9852e5715b85a0fb2852","modified":1593174717876},{"_id":"public/2019/05/17/page/typescript基本数据类型/index.html","hash":"ade6027a7489cb0cd6f6b1d121c7f786f8357de6","modified":1593174717876},{"_id":"public/2019/05/17/page/typescript函数/index.html","hash":"51fa53d5bd37eb0318f19736d6a87927dd1ee443","modified":1593174717876},{"_id":"public/archives/index.html","hash":"b0f8dc51d7a78ac865f1f04aa177f7395219dc89","modified":1593174717876},{"_id":"public/categories/web前端/index.html","hash":"cfc109774501109a631966da127f9781c630684c","modified":1593174717876},{"_id":"public/tags/typescript/index.html","hash":"abbf110a47a8b5a565e87ef6e8ba303b3a48de26","modified":1593174717876},{"_id":"public/index.html","hash":"a0a51bf13b911e10dc2e224dbe7363e62a369c66","modified":1593174717876},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1593174717876},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1593174717876},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1593174717876},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1593174717876},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1593174717876},{"_id":"public/css/syntax.css","hash":"4616879fec214c9cc4f5835615348f0bbeabf2a9","modified":1593174717876},{"_id":"public/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1593174717876},{"_id":"public/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1593174717876},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1593174717876},{"_id":"public/css/blog-style.css","hash":"e5880351fdf2c2222a3e5415a47f406fcc0eecc5","modified":1593174717876},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1593174717876},{"_id":"public/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1593174717876},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1593174717876},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1593174717876},{"_id":"source/_posts/page/typescript接口和泛型.md","hash":"d089afb913630e44772bfc7c6c7eae77df5e8f06","modified":1597400418000},{"_id":"source/_posts/page/typescript类型申明、保护、命名空间.md","hash":"010e70d07c41cf84a048be1f251a054c3ec2621c","modified":1597400418000}],"Category":[{"name":"web前端","_id":"ckbw73ckg00051gsxftz9g4v0"}],"Data":[],"Page":[{"title":"关于","date":"2020-06-21T15:05:47.000Z","layout":"poetry","_content":"\n## 个人信息\n\n- 龙兆峰/男\n- 本科/计算机科学与技术\n- 工作年限：4年\n- 技术博客：<https://lz-allen.github.io>\n- Github：<http://github.com/easychen>\n- 期望职位：高级前端工程师\n- 电话：13381678729\n\n## 技能清单\n\n- 熟练掌握 HTML，CSS ，熟练运用弹性盒子模型及 rem 布局\n- 掌握 HTML5+CSS3 新特性，根据设计图完成页面设计\n- 熟练掌握 JavaScript 语言，熟悉 ES5/ES6\n- 熟练使用第三方 JavaScript 库，比如 jQuery, Moment.js, lodash.js 等\n- 熟练 ajax、fetch 前端交互技术，熟悉 jsonp,cors,nginx 反向代理跨域，并且解决常见的跨域问题\n- 熟练掌握 Vue 并有基于 Vue + Vuex + Webpack + ES6 + Vue-Router 项目架构经验\n- 熟练掌握 React+ Redux + Router + JSX + dva\n- 熟悉 Node.js,Koa,Express 搭建后台服务端，进行前后端的数据交互\n- 熟悉 Nginx 配置，Pm2 服务部署，linux 环境的配置\n- 能熟练运用 Element,Antd ui 库，搭建后台管理系统\n- 熟悉 Less 预编译，Css 模块化，能在项目中熟练的运用\n\n## 致谢\n\n感谢您花时间阅读我的简历，期待能有机会和您共事\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2020-06-21 23:05:47\nlayout: poetry\n---\n\n## 个人信息\n\n- 龙兆峰/男\n- 本科/计算机科学与技术\n- 工作年限：4年\n- 技术博客：<https://lz-allen.github.io>\n- Github：<http://github.com/easychen>\n- 期望职位：高级前端工程师\n- 电话：13381678729\n\n## 技能清单\n\n- 熟练掌握 HTML，CSS ，熟练运用弹性盒子模型及 rem 布局\n- 掌握 HTML5+CSS3 新特性，根据设计图完成页面设计\n- 熟练掌握 JavaScript 语言，熟悉 ES5/ES6\n- 熟练使用第三方 JavaScript 库，比如 jQuery, Moment.js, lodash.js 等\n- 熟练 ajax、fetch 前端交互技术，熟悉 jsonp,cors,nginx 反向代理跨域，并且解决常见的跨域问题\n- 熟练掌握 Vue 并有基于 Vue + Vuex + Webpack + ES6 + Vue-Router 项目架构经验\n- 熟练掌握 React+ Redux + Router + JSX + dva\n- 熟悉 Node.js,Koa,Express 搭建后台服务端，进行前后端的数据交互\n- 熟悉 Nginx 配置，Pm2 服务部署，linux 环境的配置\n- 能熟练运用 Element,Antd ui 库，搭建后台管理系统\n- 熟悉 Less 预编译，Css 模块化，能在项目中熟练的运用\n\n## 致谢\n\n感谢您花时间阅读我的简历，期待能有机会和您共事\n","updated":"2020-06-21T16:51:30.915Z","path":"about/index.html","comments":1,"_id":"ckbw73ck300001gsxcund9se3","content":"<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>龙兆峰/男</li>\n<li>本科/计算机科学与技术</li>\n<li>工作年限：4年</li>\n<li>技术博客：<a href=\"https://lz-allen.github.io\">https://lz-allen.github.io</a></li>\n<li>Github：<a href=\"http://github.com/easychen\" target=\"_blank\" rel=\"noopener\">http://github.com/easychen</a></li>\n<li>期望职位：高级前端工程师</li>\n<li>电话：13381678729</li>\n</ul>\n<h2 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\"技能清单\"></a>技能清单</h2><ul>\n<li>熟练掌握 HTML，CSS ，熟练运用弹性盒子模型及 rem 布局</li>\n<li>掌握 HTML5+CSS3 新特性，根据设计图完成页面设计</li>\n<li>熟练掌握 JavaScript 语言，熟悉 ES5/ES6</li>\n<li>熟练使用第三方 JavaScript 库，比如 jQuery, Moment.js, lodash.js 等</li>\n<li>熟练 ajax、fetch 前端交互技术，熟悉 jsonp,cors,nginx 反向代理跨域，并且解决常见的跨域问题</li>\n<li>熟练掌握 Vue 并有基于 Vue + Vuex + Webpack + ES6 + Vue-Router 项目架构经验</li>\n<li>熟练掌握 React+ Redux + Router + JSX + dva</li>\n<li>熟悉 Node.js,Koa,Express 搭建后台服务端，进行前后端的数据交互</li>\n<li>熟悉 Nginx 配置，Pm2 服务部署，linux 环境的配置</li>\n<li>能熟练运用 Element,Antd ui 库，搭建后台管理系统</li>\n<li>熟悉 Less 预编译，Css 模块化，能在项目中熟练的运用</li>\n</ul>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>感谢您花时间阅读我的简历，期待能有机会和您共事</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>龙兆峰/男</li>\n<li>本科/计算机科学与技术</li>\n<li>工作年限：4年</li>\n<li>技术博客：<a href=\"https://lz-allen.github.io\">https://lz-allen.github.io</a></li>\n<li>Github：<a href=\"http://github.com/easychen\" target=\"_blank\" rel=\"noopener\">http://github.com/easychen</a></li>\n<li>期望职位：高级前端工程师</li>\n<li>电话：13381678729</li>\n</ul>\n<h2 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\"技能清单\"></a>技能清单</h2><ul>\n<li>熟练掌握 HTML，CSS ，熟练运用弹性盒子模型及 rem 布局</li>\n<li>掌握 HTML5+CSS3 新特性，根据设计图完成页面设计</li>\n<li>熟练掌握 JavaScript 语言，熟悉 ES5/ES6</li>\n<li>熟练使用第三方 JavaScript 库，比如 jQuery, Moment.js, lodash.js 等</li>\n<li>熟练 ajax、fetch 前端交互技术，熟悉 jsonp,cors,nginx 反向代理跨域，并且解决常见的跨域问题</li>\n<li>熟练掌握 Vue 并有基于 Vue + Vuex + Webpack + ES6 + Vue-Router 项目架构经验</li>\n<li>熟练掌握 React+ Redux + Router + JSX + dva</li>\n<li>熟悉 Node.js,Koa,Express 搭建后台服务端，进行前后端的数据交互</li>\n<li>熟悉 Nginx 配置，Pm2 服务部署，linux 环境的配置</li>\n<li>能熟练运用 Element,Antd ui 库，搭建后台管理系统</li>\n<li>熟悉 Less 预编译，Css 模块化，能在项目中熟练的运用</li>\n</ul>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>感谢您花时间阅读我的简历，期待能有机会和您共事</p>\n"},{"title":"标签","date":"2020-06-21T12:49:20.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-06-21 20:49:20\nlayout: tags\n---\n","updated":"2020-06-21T12:49:35.977Z","path":"tags/index.html","comments":1,"_id":"ckbw73ck600011gsx6tjt8y0v","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章分类","date":"2020-05-17T06:55:09.000Z","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2020-05-17 14:55:09\nlayout: categories\n---\n","updated":"2020-05-17T06:58:34.969Z","path":"categories/index.html","comments":1,"_id":"ckbw73ck600021gsxh8m5gjqp","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ESLint自动修复","author":"lz_allen","date":"2019-05-21T15:59:31.000Z","_content":"\n## 模块安装\n\n```typescript\ncnpm i eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev\n```\n\n## eslintrc配置文件\n\n- .eslintrc.js\n\n```typescript\nmodule.exports = {\n    \"parser\":\"@typescript-eslint/parser\",\n    \"plugins\":[\"@typescript-eslint\"],\n    \"rules\":{\n        \"no-var\":\"error\",\n        \"no-extra-semi\":\"error\",\n        \"@typescript-eslint/indent\":[\"error\",2]\n    },\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\",\n        \"ecmaFeatures\": {\n          \"modules\": true\n        }\n    }\n}\n```\n\n## ESLint自动修复\n\n安装vscode的eslint插件\n配置参数 .vscode\\settings.json\n\n```typescript\n{\n  \"eslint.autoFixOnSave\": true,\n  \"eslint.validate\": [\n      \"javascript\",\n      \"javascriptreact\",\n      {\n          \"language\": \"typescript\",\n          \"autoFix\": true\n      },\n       {\n          \"language\": \"typescriptreact\",\n          \"autoFix\": true\n      }\n  ]\n}\n```\n\n## Git Hooks 检查\n\n- Git 基本已经成为项目开发中默认的版本管理软件，在使用 Git 的项目中，我们可以为项目设置 Git Hooks 来帮我们在提交代码的各个阶段做一些代码检查等工作\n- 钩子（Hooks） 都被存储在 Git 目录下的 hooks 子目录中。 也就是绝大部分项目中的 .git/hooks 目录\n- 钩子分为两大类，客户端的和服务器端的\n  - 客户端钩子主要被提交和合并这样的操作所调用\n  - 而服务器端钩子作用于接收被推送的提交这样的联网操作，这里我们主要介绍客户端钩子\n\n### pre-commit\n\n- pre-commit 就是在代码提交之前做些东西，比如代码打包，代码检测，称之为钩子（hook）\n- 在commit之前执行一个函数（callback）。这个函数成功执行完之后，再继续commit，但是失败之后就阻止commit\n- 在.git->hooks->下面有个pre-commit.sample*，这个里面就是默认的函数(脚本)样本\n\n### 安装pre-commit、\n\n```typescript\nnpm install pre-commit --save-dev\n```\n\n### 脚本配置\n\n```typescript\n \"scripts\": {\n    \"build\": \"tsc\",\n    \"eslint\": \"eslint src --ext .ts\",\n    \"eslint:fix\": \"eslint src --ext .ts --fix\"\n  },\n  \"pre-commit\": [\n    \"eslint\"\n  ]\n```\n\n","source":"_posts/page/typescript开发自动修复.md","raw":"---\ntitle: ESLint自动修复\ncategories: web前端\nauthor: lz_allen\ntags:\n  - typescript\ndate: 2019-05-21 23:59:31\n---\n\n## 模块安装\n\n```typescript\ncnpm i eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev\n```\n\n## eslintrc配置文件\n\n- .eslintrc.js\n\n```typescript\nmodule.exports = {\n    \"parser\":\"@typescript-eslint/parser\",\n    \"plugins\":[\"@typescript-eslint\"],\n    \"rules\":{\n        \"no-var\":\"error\",\n        \"no-extra-semi\":\"error\",\n        \"@typescript-eslint/indent\":[\"error\",2]\n    },\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\",\n        \"ecmaFeatures\": {\n          \"modules\": true\n        }\n    }\n}\n```\n\n## ESLint自动修复\n\n安装vscode的eslint插件\n配置参数 .vscode\\settings.json\n\n```typescript\n{\n  \"eslint.autoFixOnSave\": true,\n  \"eslint.validate\": [\n      \"javascript\",\n      \"javascriptreact\",\n      {\n          \"language\": \"typescript\",\n          \"autoFix\": true\n      },\n       {\n          \"language\": \"typescriptreact\",\n          \"autoFix\": true\n      }\n  ]\n}\n```\n\n## Git Hooks 检查\n\n- Git 基本已经成为项目开发中默认的版本管理软件，在使用 Git 的项目中，我们可以为项目设置 Git Hooks 来帮我们在提交代码的各个阶段做一些代码检查等工作\n- 钩子（Hooks） 都被存储在 Git 目录下的 hooks 子目录中。 也就是绝大部分项目中的 .git/hooks 目录\n- 钩子分为两大类，客户端的和服务器端的\n  - 客户端钩子主要被提交和合并这样的操作所调用\n  - 而服务器端钩子作用于接收被推送的提交这样的联网操作，这里我们主要介绍客户端钩子\n\n### pre-commit\n\n- pre-commit 就是在代码提交之前做些东西，比如代码打包，代码检测，称之为钩子（hook）\n- 在commit之前执行一个函数（callback）。这个函数成功执行完之后，再继续commit，但是失败之后就阻止commit\n- 在.git->hooks->下面有个pre-commit.sample*，这个里面就是默认的函数(脚本)样本\n\n### 安装pre-commit、\n\n```typescript\nnpm install pre-commit --save-dev\n```\n\n### 脚本配置\n\n```typescript\n \"scripts\": {\n    \"build\": \"tsc\",\n    \"eslint\": \"eslint src --ext .ts\",\n    \"eslint:fix\": \"eslint src --ext .ts --fix\"\n  },\n  \"pre-commit\": [\n    \"eslint\"\n  ]\n```\n\n","slug":"page/typescript开发自动修复","published":1,"updated":"2020-08-14T10:20:18.000Z","_id":"ckbw73ckc00031gsx2bqm6zwx","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"模块安装\"><a href=\"#模块安装\" class=\"headerlink\" title=\"模块安装\"></a>模块安装</h2><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm i eslint typescript <span class=\"meta\">@typescript</span>-eslint/parser <span class=\"meta\">@typescript</span>-eslint/eslint-plugin --save-dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"eslintrc配置文件\"><a href=\"#eslintrc配置文件\" class=\"headerlink\" title=\"eslintrc配置文件\"></a>eslintrc配置文件</h2><ul>\n<li>.eslintrc.js</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"parser\"</span>:<span class=\"string\">\"@typescript-eslint/parser\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"plugins\"</span>:[<span class=\"string\">\"@typescript-eslint\"</span>],</span><br><span class=\"line\">    <span class=\"string\">\"rules\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"no-var\"</span>:<span class=\"string\">\"error\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"no-extra-semi\"</span>:<span class=\"string\">\"error\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"@typescript-eslint/indent\"</span>:[<span class=\"string\">\"error\"</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"parserOptions\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"ecmaVersion\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">        <span class=\"string\">\"sourceType\"</span>: <span class=\"string\">\"module\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"ecmaFeatures\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">\"modules\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ESLint自动修复\"><a href=\"#ESLint自动修复\" class=\"headerlink\" title=\"ESLint自动修复\"></a>ESLint自动修复</h2><p>安装vscode的eslint插件<br>配置参数 .vscode\\settings.json</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"eslint.autoFixOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"string\">\"eslint.validate\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"javascriptreact\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"string\">\"language\"</span>: <span class=\"string\">\"typescript\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"autoFix\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">          <span class=\"string\">\"language\"</span>: <span class=\"string\">\"typescriptreact\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"autoFix\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Git-Hooks-检查\"><a href=\"#Git-Hooks-检查\" class=\"headerlink\" title=\"Git Hooks 检查\"></a>Git Hooks 检查</h2><ul>\n<li>Git 基本已经成为项目开发中默认的版本管理软件，在使用 Git 的项目中，我们可以为项目设置 Git Hooks 来帮我们在提交代码的各个阶段做一些代码检查等工作</li>\n<li>钩子（Hooks） 都被存储在 Git 目录下的 hooks 子目录中。 也就是绝大部分项目中的 .git/hooks 目录</li>\n<li>钩子分为两大类，客户端的和服务器端的<ul>\n<li>客户端钩子主要被提交和合并这样的操作所调用</li>\n<li>而服务器端钩子作用于接收被推送的提交这样的联网操作，这里我们主要介绍客户端钩子</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"pre-commit\"><a href=\"#pre-commit\" class=\"headerlink\" title=\"pre-commit\"></a>pre-commit</h3><ul>\n<li>pre-commit 就是在代码提交之前做些东西，比如代码打包，代码检测，称之为钩子（hook）</li>\n<li>在commit之前执行一个函数（callback）。这个函数成功执行完之后，再继续commit，但是失败之后就阻止commit</li>\n<li>在.git-&gt;hooks-&gt;下面有个pre-commit.sample*，这个里面就是默认的函数(脚本)样本</li>\n</ul>\n<h3 id=\"安装pre-commit、\"><a href=\"#安装pre-commit、\" class=\"headerlink\" title=\"安装pre-commit、\"></a>安装pre-commit、</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install pre-commit --save-dev</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"脚本配置\"><a href=\"#脚本配置\" class=\"headerlink\" title=\"脚本配置\"></a>脚本配置</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">   <span class=\"string\">\"build\"</span>: <span class=\"string\">\"tsc\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"eslint\"</span>: <span class=\"string\">\"eslint src --ext .ts\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"eslint:fix\"</span>: <span class=\"string\">\"eslint src --ext .ts --fix\"</span></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> <span class=\"string\">\"pre-commit\"</span>: [</span><br><span class=\"line\">   <span class=\"string\">\"eslint\"</span></span><br><span class=\"line\"> ]</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"模块安装\"><a href=\"#模块安装\" class=\"headerlink\" title=\"模块安装\"></a>模块安装</h2><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnpm i eslint typescript <span class=\"meta\">@typescript</span>-eslint/parser <span class=\"meta\">@typescript</span>-eslint/eslint-plugin --save-dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"eslintrc配置文件\"><a href=\"#eslintrc配置文件\" class=\"headerlink\" title=\"eslintrc配置文件\"></a>eslintrc配置文件</h2><ul>\n<li>.eslintrc.js</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"parser\"</span>:<span class=\"string\">\"@typescript-eslint/parser\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"plugins\"</span>:[<span class=\"string\">\"@typescript-eslint\"</span>],</span><br><span class=\"line\">    <span class=\"string\">\"rules\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"no-var\"</span>:<span class=\"string\">\"error\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"no-extra-semi\"</span>:<span class=\"string\">\"error\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"@typescript-eslint/indent\"</span>:[<span class=\"string\">\"error\"</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"parserOptions\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"ecmaVersion\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">        <span class=\"string\">\"sourceType\"</span>: <span class=\"string\">\"module\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"ecmaFeatures\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">\"modules\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ESLint自动修复\"><a href=\"#ESLint自动修复\" class=\"headerlink\" title=\"ESLint自动修复\"></a>ESLint自动修复</h2><p>安装vscode的eslint插件<br>配置参数 .vscode\\settings.json</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"eslint.autoFixOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"string\">\"eslint.validate\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"javascriptreact\"</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"string\">\"language\"</span>: <span class=\"string\">\"typescript\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"autoFix\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">          <span class=\"string\">\"language\"</span>: <span class=\"string\">\"typescriptreact\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"autoFix\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Git-Hooks-检查\"><a href=\"#Git-Hooks-检查\" class=\"headerlink\" title=\"Git Hooks 检查\"></a>Git Hooks 检查</h2><ul>\n<li>Git 基本已经成为项目开发中默认的版本管理软件，在使用 Git 的项目中，我们可以为项目设置 Git Hooks 来帮我们在提交代码的各个阶段做一些代码检查等工作</li>\n<li>钩子（Hooks） 都被存储在 Git 目录下的 hooks 子目录中。 也就是绝大部分项目中的 .git/hooks 目录</li>\n<li>钩子分为两大类，客户端的和服务器端的<ul>\n<li>客户端钩子主要被提交和合并这样的操作所调用</li>\n<li>而服务器端钩子作用于接收被推送的提交这样的联网操作，这里我们主要介绍客户端钩子</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"pre-commit\"><a href=\"#pre-commit\" class=\"headerlink\" title=\"pre-commit\"></a>pre-commit</h3><ul>\n<li>pre-commit 就是在代码提交之前做些东西，比如代码打包，代码检测，称之为钩子（hook）</li>\n<li>在commit之前执行一个函数（callback）。这个函数成功执行完之后，再继续commit，但是失败之后就阻止commit</li>\n<li>在.git-&gt;hooks-&gt;下面有个pre-commit.sample*，这个里面就是默认的函数(脚本)样本</li>\n</ul>\n<h3 id=\"安装pre-commit、\"><a href=\"#安装pre-commit、\" class=\"headerlink\" title=\"安装pre-commit、\"></a>安装pre-commit、</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install pre-commit --save-dev</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"脚本配置\"><a href=\"#脚本配置\" class=\"headerlink\" title=\"脚本配置\"></a>脚本配置</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">   <span class=\"string\">\"build\"</span>: <span class=\"string\">\"tsc\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"eslint\"</span>: <span class=\"string\">\"eslint src --ext .ts\"</span>,</span><br><span class=\"line\">   <span class=\"string\">\"eslint:fix\"</span>: <span class=\"string\">\"eslint src --ext .ts --fix\"</span></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> <span class=\"string\">\"pre-commit\"</span>: [</span><br><span class=\"line\">   <span class=\"string\">\"eslint\"</span></span><br><span class=\"line\"> ]</span><br></pre></td></tr></table></figure>\n\n"},{"title":"TypeScript基本数据类型","date":"2019-05-17T07:19:26.000Z","_content":"\n## 数据类型\n\n### 1.布尔类型(boolean)\n\n```typescript\n\nlet isLzf: boolean=false;\n\n```\n\n### 1.2数字类型(number)\n\n```typescript\nlet age: number=10;\n```\n\n### 1.3 字符串类型(string)\n\n```typescript\nlet firstname: string='lzf';\n```\n\n### 1.4 数组类型(array)\n\n```typescript\nlet arr2: number[]=[4,5,6];\nlet arr3: Array<number>=[7,8,9];\n```\n\n### 1.5 元组类型(tuple)\n\n在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组\n\n```typescript\nlet zf:[string,number] = ['zf',5];\nzf[0].length;\nzf[1].toFixed(2);\n```\n\n元组\t数组\n每一项可以是不同的类型\t每一项都是同一种类型\n有预定义的长度\t没有长度限制\n用于表示一个固定的结构\t用于表示一个列表\n\n```typescript\nconst animal:[string,number,boolean] = ['zf',10,true];\n```\n\n### 1.6 枚举类型(enum)\n\n事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值\n比如性别、月份、星期、颜色、单位、学历\n\n#### 1.6.1 普通枚举\n\n```typescript\nenum Gender{\n    GIRL,\n    BOY\n}\nconsole.log(`lzf是${Gender.BOY}`);\nconsole.log(`zf${Gender.GIRL}`);\n\nenum Week{\n    MONDAY=1,\n    TUESDAY=2\n}\nconsole.log(`今天是星期${Week.MONDAY}`);\n```\n\n#### 1.6.2 常数枚举\n\n常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n假如包含了计算成员，则会在编译阶段报错\n\n```typescript\nconst enum Colors {\n    Red,\n    Yellow,\n    Blue\n}\n\nlet myColors = [Colors.Red, Colors.Yellow, Colors.Blue];\nconst enum Color {Red, Yellow, Blue = \"blue\".length};\n```\n\n### 1.7 任意类型(any)\n\nany就是可以赋值给任意类型\n第三方库没有提供类型文件时可以使用any\n类型转换遇到困难时\n数据结构太复杂难以定义\n\n```typescript\nlet root:any=document.getElementById('root');\nroot.style.color='red';\nlet root:(HTMLElement|null)=document.getElementById('root');\nroot!.style.color='red';//非空断言操作符\n```\n\n### 1.8 null 和 undefined\n\nnull 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined\nstrictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any\n\n```typescript\nlet x: number;\nx = 1;\nx = undefined;\nx = null;\n\nlet y: number | null | undefined;\ny = 1;\ny = undefined;\ny = null;\n```\n\n### 1.9 void 类型\n\nvoid 表示没有任何类型\n当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。\n\n```typescript\nfunction greeting(name:string):void {\n    console.log('hello',name);\n    //当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined\n    //严格模式(strictNullChecks:true)下只能返回undefined\n    //return null;\n    //return undefined;\n}\n```\n\n### 1.10 never类型\n\nnever是其它类型(null undefined)的子类型，代表不会出现的值\n作为不会返回（ return ）的函数的返回值类型\n\n```typescript\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\nlet result1 = error('hello');\n// 由类型推论得到返回值为 never\nfunction fail() {\n    return error(\"Something failed\");\n}\nlet result = fail();\n\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction infiniteLoop(): never {\n    while (true) {}\n}\n```\n\n#### 1.10.1 strictNullChecks\n\n在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 --strictNullChecks 这一种检查模式\n由于引入了 --strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。\n\n```typescript\n// Compiled with --strictNullChecks\nfunction fn(x: number | string) {\n  if (typeof x === 'number') {\n    // x: number 类型\n  } else if (typeof x === 'string') {\n    // x: string 类型\n  } else {\n    // x: never 类型\n    // --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察\n  }\n}\n```\n\n#### 1.10.2 never 和 void 的区别、\n\nvoid 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。\n拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。\n1.11 类型推论\n是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性\n定义时未赋值就会推论成any类型\n如果定义的时候就赋值就能利用到类型推论\n\n```typescript\nlet username2;\nusername2 = 10;\nusername2 = 'zf';\nusername2 = null;\n```\n\n### 1.12 包装对象（Wrapper Object）\n\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n所有的原始数据类型都没有属性（property）\n原始数据类型\n布尔值\n数值\n字符串\n\n```typescript\nnull\nundefined\nSymbol\nlet name = 'zf';\nconsole.log(name.toUpperCase());\nconsole.log((new String('zf')).toUpperCase());\n当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换\nlet isOK: boolean = true; // 编译通过\nlet isOK: boolean = Boolean(1) // 编译通过\nlet isOK: boolean = new Boolean(1); // 编译失败   期望的 isOK 是一个原始数据类型\n```\n\n### 1.13 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种\n未赋值时联合类型上只能访问两个类型共有的属性和方法\n\n```typescript\nlet name: string | number;\nconsole.log(name.toString());\nname = 3;\nconsole.log(name.toFixed(2));\nname = 'zf';\nconsole.log(name.length);\n\nexport {};\n```\n\n### 1.14 类型断言\n\n类型断言可以将一个联合类型的变量，指定为一个更加具体的类型\n不能将联合类型断言为不存在的类型\n\n```typescript\nlet name: string | number;\nconsole.log((name as string).length);\nconsole.log((name as number).toFixed(2));\nconsole.log((name as boolean));\n```\n\n### 1.15 字面量类型\n\n可以把字符串、数字、布尔值字面量组成一个联合类型\n\n```typescript\ntype ZType = 1 | 'One'|true;\nlet t1:ZType = 1;\nlet t2:ZType = 'One';\nlet t3:ZType = true;\n```\n\n### 1.16 字符串字面量 vs 联合类型\n\n字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种\n字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致\n","source":"_posts/page/typescript基本数据类型.md","raw":"---\ntitle: TypeScript基本数据类型\ntags:\n  - typescript\ncategories: web前端\ndate: 2019-05-17 15:19:26\n---\n\n## 数据类型\n\n### 1.布尔类型(boolean)\n\n```typescript\n\nlet isLzf: boolean=false;\n\n```\n\n### 1.2数字类型(number)\n\n```typescript\nlet age: number=10;\n```\n\n### 1.3 字符串类型(string)\n\n```typescript\nlet firstname: string='lzf';\n```\n\n### 1.4 数组类型(array)\n\n```typescript\nlet arr2: number[]=[4,5,6];\nlet arr3: Array<number>=[7,8,9];\n```\n\n### 1.5 元组类型(tuple)\n\n在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组\n\n```typescript\nlet zf:[string,number] = ['zf',5];\nzf[0].length;\nzf[1].toFixed(2);\n```\n\n元组\t数组\n每一项可以是不同的类型\t每一项都是同一种类型\n有预定义的长度\t没有长度限制\n用于表示一个固定的结构\t用于表示一个列表\n\n```typescript\nconst animal:[string,number,boolean] = ['zf',10,true];\n```\n\n### 1.6 枚举类型(enum)\n\n事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值\n比如性别、月份、星期、颜色、单位、学历\n\n#### 1.6.1 普通枚举\n\n```typescript\nenum Gender{\n    GIRL,\n    BOY\n}\nconsole.log(`lzf是${Gender.BOY}`);\nconsole.log(`zf${Gender.GIRL}`);\n\nenum Week{\n    MONDAY=1,\n    TUESDAY=2\n}\nconsole.log(`今天是星期${Week.MONDAY}`);\n```\n\n#### 1.6.2 常数枚举\n\n常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n假如包含了计算成员，则会在编译阶段报错\n\n```typescript\nconst enum Colors {\n    Red,\n    Yellow,\n    Blue\n}\n\nlet myColors = [Colors.Red, Colors.Yellow, Colors.Blue];\nconst enum Color {Red, Yellow, Blue = \"blue\".length};\n```\n\n### 1.7 任意类型(any)\n\nany就是可以赋值给任意类型\n第三方库没有提供类型文件时可以使用any\n类型转换遇到困难时\n数据结构太复杂难以定义\n\n```typescript\nlet root:any=document.getElementById('root');\nroot.style.color='red';\nlet root:(HTMLElement|null)=document.getElementById('root');\nroot!.style.color='red';//非空断言操作符\n```\n\n### 1.8 null 和 undefined\n\nnull 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined\nstrictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any\n\n```typescript\nlet x: number;\nx = 1;\nx = undefined;\nx = null;\n\nlet y: number | null | undefined;\ny = 1;\ny = undefined;\ny = null;\n```\n\n### 1.9 void 类型\n\nvoid 表示没有任何类型\n当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。\n\n```typescript\nfunction greeting(name:string):void {\n    console.log('hello',name);\n    //当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined\n    //严格模式(strictNullChecks:true)下只能返回undefined\n    //return null;\n    //return undefined;\n}\n```\n\n### 1.10 never类型\n\nnever是其它类型(null undefined)的子类型，代表不会出现的值\n作为不会返回（ return ）的函数的返回值类型\n\n```typescript\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\nlet result1 = error('hello');\n// 由类型推论得到返回值为 never\nfunction fail() {\n    return error(\"Something failed\");\n}\nlet result = fail();\n\n// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点\nfunction infiniteLoop(): never {\n    while (true) {}\n}\n```\n\n#### 1.10.1 strictNullChecks\n\n在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 --strictNullChecks 这一种检查模式\n由于引入了 --strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。\n\n```typescript\n// Compiled with --strictNullChecks\nfunction fn(x: number | string) {\n  if (typeof x === 'number') {\n    // x: number 类型\n  } else if (typeof x === 'string') {\n    // x: string 类型\n  } else {\n    // x: never 类型\n    // --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察\n  }\n}\n```\n\n#### 1.10.2 never 和 void 的区别、\n\nvoid 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。\n拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。\n1.11 类型推论\n是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性\n定义时未赋值就会推论成any类型\n如果定义的时候就赋值就能利用到类型推论\n\n```typescript\nlet username2;\nusername2 = 10;\nusername2 = 'zf';\nusername2 = null;\n```\n\n### 1.12 包装对象（Wrapper Object）\n\nJavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n所有的原始数据类型都没有属性（property）\n原始数据类型\n布尔值\n数值\n字符串\n\n```typescript\nnull\nundefined\nSymbol\nlet name = 'zf';\nconsole.log(name.toUpperCase());\nconsole.log((new String('zf')).toUpperCase());\n当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换\nlet isOK: boolean = true; // 编译通过\nlet isOK: boolean = Boolean(1) // 编译通过\nlet isOK: boolean = new Boolean(1); // 编译失败   期望的 isOK 是一个原始数据类型\n```\n\n### 1.13 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种\n未赋值时联合类型上只能访问两个类型共有的属性和方法\n\n```typescript\nlet name: string | number;\nconsole.log(name.toString());\nname = 3;\nconsole.log(name.toFixed(2));\nname = 'zf';\nconsole.log(name.length);\n\nexport {};\n```\n\n### 1.14 类型断言\n\n类型断言可以将一个联合类型的变量，指定为一个更加具体的类型\n不能将联合类型断言为不存在的类型\n\n```typescript\nlet name: string | number;\nconsole.log((name as string).length);\nconsole.log((name as number).toFixed(2));\nconsole.log((name as boolean));\n```\n\n### 1.15 字面量类型\n\n可以把字符串、数字、布尔值字面量组成一个联合类型\n\n```typescript\ntype ZType = 1 | 'One'|true;\nlet t1:ZType = 1;\nlet t2:ZType = 'One';\nlet t3:ZType = true;\n```\n\n### 1.16 字符串字面量 vs 联合类型\n\n字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种\n字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致\n","slug":"page/typescript基本数据类型","published":1,"updated":"2020-08-14T10:20:18.000Z","_id":"ckbw73ckf00041gsx27ry2cni","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"1-布尔类型-boolean\"><a href=\"#1-布尔类型-boolean\" class=\"headerlink\" title=\"1.布尔类型(boolean)\"></a>1.布尔类型(boolean)</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> isLzf: <span class=\"built_in\">boolean</span>=<span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2数字类型-number\"><a href=\"#1-2数字类型-number\" class=\"headerlink\" title=\"1.2数字类型(number)\"></a>1.2数字类型(number)</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> age: <span class=\"built_in\">number</span>=<span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-字符串类型-string\"><a href=\"#1-3-字符串类型-string\" class=\"headerlink\" title=\"1.3 字符串类型(string)\"></a>1.3 字符串类型(string)</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> firstname: <span class=\"built_in\">string</span>=<span class=\"string\">'lzf'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-数组类型-array\"><a href=\"#1-4-数组类型-array\" class=\"headerlink\" title=\"1.4 数组类型(array)\"></a>1.4 数组类型(array)</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr2: <span class=\"built_in\">number</span>[]=[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt;=[<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-元组类型-tuple\"><a href=\"#1-5-元组类型-tuple\" class=\"headerlink\" title=\"1.5 元组类型(tuple)\"></a>1.5 元组类型(tuple)</h3><p>在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zf:[<span class=\"built_in\">string</span>,<span class=\"built_in\">number</span>] = [<span class=\"string\">'zf'</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">zf[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">zf[<span class=\"number\">1</span>].toFixed(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>元组    数组<br>每一项可以是不同的类型    每一项都是同一种类型<br>有预定义的长度    没有长度限制<br>用于表示一个固定的结构    用于表示一个列表</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> animal:[<span class=\"built_in\">string</span>,<span class=\"built_in\">number</span>,<span class=\"built_in\">boolean</span>] = [<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-枚举类型-enum\"><a href=\"#1-6-枚举类型-enum\" class=\"headerlink\" title=\"1.6 枚举类型(enum)\"></a>1.6 枚举类型(enum)</h3><p>事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值<br>比如性别、月份、星期、颜色、单位、学历</p>\n<h4 id=\"1-6-1-普通枚举\"><a href=\"#1-6-1-普通枚举\" class=\"headerlink\" title=\"1.6.1 普通枚举\"></a>1.6.1 普通枚举</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Gender&#123;</span><br><span class=\"line\">    GIRL,</span><br><span class=\"line\">    BOY</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`lzf是<span class=\"subst\">$&#123;Gender.BOY&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`zf<span class=\"subst\">$&#123;Gender.GIRL&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> Week&#123;</span><br><span class=\"line\">    MONDAY=<span class=\"number\">1</span>,</span><br><span class=\"line\">    TUESDAY=<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`今天是星期<span class=\"subst\">$&#123;Week.MONDAY&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-6-2-常数枚举\"><a href=\"#1-6-2-常数枚举\" class=\"headerlink\" title=\"1.6.2 常数枚举\"></a>1.6.2 常数枚举</h4><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。<br>假如包含了计算成员，则会在编译阶段报错</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Colors &#123;</span><br><span class=\"line\">    Red,</span><br><span class=\"line\">    Yellow,</span><br><span class=\"line\">    Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myColors = [Colors.Red, Colors.Yellow, Colors.Blue];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Color &#123;Red, Yellow, Blue = <span class=\"string\">\"blue\"</span>.length&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-任意类型-any\"><a href=\"#1-7-任意类型-any\" class=\"headerlink\" title=\"1.7 任意类型(any)\"></a>1.7 任意类型(any)</h3><p>any就是可以赋值给任意类型<br>第三方库没有提供类型文件时可以使用any<br>类型转换遇到困难时<br>数据结构太复杂难以定义</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> root:<span class=\"built_in\">any</span>=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root.style.color=<span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> root:(HTMLElement|<span class=\"literal\">null</span>)=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root!.style.color=<span class=\"string\">'red'</span>;<span class=\"comment\">//非空断言操作符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-8-null-和-undefined\"><a href=\"#1-8-null-和-undefined\" class=\"headerlink\" title=\"1.8 null 和 undefined\"></a>1.8 null 和 undefined</h3><p>null 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined<br>strictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\">x = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> y: <span class=\"built_in\">number</span> | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"number\">1</span>;</span><br><span class=\"line\">y = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-void-类型\"><a href=\"#1-9-void-类型\" class=\"headerlink\" title=\"1.9 void 类型\"></a>1.9 void 类型</h3><p>void 表示没有任何类型<br>当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeting</span>(<span class=\"params\">name:<span class=\"built_in\">string</span></span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">    <span class=\"comment\">//当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//严格模式(strictNullChecks:true)下只能返回undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//return null;</span></span><br><span class=\"line\">    <span class=\"comment\">//return undefined;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-10-never类型\"><a href=\"#1-10-never类型\" class=\"headerlink\" title=\"1.10 never类型\"></a>1.10 never类型</h3><p>never是其它类型(null undefined)的子类型，代表不会出现的值<br>作为不会返回（ return ）的函数的返回值类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = error(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 由类型推论得到返回值为 never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = fail();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-1-strictNullChecks\"><a href=\"#1-10-1-strictNullChecks\" class=\"headerlink\" title=\"1.10.1 strictNullChecks\"></a>1.10.1 strictNullChecks</h4><p>在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 –strictNullChecks 这一种检查模式<br>由于引入了 –strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Compiled with --strictNullChecks</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">x: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: number 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: string 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: never 类型</span></span><br><span class=\"line\">    <span class=\"comment\">// --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-2-never-和-void-的区别、\"><a href=\"#1-10-2-never-和-void-的区别、\" class=\"headerlink\" title=\"1.10.2 never 和 void 的区别、\"></a>1.10.2 never 和 void 的区别、</h4><p>void 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。<br>拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。<br>1.11 类型推论<br>是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性<br>定义时未赋值就会推论成any类型<br>如果定义的时候就赋值就能利用到类型推论</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username2;</span><br><span class=\"line\">username2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">username2 = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">username2 = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-12-包装对象（Wrapper-Object）\"><a href=\"#1-12-包装对象（Wrapper-Object）\" class=\"headerlink\" title=\"1.12 包装对象（Wrapper Object）\"></a>1.12 包装对象（Wrapper Object）</h3><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>所有的原始数据类型都没有属性（property）<br>原始数据类型<br>布尔值<br>数值<br>字符串</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">Symbol</span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toUpperCase());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'zf'</span>)).toUpperCase());</span><br><span class=\"line\">当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换</span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: <span class=\"built_in\">boolean</span> = <span class=\"literal\">true</span>; <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: <span class=\"built_in\">boolean</span> = <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>) <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: <span class=\"built_in\">boolean</span> = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>); <span class=\"comment\">// 编译失败   期望的 isOK 是一个原始数据类型</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-13-联合类型\"><a href=\"#1-13-联合类型\" class=\"headerlink\" title=\"1.13 联合类型\"></a>1.13 联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种<br>未赋值时联合类型上只能访问两个类型共有的属性和方法</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toString());</span><br><span class=\"line\">name = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\">name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-14-类型断言\"><a href=\"#1-14-类型断言\" class=\"headerlink\" title=\"1.14 类型断言\"></a>1.14 类型断言</h3><p>类型断言可以将一个联合类型的变量，指定为一个更加具体的类型<br>不能将联合类型断言为不存在的类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>).toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> <span class=\"built_in\">boolean</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-15-字面量类型\"><a href=\"#1-15-字面量类型\" class=\"headerlink\" title=\"1.15 字面量类型\"></a>1.15 字面量类型</h3><p>可以把字符串、数字、布尔值字面量组成一个联合类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ZType = <span class=\"number\">1</span> | <span class=\"string\">'One'</span>|<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t1:ZType = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t2:ZType = <span class=\"string\">'One'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t3:ZType = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-16-字符串字面量-vs-联合类型\"><a href=\"#1-16-字符串字面量-vs-联合类型\" class=\"headerlink\" title=\"1.16 字符串字面量 vs 联合类型\"></a>1.16 字符串字面量 vs 联合类型</h3><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种<br>字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"1-布尔类型-boolean\"><a href=\"#1-布尔类型-boolean\" class=\"headerlink\" title=\"1.布尔类型(boolean)\"></a>1.布尔类型(boolean)</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> isLzf: <span class=\"built_in\">boolean</span>=<span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2数字类型-number\"><a href=\"#1-2数字类型-number\" class=\"headerlink\" title=\"1.2数字类型(number)\"></a>1.2数字类型(number)</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> age: <span class=\"built_in\">number</span>=<span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-字符串类型-string\"><a href=\"#1-3-字符串类型-string\" class=\"headerlink\" title=\"1.3 字符串类型(string)\"></a>1.3 字符串类型(string)</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> firstname: <span class=\"built_in\">string</span>=<span class=\"string\">'lzf'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-数组类型-array\"><a href=\"#1-4-数组类型-array\" class=\"headerlink\" title=\"1.4 数组类型(array)\"></a>1.4 数组类型(array)</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr2: <span class=\"built_in\">number</span>[]=[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt;=[<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-元组类型-tuple\"><a href=\"#1-5-元组类型-tuple\" class=\"headerlink\" title=\"1.5 元组类型(tuple)\"></a>1.5 元组类型(tuple)</h3><p>在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知数量和类型的数组</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zf:[<span class=\"built_in\">string</span>,<span class=\"built_in\">number</span>] = [<span class=\"string\">'zf'</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">zf[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">zf[<span class=\"number\">1</span>].toFixed(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>元组    数组<br>每一项可以是不同的类型    每一项都是同一种类型<br>有预定义的长度    没有长度限制<br>用于表示一个固定的结构    用于表示一个列表</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> animal:[<span class=\"built_in\">string</span>,<span class=\"built_in\">number</span>,<span class=\"built_in\">boolean</span>] = [<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-枚举类型-enum\"><a href=\"#1-6-枚举类型-enum\" class=\"headerlink\" title=\"1.6 枚举类型(enum)\"></a>1.6 枚举类型(enum)</h3><p>事先考虑某一个变量的所有的可能的值，尽量用自然语言中的单词表示它的每一个值<br>比如性别、月份、星期、颜色、单位、学历</p>\n<h4 id=\"1-6-1-普通枚举\"><a href=\"#1-6-1-普通枚举\" class=\"headerlink\" title=\"1.6.1 普通枚举\"></a>1.6.1 普通枚举</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Gender&#123;</span><br><span class=\"line\">    GIRL,</span><br><span class=\"line\">    BOY</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`lzf是<span class=\"subst\">$&#123;Gender.BOY&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`zf<span class=\"subst\">$&#123;Gender.GIRL&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> Week&#123;</span><br><span class=\"line\">    MONDAY=<span class=\"number\">1</span>,</span><br><span class=\"line\">    TUESDAY=<span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`今天是星期<span class=\"subst\">$&#123;Week.MONDAY&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-6-2-常数枚举\"><a href=\"#1-6-2-常数枚举\" class=\"headerlink\" title=\"1.6.2 常数枚举\"></a>1.6.2 常数枚举</h4><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。<br>假如包含了计算成员，则会在编译阶段报错</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Colors &#123;</span><br><span class=\"line\">    Red,</span><br><span class=\"line\">    Yellow,</span><br><span class=\"line\">    Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myColors = [Colors.Red, Colors.Yellow, Colors.Blue];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Color &#123;Red, Yellow, Blue = <span class=\"string\">\"blue\"</span>.length&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-任意类型-any\"><a href=\"#1-7-任意类型-any\" class=\"headerlink\" title=\"1.7 任意类型(any)\"></a>1.7 任意类型(any)</h3><p>any就是可以赋值给任意类型<br>第三方库没有提供类型文件时可以使用any<br>类型转换遇到困难时<br>数据结构太复杂难以定义</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> root:<span class=\"built_in\">any</span>=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root.style.color=<span class=\"string\">'red'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> root:(HTMLElement|<span class=\"literal\">null</span>)=<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\">root!.style.color=<span class=\"string\">'red'</span>;<span class=\"comment\">//非空断言操作符</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-8-null-和-undefined\"><a href=\"#1-8-null-和-undefined\" class=\"headerlink\" title=\"1.8 null 和 undefined\"></a>1.8 null 和 undefined</h3><p>null 和 undefined 是其它类型的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined<br>strictNullChecks 参数用于新的严格空检查模式,在严格空检查模式下， null 和 undefined 值都不属于任何一个类型，它们只能赋值给自己这种类型或者 any</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\">x = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">x = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> y: <span class=\"built_in\">number</span> | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"number\">1</span>;</span><br><span class=\"line\">y = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">y = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-9-void-类型\"><a href=\"#1-9-void-类型\" class=\"headerlink\" title=\"1.9 void 类型\"></a>1.9 void 类型</h3><p>void 表示没有任何类型<br>当一个函数没有返回值时，TS 会认为它的返回值是 void 类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeting</span>(<span class=\"params\">name:<span class=\"built_in\">string</span></span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">    <span class=\"comment\">//当我们声明一个变量类型是 void 的时候，它的非严格模式(strictNullChecks:false)下仅可以被赋值为 null 和 undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//严格模式(strictNullChecks:true)下只能返回undefined</span></span><br><span class=\"line\">    <span class=\"comment\">//return null;</span></span><br><span class=\"line\">    <span class=\"comment\">//return undefined;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-10-never类型\"><a href=\"#1-10-never类型\" class=\"headerlink\" title=\"1.10 never类型\"></a>1.10 never类型</h3><p>never是其它类型(null undefined)的子类型，代表不会出现的值<br>作为不会返回（ return ）的函数的返回值类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = error(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 由类型推论得到返回值为 never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = fail();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数 必须存在 无法达到（ unreachable ） 的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-1-strictNullChecks\"><a href=\"#1-10-1-strictNullChecks\" class=\"headerlink\" title=\"1.10.1 strictNullChecks\"></a>1.10.1 strictNullChecks</h4><p>在 TS 中， null 和 undefined 是任何类型的有效值，所以无法正确地检测它们是否被错误地使用。于是 TS 引入了 –strictNullChecks 这一种检查模式<br>由于引入了 –strictNullChecks ，在这一模式下，null 和 undefined 能被检测到。所以 TS 需要一种新的底部类型（ bottom type ）。所以就引入了 never。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Compiled with --strictNullChecks</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">x: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: number 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: string 类型</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// x: never 类型</span></span><br><span class=\"line\">    <span class=\"comment\">// --strictNullChecks 模式下，这里的代码将不会被执行，x 无法被观察</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-10-2-never-和-void-的区别、\"><a href=\"#1-10-2-never-和-void-的区别、\" class=\"headerlink\" title=\"1.10.2 never 和 void 的区别、\"></a>1.10.2 never 和 void 的区别、</h4><p>void 可以被赋值为 null 和 undefined的类型。 never 则是一个不包含值的类型。<br>拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。<br>1.11 类型推论<br>是指编程语言中能够自动推导出值的类型的能力，它是一些强静态类型语言中出现的特性<br>定义时未赋值就会推论成any类型<br>如果定义的时候就赋值就能利用到类型推论</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> username2;</span><br><span class=\"line\">username2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">username2 = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">username2 = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-12-包装对象（Wrapper-Object）\"><a href=\"#1-12-包装对象（Wrapper-Object）\" class=\"headerlink\" title=\"1.12 包装对象（Wrapper Object）\"></a>1.12 包装对象（Wrapper Object）</h3><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>所有的原始数据类型都没有属性（property）<br>原始数据类型<br>布尔值<br>数值<br>字符串</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">Symbol</span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toUpperCase());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'zf'</span>)).toUpperCase());</span><br><span class=\"line\">当调用基本数据类型方法的时候，JavaScript 会在原始数据类型和对象类型之间做一个迅速的强制性切换</span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: <span class=\"built_in\">boolean</span> = <span class=\"literal\">true</span>; <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: <span class=\"built_in\">boolean</span> = <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>) <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isOK: <span class=\"built_in\">boolean</span> = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>); <span class=\"comment\">// 编译失败   期望的 isOK 是一个原始数据类型</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-13-联合类型\"><a href=\"#1-13-联合类型\" class=\"headerlink\" title=\"1.13 联合类型\"></a>1.13 联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种<br>未赋值时联合类型上只能访问两个类型共有的属性和方法</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toString());</span><br><span class=\"line\">name = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\">name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name.length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-14-类型断言\"><a href=\"#1-14-类型断言\" class=\"headerlink\" title=\"1.14 类型断言\"></a>1.14 类型断言</h3><p>类型断言可以将一个联合类型的变量，指定为一个更加具体的类型<br>不能将联合类型断言为不存在的类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>).toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((name <span class=\"keyword\">as</span> <span class=\"built_in\">boolean</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-15-字面量类型\"><a href=\"#1-15-字面量类型\" class=\"headerlink\" title=\"1.15 字面量类型\"></a>1.15 字面量类型</h3><p>可以把字符串、数字、布尔值字面量组成一个联合类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ZType = <span class=\"number\">1</span> | <span class=\"string\">'One'</span>|<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t1:ZType = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t2:ZType = <span class=\"string\">'One'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t3:ZType = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-16-字符串字面量-vs-联合类型\"><a href=\"#1-16-字符串字面量-vs-联合类型\" class=\"headerlink\" title=\"1.16 字符串字面量 vs 联合类型\"></a>1.16 字符串字面量 vs 联合类型</h3><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个, 联合类型（Union Types）表示取值可以为多种类型中的一种<br>字符串字面量 限定了使用该字面量的地方仅接受特定的值,联合类型 对于值并没有限定，仅仅限定值的类型需要保持一致</p>\n"},{"title":"TypeScript函数","date":"2019-05-17T07:19:26.000Z","_content":"## 1. 函数\n\n### 1.1 函数的定义\n\n可以指定参数的类型和返回值的类型\n\n```typescript\nfunction hello(name:string):void {\n    console.log('hello',name);\n}\nhello('zf');\n```\n\n### 1.2 函数表达式\n\n```typescript\n定义函数类型\ntype GetUsernameFunction = (x:string,y:string)=>string;\nlet getUsername:GetUsernameFunction = function(firstName,lastName){\n  return firstName + lastName;\n}\n```\n\n### 1.3 没有返回值\n\n```typescript\nlet hello2 = function (name:string):void {\n    console.log('hello2',name);\n    return undefined;\n}\nhello2('zf');\n```\n\n### 1.4 可选参数\n\n```typescript\n在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数\n\nfunction print(name:string,age?:number):void {\n    console.log(name,age);\n}\nprint('zf');\n```\n\n### 1.5 默认参数\n\n```typescript\nfunction ajax(url:string,method:string='GET') {\n    console.log(url,method);\n}\najax('/users');\n```\n\n### 1.6 剩余参数\n\n```typescript\nfunction sum(...numbers:number[]) {\n    return numbers.reduce((val,item)=>val+=item,0);\n}\nconsole.log(sum(1,2,3));\n```\n\n### 1.7 函数重载\n\n在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样\n在TypeScript中，表现为给同一个函数提供多个函数类型定义\n\n```typescript\nlet obj: any={};\nfunction attr(val: string): void;\nfunction attr(val: number): void;\nfunction attr(val:any):void {\n    if (typeof val === 'string') {\n        obj.name=val;\n    } else {\n        obj.age=val;\n    }\n}\nattr('zf');\nattr(9);\nattr(true);\nconsole.log(obj);\n```\n","source":"_posts/page/typescript函数.md","raw":"---\ntitle: TypeScript函数\ntags:\n  - typescript\ncategories: web前端\ndate: 2019-05-17 15:19:26\n---\n## 1. 函数\n\n### 1.1 函数的定义\n\n可以指定参数的类型和返回值的类型\n\n```typescript\nfunction hello(name:string):void {\n    console.log('hello',name);\n}\nhello('zf');\n```\n\n### 1.2 函数表达式\n\n```typescript\n定义函数类型\ntype GetUsernameFunction = (x:string,y:string)=>string;\nlet getUsername:GetUsernameFunction = function(firstName,lastName){\n  return firstName + lastName;\n}\n```\n\n### 1.3 没有返回值\n\n```typescript\nlet hello2 = function (name:string):void {\n    console.log('hello2',name);\n    return undefined;\n}\nhello2('zf');\n```\n\n### 1.4 可选参数\n\n```typescript\n在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数\n\nfunction print(name:string,age?:number):void {\n    console.log(name,age);\n}\nprint('zf');\n```\n\n### 1.5 默认参数\n\n```typescript\nfunction ajax(url:string,method:string='GET') {\n    console.log(url,method);\n}\najax('/users');\n```\n\n### 1.6 剩余参数\n\n```typescript\nfunction sum(...numbers:number[]) {\n    return numbers.reduce((val,item)=>val+=item,0);\n}\nconsole.log(sum(1,2,3));\n```\n\n### 1.7 函数重载\n\n在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样\n在TypeScript中，表现为给同一个函数提供多个函数类型定义\n\n```typescript\nlet obj: any={};\nfunction attr(val: string): void;\nfunction attr(val: number): void;\nfunction attr(val:any):void {\n    if (typeof val === 'string') {\n        obj.name=val;\n    } else {\n        obj.age=val;\n    }\n}\nattr('zf');\nattr(9);\nattr(true);\nconsole.log(obj);\n```\n","slug":"page/typescript函数","published":1,"updated":"2020-08-14T10:20:18.000Z","_id":"ckbw73cki00071gsxe6bkg5j8","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-函数\"><a href=\"#1-函数\" class=\"headerlink\" title=\"1. 函数\"></a>1. 函数</h2><h3 id=\"1-1-函数的定义\"><a href=\"#1-1-函数的定义\" class=\"headerlink\" title=\"1.1 函数的定义\"></a>1.1 函数的定义</h3><p>可以指定参数的类型和返回值的类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">name:<span class=\"built_in\">string</span></span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-函数表达式\"><a href=\"#1-2-函数表达式\" class=\"headerlink\" title=\"1.2 函数表达式\"></a>1.2 函数表达式</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">定义函数类型</span><br><span class=\"line\"><span class=\"keyword\">type</span> GetUsernameFunction = <span class=\"function\">(<span class=\"params\">x:<span class=\"built_in\">string</span>,y:<span class=\"built_in\">string</span></span>)=&gt;</span><span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> getUsername:GetUsernameFunction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">firstName,lastName</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-没有返回值\"><a href=\"#1-3-没有返回值\" class=\"headerlink\" title=\"1.3 没有返回值\"></a>1.3 没有返回值</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name:<span class=\"built_in\">string</span></span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello2'</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello2(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-可选参数\"><a href=\"#1-4-可选参数\" class=\"headerlink\" title=\"1.4 可选参数\"></a>1.4 可选参数</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age?:<span class=\"built_in\">number</span></span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name,age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-默认参数\"><a href=\"#1-5-默认参数\" class=\"headerlink\" title=\"1.5 默认参数\"></a>1.5 默认参数</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url:<span class=\"built_in\">string</span>,method:<span class=\"built_in\">string</span>='GET'</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(url,method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ajax(<span class=\"string\">'/users'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-剩余参数\"><a href=\"#1-6-剩余参数\" class=\"headerlink\" title=\"1.6 剩余参数\"></a>1.6 剩余参数</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">...numbers:<span class=\"built_in\">number</span>[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numbers.reduce(<span class=\"function\">(<span class=\"params\">val,item</span>)=&gt;</span>val+=item,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-函数重载\"><a href=\"#1-7-函数重载\" class=\"headerlink\" title=\"1.7 函数重载\"></a>1.7 函数重载</h3><p>在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样<br>在TypeScript中，表现为给同一个函数提供多个函数类型定义</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj: <span class=\"built_in\">any</span>=&#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: <span class=\"built_in\">string</span></span>): <span class=\"title\">void</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: <span class=\"built_in\">number</span></span>): <span class=\"title\">void</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val:<span class=\"built_in\">any</span></span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        obj.name=val;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        obj.age=val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">attr(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">attr(<span class=\"number\">9</span>);</span><br><span class=\"line\">attr(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-函数\"><a href=\"#1-函数\" class=\"headerlink\" title=\"1. 函数\"></a>1. 函数</h2><h3 id=\"1-1-函数的定义\"><a href=\"#1-1-函数的定义\" class=\"headerlink\" title=\"1.1 函数的定义\"></a>1.1 函数的定义</h3><p>可以指定参数的类型和返回值的类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">name:<span class=\"built_in\">string</span></span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>,name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-函数表达式\"><a href=\"#1-2-函数表达式\" class=\"headerlink\" title=\"1.2 函数表达式\"></a>1.2 函数表达式</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">定义函数类型</span><br><span class=\"line\"><span class=\"keyword\">type</span> GetUsernameFunction = <span class=\"function\">(<span class=\"params\">x:<span class=\"built_in\">string</span>,y:<span class=\"built_in\">string</span></span>)=&gt;</span><span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> getUsername:GetUsernameFunction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">firstName,lastName</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-没有返回值\"><a href=\"#1-3-没有返回值\" class=\"headerlink\" title=\"1.3 没有返回值\"></a>1.3 没有返回值</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name:<span class=\"built_in\">string</span></span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello2'</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello2(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-可选参数\"><a href=\"#1-4-可选参数\" class=\"headerlink\" title=\"1.4 可选参数\"></a>1.4 可选参数</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">在TS中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是最后一个参数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age?:<span class=\"built_in\">number</span></span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name,age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(<span class=\"string\">'zf'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-默认参数\"><a href=\"#1-5-默认参数\" class=\"headerlink\" title=\"1.5 默认参数\"></a>1.5 默认参数</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url:<span class=\"built_in\">string</span>,method:<span class=\"built_in\">string</span>='GET'</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(url,method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ajax(<span class=\"string\">'/users'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-剩余参数\"><a href=\"#1-6-剩余参数\" class=\"headerlink\" title=\"1.6 剩余参数\"></a>1.6 剩余参数</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">...numbers:<span class=\"built_in\">number</span>[]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numbers.reduce(<span class=\"function\">(<span class=\"params\">val,item</span>)=&gt;</span>val+=item,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-7-函数重载\"><a href=\"#1-7-函数重载\" class=\"headerlink\" title=\"1.7 函数重载\"></a>1.7 函数重载</h3><p>在Java中的重载，指的是两个或者两个以上的同名函数，参数不一样<br>在TypeScript中，表现为给同一个函数提供多个函数类型定义</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj: <span class=\"built_in\">any</span>=&#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: <span class=\"built_in\">string</span></span>): <span class=\"title\">void</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val: <span class=\"built_in\">number</span></span>): <span class=\"title\">void</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">attr</span>(<span class=\"params\">val:<span class=\"built_in\">any</span></span>):<span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        obj.name=val;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        obj.age=val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">attr(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">attr(<span class=\"number\">9</span>);</span><br><span class=\"line\">attr(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br></pre></td></tr></table></figure>\n"},{"title":"typescript类","author":"lz_allen","date":"2020-05-22T00:16:28.000Z","_content":"\n## 类\n\n### 如何定义类\n\n\"strictPropertyInitialization\": true / 启用类属性初始化的严格检查/\nname!:string\n\n```typescript\nclass Person{\n    name:string;\n    getName():void{\n        console.log(this.name);\n    }\n}\nlet p1 = new Person();\np1.name = 'zf';\np1.getName();\n```\n\n### 存取器\n\n- 在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为\n- 构造函数\n- 主要用于初始化类的成员变量属性\n- 类的对象创建时自动调用执行\n- 没有返回值\n\n```typescript\nclass User {\n    myname:string;\n    constructor(myname: string) {\n        this.myname = myname;\n    }\n    get name() {\n        return this.myname;\n    }\n    set name(value) {\n        this.myname = value;\n    }\n}\n\nlet user = new User('zf');\nuser.name = 'jiagou'; \nconsole.log(user.name); \n\"use strict\";\nvar User = /** @class */ (function () {\n    function User(myname) {\n        this.myname = myname;\n    }\n    Object.defineProperty(User.prototype, \"name\", {\n        get: function () {\n            return this.myname;\n        },\n        set: function (value) {\n            this.myname = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return User;\n}());\nvar user = new User('zf');\nuser.name = 'jiagou';\nconsole.log(user.name);\n```\n\n### 参数属性\n\n```typescript\nclass User {\n    constructor(public myname: string) {}\n    get name() {\n        return this.myname;\n    }\n    set name(value) {\n        this.myname = value;\n    }\n}\n\nlet user = new User('zf');\nconsole.log(user.name); \nuser.name = 'jiagou'; \nconsole.log(user.name);\n```\n\n### readonly\n\n- readonly修饰的变量只能在构造函数中初始化\n- 在 TypeScript 中，const 是常量标志符，其值不能被重新分配\n- TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly\n- readonly 实际上只是在编译阶段进行代码检查。而 const 则会在运行时检查（在支持 const 语法的 JavaScript 运行时环境中）\n\n```typescript\nclass Animal {\n    public readonly name: string\n    constructor(name:string) {\n        this.name = name;\n    }\n    changeName(name:string){\n        this.name = name;\n    }\n}\n\nlet a = new Animal('zf');\na.changeName('jiagou');\n```\n\n### 继承\n\n- 子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性\\\n- 将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑\n- super可以调用父类上的方法和属性\n\n```typescript\nclass Person {\n    name: string;//定义实例的属性，默认省略public修饰符\n    age: number;\n    constructor(name:string,age:number) {//构造函数\n        this.name=name;\n        this.age=age;\n    }\n    getName():string {\n        return this.name;\n    }\n    setName(name:string): void{\n        this.name=name;\n    }\n}\nclass Student extends Person{\n    no: number;\n    constructor(name:string,age:number,no:number) {\n        super(name,age);\n        this.no=no;\n    }\n    getNo():number {\n        return this.no;\n    }\n}\nlet s1=new Student('zf',10,1);\nconsole.log(s1);\n\n```\n\n### 类里面的修饰符\n\n```typescript\nclass Father {\n    public name: string;  //类里面 子类 其它任何地方外边都可以访问\n    protected age: number; //类里面 子类 都可以访问,其它任何地方不能访问\n    private money: number; //类里面可以访问， 子类和其它任何地方都不可以访问\n    constructor(name:string,age:number,money:number) {//构造函数\n        this.name=name;\n        this.age=age;\n        this.money=money;\n    }\n    getName():string {\n        return this.name;\n    }\n    setName(name:string): void{\n        this.name=name;\n    }\n}\nclass Child extends Father{\n    constructor(name:string,age:number,money:number) {\n        super(name,age,money);\n    }\n    desc() {\n        console.log(`${this.name} ${this.age} ${this.money}`);\n    }\n}\n\nlet child = new Child('zf',10,1000);\nconsole.log(child.name);\nconsole.log(child.age);\nconsole.log(child.money);\n```\n\n### 静态属性 静态方法\n\n```typescript\nclass Father {\n    static className='Father';\n    static getClassName() {\n        return Father.className;\n    }\n    public name: string;\n    constructor(name:string) {//构造函数\n        this.name=name;\n    }\n\n}\nconsole.log(Father.className);\nconsole.log(Father.getClassName());\n```\n\n### 装饰器\n\n- 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为\n- 常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器\n- 装饰器的写法分为普通装饰器和装饰器工厂\n\n#### 类装饰器\n\n类装饰器在类声明之前声明，用来监视、修改或替换类定义\n\n```typescript\nnamespace a {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(target: any) {\n        target.prototype.name = 'zf';\n        target.prototype.eat = function () {\n            console.log('eat');\n        }\n    }\n    @enhancer\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n\nnamespace b {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(name: string) {\n        return function enhancer(target: any) {\n            target.prototype.name = name;\n            target.prototype.eat = function () {\n                console.log('eat');\n            }\n        }\n    }\n\n    @enhancer('zf')\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n\nnamespace c {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(target: any) {\n        return class {\n            name: string = 'jiagou'\n            eat() {\n                console.log('吃饭饭');\n            }\n        }\n    }\n    @enhancer\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n```\n\n#### 属性装饰器\n\n- 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数\n- 属性装饰器用来装饰属性\n- 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n- 第二个参数是属性的名称\n- 方法装饰器用来装饰方法\n- 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n- 第二个参数是方法的名称\n- 第三个参数是方法描述符\n\n```typescript\nnamespace d {\n    function upperCase(target: any, propertyKey: string) {\n        let value = target[propertyKey];\n        const getter = function () {\n            return value;\n        }\n        // 用来替换的setter\n        const setter = function (newVal: string) {\n            value = newVal.toUpperCase()\n        };\n        // 替换属性，先删除原先的属性，再重新定义属性\n        if (delete target[propertyKey]) {\n            Object.defineProperty(target, propertyKey, {\n                get: getter,\n                set: setter,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    function noEnumerable(target: any, property: string, descriptor: PropertyDescriptor) {\n        console.log('target.getName', target.getName);\n        console.log('target.getAge', target.getAge);\n        descriptor.enumerable = true;\n    }\n    function toNumber(target: any, methodName: string, descriptor: PropertyDescriptor) {\n        let oldMethod = descriptor.value;\n        descriptor.value = function (...args: any[]) {\n            args = args.map(item => parseFloat(item));\n            return oldMethod.apply(this, args);\n        }\n    }\n    class Person {\n        @upperCase\n        name: string = 'zf'\n        public static age: number = 10\n        constructor() { }\n        @noEnumerable\n        getName() {\n            console.log(this.name);\n        }\n        @toNumber\n        sum(...args: any[]) {\n            return args.reduce((accu: number, item: number) => accu + item, 0);\n        }\n    }\n    let p: Person = new Person();\n    for (let attr in p) {\n        console.log('attr=', attr);\n    }\n    p.name = 'jiagou';\n    p.getName();\n    console.log(p.sum(\"1\", \"2\", \"3\"));\n}\n```\n\n#### 参数装饰器\n\n- 会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据\n- 第1个参数对于静态成员是类的构造函数，对于实例成员是类的原型对象\n- 第2个参数的名称\n- 第3个参数在函数列表中的索引\n\n```typescript\nnamespace d {\n    interface Person {\n        age: number;\n    }\n    function addAge(target: any, methodName: string, paramsIndex: number) {\n        console.log(target);\n        console.log(methodName);\n        console.log(paramsIndex);\n        target.age = 10;\n    }\n    class Person {\n        login(username: string, @addAge password: string) {\n            console.log(this.age, username, password);\n        }\n    }\n    let p = new Person();\n    p.login('zf', '123456')\n}\n```\n\n### 装饰器执行顺序\n\n- 有多个参数装饰器时：从最后一个参数依次向前执行\n- 方法和方法参数中参数装饰器先执行。\n- 类装饰器总是最后执行\n- 方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行\n\n```typescript\nnamespace e {\n    function Class1Decorator() {\n        return function (target: any) {\n            console.log(\"类1装饰器\");\n        }\n    }\n    function Class2Decorator() {\n        return function (target: any) {\n            console.log(\"类2装饰器\");\n        }\n    }\n    function MethodDecorator() {\n        return function (target: any, methodName: string, descriptor: PropertyDescriptor) {\n            console.log(\"方法装饰器\");\n        }\n    }\n    function Param1Decorator() {\n        return function (target: any, methodName: string, paramIndex: number) {\n            console.log(\"参数1装饰器\");\n        }\n    }\n    function Param2Decorator() {\n        return function (target: any, methodName: string, paramIndex: number) {\n            console.log(\"参数2装饰器\");\n        }\n    }\n    function PropertyDecorator(name: string) {\n        return function (target: any, propertyName: string) {\n            console.log(name + \"属性装饰器\");\n        }\n    }\n\n    @Class1Decorator()\n    @Class2Decorator()\n    class Person {\n        @PropertyDecorator('name')\n        name: string = 'zf';\n        @PropertyDecorator('age')\n        age: number = 10;\n        @MethodDecorator()\n        greet(@Param1Decorator() p1: string, @Param2Decorator() p2: string) { }\n    }\n}\n```\n\n/**\nname属性装饰器\nage属性装饰器\n参数2装饰器\n参数1装饰器\n方法装饰器\n类2装饰器\n类1装饰器\n */\n\n### 抽象类\n\n- 抽象描述一种抽象的概念，无法被实例化，只能被继承\n- 无法创建抽象类的实例\\\n- 抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现，而且必须实现\n\n```typescript\nabstract class Animal {\n    name!:string;\n    abstract speak():void;\n}\nclass Cat extends Animal{\n    speak(){\n        console.log('喵喵喵');\n    }\n}\nlet animal = new Animal();//Cannot create an instance of an abstract class\nanimal.speak();\nlet cat = new Cat();\ncat.speak();\n```\n\n- 访问控制修饰符 private protected public\n- 只读属性 readonly\n- 静态属性 static\n- 抽象类、抽象方法 abstract\n  \n#### 抽象类 vs 接口\n\n- 不同类之间公有的属性或方法，可以抽象成一个接口（Interfaces）\n- 而抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n- 抽象类本质是一个无法被实例化的类，其中能够实现方法和初始化属性，而接口仅能够用于描述,既不提供方法的实现，也不为属性进行初始化\n- 一个类可以继承一个类或抽象类，但可以实现（implements）多个接口\n- 抽象类也可以实现接口\n\n```typescript\nabstract class Animal{\n    name:string;\n    constructor(name:string){\n      this.name = name;\n    }\n    abstract speak():void;\n  }\ninterface Flying{\n      fly():void\n}\nclass Duck extends Animal implements Flying{\n      speak(){\n          console.log('汪汪汪');\n      }\n      fly(){\n          console.log('我会飞');\n      }\n}\nlet duck = new Duck('zf');\nduck.speak();\nduck.fly();\n```\n\n#### 抽象方法\n\n- 抽象类和方法不包含具体实现，必须在子类中实现\n- 抽象方法只能出现在抽象类中\n- 子类可以对抽象类进行不同的实现\n\n```typescript\nabstract class Animal{\n    abstract speak():void;\n}\nclass Dog extends  Animal{\n    speak(){\n        console.log('小狗汪汪汪');\n    }\n}\nclass Cat extends  Animal{\n    speak(){\n        console.log('小猫喵喵喵');\n    }\n}\nlet dog=new Dog();\nlet cat=new Cat();\ndog.speak();\ncat.speak();\n```\n\n### 重写(override) vs 重载(overload)\n\n- 重写是指子类重写继承自父类中的方法\n- 重载是指为同一个函数提供多个类型定义\n\n```typescript\nclass Animal{\n    speak(word:string):string{\n        return '动作叫:'+word;\n    }\n}\nclass Cat extends Animal{\n    speak(word:string):string{\n        return '猫叫:'+word;\n    }\n}\nlet cat = new Cat();\nconsole.log(cat.speak('hello'));\n//--------------------------------------------\nfunction double(val:number):number\nfunction double(val:string):string\nfunction double(val:any):any{\n  if(typeof val == 'number'){\n    return val *2;\n  }\n  return val + val;\n}\n\nlet r = double(1);\nconsole.log(r);\n```\n\n### 继承 vs 多态\n\n- 继承(Inheritance)子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n- 多态(Polymorphism)由继承而产生了相关的不同的类，对同一个方法可以有不同的行为\n  \n```typescript\nclass Animal{\n    speak(word:string):string{\n        return 'Animal: '+word;\n    }\n}\nclass Cat extends Animal{\n    speak(word:string):string{\n        return 'Cat:'+word;\n    }\n}\nclass Dog extends Animal{\n    speak(word:string):string{\n        return 'Dog:'+word;\n    }\n}\nlet cat = new Cat();\nconsole.log(cat.speak('hello'));\nlet dog = new Dog();\nconsole.log(dog.speak('hello'));\n```\n","source":"_posts/page/typescript类.md","raw":"---\ntitle: typescript类\ncategories: web前端\nauthor: lz_allen\ntags:\n  - typescript\ndate: 2020-05-22 08:16:28\n---\n\n## 类\n\n### 如何定义类\n\n\"strictPropertyInitialization\": true / 启用类属性初始化的严格检查/\nname!:string\n\n```typescript\nclass Person{\n    name:string;\n    getName():void{\n        console.log(this.name);\n    }\n}\nlet p1 = new Person();\np1.name = 'zf';\np1.getName();\n```\n\n### 存取器\n\n- 在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为\n- 构造函数\n- 主要用于初始化类的成员变量属性\n- 类的对象创建时自动调用执行\n- 没有返回值\n\n```typescript\nclass User {\n    myname:string;\n    constructor(myname: string) {\n        this.myname = myname;\n    }\n    get name() {\n        return this.myname;\n    }\n    set name(value) {\n        this.myname = value;\n    }\n}\n\nlet user = new User('zf');\nuser.name = 'jiagou'; \nconsole.log(user.name); \n\"use strict\";\nvar User = /** @class */ (function () {\n    function User(myname) {\n        this.myname = myname;\n    }\n    Object.defineProperty(User.prototype, \"name\", {\n        get: function () {\n            return this.myname;\n        },\n        set: function (value) {\n            this.myname = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return User;\n}());\nvar user = new User('zf');\nuser.name = 'jiagou';\nconsole.log(user.name);\n```\n\n### 参数属性\n\n```typescript\nclass User {\n    constructor(public myname: string) {}\n    get name() {\n        return this.myname;\n    }\n    set name(value) {\n        this.myname = value;\n    }\n}\n\nlet user = new User('zf');\nconsole.log(user.name); \nuser.name = 'jiagou'; \nconsole.log(user.name);\n```\n\n### readonly\n\n- readonly修饰的变量只能在构造函数中初始化\n- 在 TypeScript 中，const 是常量标志符，其值不能被重新分配\n- TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly\n- readonly 实际上只是在编译阶段进行代码检查。而 const 则会在运行时检查（在支持 const 语法的 JavaScript 运行时环境中）\n\n```typescript\nclass Animal {\n    public readonly name: string\n    constructor(name:string) {\n        this.name = name;\n    }\n    changeName(name:string){\n        this.name = name;\n    }\n}\n\nlet a = new Animal('zf');\na.changeName('jiagou');\n```\n\n### 继承\n\n- 子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性\\\n- 将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑\n- super可以调用父类上的方法和属性\n\n```typescript\nclass Person {\n    name: string;//定义实例的属性，默认省略public修饰符\n    age: number;\n    constructor(name:string,age:number) {//构造函数\n        this.name=name;\n        this.age=age;\n    }\n    getName():string {\n        return this.name;\n    }\n    setName(name:string): void{\n        this.name=name;\n    }\n}\nclass Student extends Person{\n    no: number;\n    constructor(name:string,age:number,no:number) {\n        super(name,age);\n        this.no=no;\n    }\n    getNo():number {\n        return this.no;\n    }\n}\nlet s1=new Student('zf',10,1);\nconsole.log(s1);\n\n```\n\n### 类里面的修饰符\n\n```typescript\nclass Father {\n    public name: string;  //类里面 子类 其它任何地方外边都可以访问\n    protected age: number; //类里面 子类 都可以访问,其它任何地方不能访问\n    private money: number; //类里面可以访问， 子类和其它任何地方都不可以访问\n    constructor(name:string,age:number,money:number) {//构造函数\n        this.name=name;\n        this.age=age;\n        this.money=money;\n    }\n    getName():string {\n        return this.name;\n    }\n    setName(name:string): void{\n        this.name=name;\n    }\n}\nclass Child extends Father{\n    constructor(name:string,age:number,money:number) {\n        super(name,age,money);\n    }\n    desc() {\n        console.log(`${this.name} ${this.age} ${this.money}`);\n    }\n}\n\nlet child = new Child('zf',10,1000);\nconsole.log(child.name);\nconsole.log(child.age);\nconsole.log(child.money);\n```\n\n### 静态属性 静态方法\n\n```typescript\nclass Father {\n    static className='Father';\n    static getClassName() {\n        return Father.className;\n    }\n    public name: string;\n    constructor(name:string) {//构造函数\n        this.name=name;\n    }\n\n}\nconsole.log(Father.className);\nconsole.log(Father.getClassName());\n```\n\n### 装饰器\n\n- 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为\n- 常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器\n- 装饰器的写法分为普通装饰器和装饰器工厂\n\n#### 类装饰器\n\n类装饰器在类声明之前声明，用来监视、修改或替换类定义\n\n```typescript\nnamespace a {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(target: any) {\n        target.prototype.name = 'zf';\n        target.prototype.eat = function () {\n            console.log('eat');\n        }\n    }\n    @enhancer\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n\nnamespace b {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(name: string) {\n        return function enhancer(target: any) {\n            target.prototype.name = name;\n            target.prototype.eat = function () {\n                console.log('eat');\n            }\n        }\n    }\n\n    @enhancer('zf')\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n\nnamespace c {\n    interface Person {\n        name: string;\n        eat: any\n    }\n    function enhancer(target: any) {\n        return class {\n            name: string = 'jiagou'\n            eat() {\n                console.log('吃饭饭');\n            }\n        }\n    }\n    @enhancer\n    class Person {\n        constructor() { }\n    }\n    let p: Person = new Person();\n    console.log(p.name);\n    p.eat();\n}\n```\n\n#### 属性装饰器\n\n- 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数\n- 属性装饰器用来装饰属性\n- 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n- 第二个参数是属性的名称\n- 方法装饰器用来装饰方法\n- 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\n- 第二个参数是方法的名称\n- 第三个参数是方法描述符\n\n```typescript\nnamespace d {\n    function upperCase(target: any, propertyKey: string) {\n        let value = target[propertyKey];\n        const getter = function () {\n            return value;\n        }\n        // 用来替换的setter\n        const setter = function (newVal: string) {\n            value = newVal.toUpperCase()\n        };\n        // 替换属性，先删除原先的属性，再重新定义属性\n        if (delete target[propertyKey]) {\n            Object.defineProperty(target, propertyKey, {\n                get: getter,\n                set: setter,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    function noEnumerable(target: any, property: string, descriptor: PropertyDescriptor) {\n        console.log('target.getName', target.getName);\n        console.log('target.getAge', target.getAge);\n        descriptor.enumerable = true;\n    }\n    function toNumber(target: any, methodName: string, descriptor: PropertyDescriptor) {\n        let oldMethod = descriptor.value;\n        descriptor.value = function (...args: any[]) {\n            args = args.map(item => parseFloat(item));\n            return oldMethod.apply(this, args);\n        }\n    }\n    class Person {\n        @upperCase\n        name: string = 'zf'\n        public static age: number = 10\n        constructor() { }\n        @noEnumerable\n        getName() {\n            console.log(this.name);\n        }\n        @toNumber\n        sum(...args: any[]) {\n            return args.reduce((accu: number, item: number) => accu + item, 0);\n        }\n    }\n    let p: Person = new Person();\n    for (let attr in p) {\n        console.log('attr=', attr);\n    }\n    p.name = 'jiagou';\n    p.getName();\n    console.log(p.sum(\"1\", \"2\", \"3\"));\n}\n```\n\n#### 参数装饰器\n\n- 会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据\n- 第1个参数对于静态成员是类的构造函数，对于实例成员是类的原型对象\n- 第2个参数的名称\n- 第3个参数在函数列表中的索引\n\n```typescript\nnamespace d {\n    interface Person {\n        age: number;\n    }\n    function addAge(target: any, methodName: string, paramsIndex: number) {\n        console.log(target);\n        console.log(methodName);\n        console.log(paramsIndex);\n        target.age = 10;\n    }\n    class Person {\n        login(username: string, @addAge password: string) {\n            console.log(this.age, username, password);\n        }\n    }\n    let p = new Person();\n    p.login('zf', '123456')\n}\n```\n\n### 装饰器执行顺序\n\n- 有多个参数装饰器时：从最后一个参数依次向前执行\n- 方法和方法参数中参数装饰器先执行。\n- 类装饰器总是最后执行\n- 方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行\n\n```typescript\nnamespace e {\n    function Class1Decorator() {\n        return function (target: any) {\n            console.log(\"类1装饰器\");\n        }\n    }\n    function Class2Decorator() {\n        return function (target: any) {\n            console.log(\"类2装饰器\");\n        }\n    }\n    function MethodDecorator() {\n        return function (target: any, methodName: string, descriptor: PropertyDescriptor) {\n            console.log(\"方法装饰器\");\n        }\n    }\n    function Param1Decorator() {\n        return function (target: any, methodName: string, paramIndex: number) {\n            console.log(\"参数1装饰器\");\n        }\n    }\n    function Param2Decorator() {\n        return function (target: any, methodName: string, paramIndex: number) {\n            console.log(\"参数2装饰器\");\n        }\n    }\n    function PropertyDecorator(name: string) {\n        return function (target: any, propertyName: string) {\n            console.log(name + \"属性装饰器\");\n        }\n    }\n\n    @Class1Decorator()\n    @Class2Decorator()\n    class Person {\n        @PropertyDecorator('name')\n        name: string = 'zf';\n        @PropertyDecorator('age')\n        age: number = 10;\n        @MethodDecorator()\n        greet(@Param1Decorator() p1: string, @Param2Decorator() p2: string) { }\n    }\n}\n```\n\n/**\nname属性装饰器\nage属性装饰器\n参数2装饰器\n参数1装饰器\n方法装饰器\n类2装饰器\n类1装饰器\n */\n\n### 抽象类\n\n- 抽象描述一种抽象的概念，无法被实例化，只能被继承\n- 无法创建抽象类的实例\\\n- 抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现，而且必须实现\n\n```typescript\nabstract class Animal {\n    name!:string;\n    abstract speak():void;\n}\nclass Cat extends Animal{\n    speak(){\n        console.log('喵喵喵');\n    }\n}\nlet animal = new Animal();//Cannot create an instance of an abstract class\nanimal.speak();\nlet cat = new Cat();\ncat.speak();\n```\n\n- 访问控制修饰符 private protected public\n- 只读属性 readonly\n- 静态属性 static\n- 抽象类、抽象方法 abstract\n  \n#### 抽象类 vs 接口\n\n- 不同类之间公有的属性或方法，可以抽象成一个接口（Interfaces）\n- 而抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n- 抽象类本质是一个无法被实例化的类，其中能够实现方法和初始化属性，而接口仅能够用于描述,既不提供方法的实现，也不为属性进行初始化\n- 一个类可以继承一个类或抽象类，但可以实现（implements）多个接口\n- 抽象类也可以实现接口\n\n```typescript\nabstract class Animal{\n    name:string;\n    constructor(name:string){\n      this.name = name;\n    }\n    abstract speak():void;\n  }\ninterface Flying{\n      fly():void\n}\nclass Duck extends Animal implements Flying{\n      speak(){\n          console.log('汪汪汪');\n      }\n      fly(){\n          console.log('我会飞');\n      }\n}\nlet duck = new Duck('zf');\nduck.speak();\nduck.fly();\n```\n\n#### 抽象方法\n\n- 抽象类和方法不包含具体实现，必须在子类中实现\n- 抽象方法只能出现在抽象类中\n- 子类可以对抽象类进行不同的实现\n\n```typescript\nabstract class Animal{\n    abstract speak():void;\n}\nclass Dog extends  Animal{\n    speak(){\n        console.log('小狗汪汪汪');\n    }\n}\nclass Cat extends  Animal{\n    speak(){\n        console.log('小猫喵喵喵');\n    }\n}\nlet dog=new Dog();\nlet cat=new Cat();\ndog.speak();\ncat.speak();\n```\n\n### 重写(override) vs 重载(overload)\n\n- 重写是指子类重写继承自父类中的方法\n- 重载是指为同一个函数提供多个类型定义\n\n```typescript\nclass Animal{\n    speak(word:string):string{\n        return '动作叫:'+word;\n    }\n}\nclass Cat extends Animal{\n    speak(word:string):string{\n        return '猫叫:'+word;\n    }\n}\nlet cat = new Cat();\nconsole.log(cat.speak('hello'));\n//--------------------------------------------\nfunction double(val:number):number\nfunction double(val:string):string\nfunction double(val:any):any{\n  if(typeof val == 'number'){\n    return val *2;\n  }\n  return val + val;\n}\n\nlet r = double(1);\nconsole.log(r);\n```\n\n### 继承 vs 多态\n\n- 继承(Inheritance)子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n- 多态(Polymorphism)由继承而产生了相关的不同的类，对同一个方法可以有不同的行为\n  \n```typescript\nclass Animal{\n    speak(word:string):string{\n        return 'Animal: '+word;\n    }\n}\nclass Cat extends Animal{\n    speak(word:string):string{\n        return 'Cat:'+word;\n    }\n}\nclass Dog extends Animal{\n    speak(word:string):string{\n        return 'Dog:'+word;\n    }\n}\nlet cat = new Cat();\nconsole.log(cat.speak('hello'));\nlet dog = new Dog();\nconsole.log(dog.speak('hello'));\n```\n","slug":"page/typescript类","published":1,"updated":"2020-08-14T10:20:18.000Z","_id":"ckbw73ckj00081gsx7k2s98b7","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"如何定义类\"><a href=\"#如何定义类\" class=\"headerlink\" title=\"如何定义类\"></a>如何定义类</h3><p>“strictPropertyInitialization”: true / 启用类属性初始化的严格检查/<br>name!:string</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    getName():<span class=\"built_in\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p1.name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">p1.getName();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存取器\"><a href=\"#存取器\" class=\"headerlink\" title=\"存取器\"></a>存取器</h3><ul>\n<li>在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为</li>\n<li>构造函数</li>\n<li>主要用于初始化类的成员变量属性</li>\n<li>类的对象创建时自动调用执行</li>\n<li>没有返回值</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> User &#123;</span><br><span class=\"line\">    myname:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">myname: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name); </span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> User = <span class=\"comment\">/** @class */</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">User</span>(<span class=\"params\">myname</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(User.prototype, <span class=\"string\">\"name\"</span>, &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">set</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> User;</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"><span class=\"keyword\">var</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数属性\"><a href=\"#参数属性\" class=\"headerlink\" title=\"参数属性\"></a>参数属性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> User &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> myname: <span class=\"built_in\">string</span></span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name); </span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"readonly\"><a href=\"#readonly\" class=\"headerlink\" title=\"readonly\"></a>readonly</h3><ul>\n<li>readonly修饰的变量只能在构造函数中初始化</li>\n<li>在 TypeScript 中，const 是常量标志符，其值不能被重新分配</li>\n<li>TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly</li>\n<li>readonly 实际上只是在编译阶段进行代码检查。而 const 则会在运行时检查（在支持 const 语法的 JavaScript 运行时环境中）</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> readonly name: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    changeName(name:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">a.changeName(<span class=\"string\">'jiagou'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><ul>\n<li>子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性\\</li>\n<li>将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑</li>\n<li>super可以调用父类上的方法和属性</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;<span class=\"comment\">//定义实例的属性，默认省略public修饰符</span></span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span></span>) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName():<span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name:<span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Student <span class=\"keyword\">extends</span> Person&#123;</span><br><span class=\"line\">    no: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span>,no:<span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name,age);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.no=no;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getNo():<span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.no;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s1=<span class=\"keyword\">new</span> Student(<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s1);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类里面的修饰符\"><a href=\"#类里面的修饰符\" class=\"headerlink\" title=\"类里面的修饰符\"></a>类里面的修饰符</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Father &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span>;  <span class=\"comment\">//类里面 子类 其它任何地方外边都可以访问</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> age: <span class=\"built_in\">number</span>; <span class=\"comment\">//类里面 子类 都可以访问,其它任何地方不能访问</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> money: <span class=\"built_in\">number</span>; <span class=\"comment\">//类里面可以访问， 子类和其它任何地方都不可以访问</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span>,money:<span class=\"built_in\">number</span></span>) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.money=money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName():<span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name:<span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Child <span class=\"keyword\">extends</span> Father&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span>,money:<span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name,age,money);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    desc() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.age&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.money&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.age);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.money);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态属性-静态方法\"><a href=\"#静态属性-静态方法\" class=\"headerlink\" title=\"静态属性 静态方法\"></a>静态属性 静态方法</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Father &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> className=<span class=\"string\">'Father'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> getClassName() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Father.className;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span></span>) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Father.className);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Father.getClassName());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><ul>\n<li>装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为</li>\n<li>常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器</li>\n<li>装饰器的写法分为普通装饰器和装饰器工厂</li>\n</ul>\n<h4 id=\"类装饰器\"><a href=\"#类装饰器\" class=\"headerlink\" title=\"类装饰器\"></a>类装饰器</h4><p>类装饰器在类声明之前声明，用来监视、修改或替换类定义</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> a &#123;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">        name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">        eat: <span class=\"built_in\">any</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">        target.prototype.name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">        target.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'eat'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@enhancer</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> b &#123;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">        name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">        eat: <span class=\"built_in\">any</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">            target.prototype.name = name;</span><br><span class=\"line\">            target.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'eat'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@enhancer</span>(<span class=\"string\">'zf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> c &#123;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">        name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">        eat: <span class=\"built_in\">any</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">class</span> &#123;</span><br><span class=\"line\">            name: <span class=\"built_in\">string</span> = <span class=\"string\">'jiagou'</span></span><br><span class=\"line\">            eat() &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'吃饭饭'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@enhancer</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"属性装饰器\"><a href=\"#属性装饰器\" class=\"headerlink\" title=\"属性装饰器\"></a>属性装饰器</h4><ul>\n<li>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数</li>\n<li>属性装饰器用来装饰属性</li>\n<li>第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第二个参数是属性的名称</li>\n<li>方法装饰器用来装饰方法</li>\n<li>第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第二个参数是方法的名称</li>\n<li>第三个参数是方法描述符</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> d &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upperCase</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyKey: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = target[propertyKey];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> getter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 用来替换的setter</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> setter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">            value = newVal.toUpperCase()</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 替换属性，先删除原先的属性，再重新定义属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">delete</span> target[propertyKey]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(target, propertyKey, &#123;</span><br><span class=\"line\">                <span class=\"keyword\">get</span>: getter,</span><br><span class=\"line\">                <span class=\"keyword\">set</span>: setter,</span><br><span class=\"line\">                enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                configurable: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">noEnumerable</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, property: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target.getName'</span>, target.getName);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target.getAge'</span>, target.getAge);</span><br><span class=\"line\">        descriptor.enumerable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toNumber</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, methodName: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> oldMethod = descriptor.value;</span><br><span class=\"line\">        descriptor.value = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...args: <span class=\"built_in\">any</span>[]</span>) </span>&#123;</span><br><span class=\"line\">            args = args.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">parseFloat</span>(item));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldMethod.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        <span class=\"meta\">@upperCase</span></span><br><span class=\"line\">        name: <span class=\"built_in\">string</span> = <span class=\"string\">'zf'</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> age: <span class=\"built_in\">number</span> = <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">        <span class=\"meta\">@noEnumerable</span></span><br><span class=\"line\">        getName() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@toNumber</span></span><br><span class=\"line\">        sum(...args: <span class=\"built_in\">any</span>[]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> args.reduce(<span class=\"function\">(<span class=\"params\">accu: <span class=\"built_in\">number</span>, item: <span class=\"built_in\">number</span></span>) =&gt;</span> accu + item, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> attr <span class=\"keyword\">in</span> p) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'attr='</span>, attr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p.name = <span class=\"string\">'jiagou'</span>;</span><br><span class=\"line\">    p.getName();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.sum(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数装饰器\"><a href=\"#参数装饰器\" class=\"headerlink\" title=\"参数装饰器\"></a>参数装饰器</h4><ul>\n<li>会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据</li>\n<li>第1个参数对于静态成员是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第2个参数的名称</li>\n<li>第3个参数在函数列表中的索引</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> d &#123;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">        age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addAge</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, methodName: <span class=\"built_in\">string</span>, paramsIndex: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(target);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(methodName);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(paramsIndex);</span><br><span class=\"line\">        target.age = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        login(username: <span class=\"built_in\">string</span>, <span class=\"meta\">@addAge</span> password: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age, username, password);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    p.login(<span class=\"string\">'zf'</span>, <span class=\"string\">'123456'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器执行顺序\"><a href=\"#装饰器执行顺序\" class=\"headerlink\" title=\"装饰器执行顺序\"></a>装饰器执行顺序</h3><ul>\n<li>有多个参数装饰器时：从最后一个参数依次向前执行</li>\n<li>方法和方法参数中参数装饰器先执行。</li>\n<li>类装饰器总是最后执行</li>\n<li>方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> e &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Class1Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"类1装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Class2Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"类2装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MethodDecorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, methodName: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"方法装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Param1Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, methodName: <span class=\"built_in\">string</span>, paramIndex: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"参数1装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Param2Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, methodName: <span class=\"built_in\">string</span>, paramIndex: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"参数2装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">PropertyDecorator</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(name + <span class=\"string\">\"属性装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Class1Decorator</span>()</span><br><span class=\"line\">    <span class=\"meta\">@Class2Decorator</span>()</span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        <span class=\"meta\">@PropertyDecorator</span>(<span class=\"string\">'name'</span>)</span><br><span class=\"line\">        name: <span class=\"built_in\">string</span> = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">        <span class=\"meta\">@PropertyDecorator</span>(<span class=\"string\">'age'</span>)</span><br><span class=\"line\">        age: <span class=\"built_in\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"meta\">@MethodDecorator</span>()</span><br><span class=\"line\">        greet(<span class=\"meta\">@Param1Decorator</span>() p1: <span class=\"built_in\">string</span>, <span class=\"meta\">@Param2Decorator</span>() p2: <span class=\"built_in\">string</span>) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>/**<br>name属性装饰器<br>age属性装饰器<br>参数2装饰器<br>参数1装饰器<br>方法装饰器<br>类2装饰器<br>类1装饰器<br> */</p>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>抽象描述一种抽象的概念，无法被实例化，只能被继承</li>\n<li>无法创建抽象类的实例\\</li>\n<li>抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现，而且必须实现</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    name!:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> speak():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Cat <span class=\"keyword\">extends</span> Animal&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'喵喵喵'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal();<span class=\"comment\">//Cannot create an instance of an abstract class</span></span><br><span class=\"line\">animal.speak();</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">cat.speak();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>访问控制修饰符 private protected public</li>\n<li>只读属性 readonly</li>\n<li>静态属性 static</li>\n<li>抽象类、抽象方法 abstract</li>\n</ul>\n<h4 id=\"抽象类-vs-接口\"><a href=\"#抽象类-vs-接口\" class=\"headerlink\" title=\"抽象类 vs 接口\"></a>抽象类 vs 接口</h4><ul>\n<li>不同类之间公有的属性或方法，可以抽象成一个接口（Interfaces）</li>\n<li>而抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>\n<li>抽象类本质是一个无法被实例化的类，其中能够实现方法和初始化属性，而接口仅能够用于描述,既不提供方法的实现，也不为属性进行初始化</li>\n<li>一个类可以继承一个类或抽象类，但可以实现（implements）多个接口</li>\n<li>抽象类也可以实现接口</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span></span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> speak():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Flying&#123;</span><br><span class=\"line\">      fly():<span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Duck <span class=\"keyword\">extends</span> Animal <span class=\"keyword\">implements</span> Flying&#123;</span><br><span class=\"line\">      speak()&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'汪汪汪'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      fly()&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'我会飞'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> duck = <span class=\"keyword\">new</span> Duck(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">duck.speak();</span><br><span class=\"line\">duck.fly();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"抽象方法\"><a href=\"#抽象方法\" class=\"headerlink\" title=\"抽象方法\"></a>抽象方法</h4><ul>\n<li>抽象类和方法不包含具体实现，必须在子类中实现</li>\n<li>抽象方法只能出现在抽象类中</li>\n<li>子类可以对抽象类进行不同的实现</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> speak():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span>  Animal&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'小狗汪汪汪'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Cat <span class=\"keyword\">extends</span>  Animal&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'小猫喵喵喵'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog=<span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat=<span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">dog.speak();</span><br><span class=\"line\">cat.speak();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重写-override-vs-重载-overload\"><a href=\"#重写-override-vs-重载-overload\" class=\"headerlink\" title=\"重写(override) vs 重载(overload)\"></a>重写(override) vs 重载(overload)</h3><ul>\n<li>重写是指子类重写继承自父类中的方法</li>\n<li>重载是指为同一个函数提供多个类型定义</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">    speak(word:<span class=\"built_in\">string</span>):<span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'动作叫:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Cat <span class=\"keyword\">extends</span> Animal&#123;</span><br><span class=\"line\">    speak(word:<span class=\"built_in\">string</span>):<span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'猫叫:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.speak(<span class=\"string\">'hello'</span>));</span><br><span class=\"line\"><span class=\"comment\">//--------------------------------------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:<span class=\"built_in\">number</span></span>):<span class=\"title\">number</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:<span class=\"built_in\">string</span></span>):<span class=\"title\">string</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:<span class=\"built_in\">any</span></span>):<span class=\"title\">any</span></span>&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">if</span>(<span class=\"params\"><span class=\"keyword\">typeof</span> val == '<span class=\"built_in\">number</span>'</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">return</span> <span class=\"title\">val</span> *2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val + val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> r = double(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(r);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承-vs-多态\"><a href=\"#继承-vs-多态\" class=\"headerlink\" title=\"继承 vs 多态\"></a>继承 vs 多态</h3><ul>\n<li>继承(Inheritance)子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>\n<li>多态(Polymorphism)由继承而产生了相关的不同的类，对同一个方法可以有不同的行为</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">    speak(word:<span class=\"built_in\">string</span>):<span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Animal: '</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Cat <span class=\"keyword\">extends</span> Animal&#123;</span><br><span class=\"line\">    speak(word:<span class=\"built_in\">string</span>):<span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Cat:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal&#123;</span><br><span class=\"line\">    speak(word:<span class=\"built_in\">string</span>):<span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Dog:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.speak(<span class=\"string\">'hello'</span>));</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.speak(<span class=\"string\">'hello'</span>));</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><h3 id=\"如何定义类\"><a href=\"#如何定义类\" class=\"headerlink\" title=\"如何定义类\"></a>如何定义类</h3><p>“strictPropertyInitialization”: true / 启用类属性初始化的严格检查/<br>name!:string</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    getName():<span class=\"built_in\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p1.name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">p1.getName();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存取器\"><a href=\"#存取器\" class=\"headerlink\" title=\"存取器\"></a>存取器</h3><ul>\n<li>在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为</li>\n<li>构造函数</li>\n<li>主要用于初始化类的成员变量属性</li>\n<li>类的对象创建时自动调用执行</li>\n<li>没有返回值</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> User &#123;</span><br><span class=\"line\">    myname:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">myname: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name); </span><br><span class=\"line\"><span class=\"meta\">\"use strict\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> User = <span class=\"comment\">/** @class */</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">User</span>(<span class=\"params\">myname</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(User.prototype, <span class=\"string\">\"name\"</span>, &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">set</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> User;</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"><span class=\"keyword\">var</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数属性\"><a href=\"#参数属性\" class=\"headerlink\" title=\"参数属性\"></a>参数属性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> User &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> myname: <span class=\"built_in\">string</span></span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.myname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.myname = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name); </span><br><span class=\"line\">user.name = <span class=\"string\">'jiagou'</span>; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.name);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"readonly\"><a href=\"#readonly\" class=\"headerlink\" title=\"readonly\"></a>readonly</h3><ul>\n<li>readonly修饰的变量只能在构造函数中初始化</li>\n<li>在 TypeScript 中，const 是常量标志符，其值不能被重新分配</li>\n<li>TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly</li>\n<li>readonly 实际上只是在编译阶段进行代码检查。而 const 则会在运行时检查（在支持 const 语法的 JavaScript 运行时环境中）</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> readonly name: <span class=\"built_in\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    changeName(name:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">a.changeName(<span class=\"string\">'jiagou'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><ul>\n<li>子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性\\</li>\n<li>将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑</li>\n<li>super可以调用父类上的方法和属性</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;<span class=\"comment\">//定义实例的属性，默认省略public修饰符</span></span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span></span>) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName():<span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name:<span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Student <span class=\"keyword\">extends</span> Person&#123;</span><br><span class=\"line\">    no: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span>,no:<span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name,age);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.no=no;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getNo():<span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.no;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s1=<span class=\"keyword\">new</span> Student(<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(s1);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类里面的修饰符\"><a href=\"#类里面的修饰符\" class=\"headerlink\" title=\"类里面的修饰符\"></a>类里面的修饰符</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Father &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span>;  <span class=\"comment\">//类里面 子类 其它任何地方外边都可以访问</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> age: <span class=\"built_in\">number</span>; <span class=\"comment\">//类里面 子类 都可以访问,其它任何地方不能访问</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> money: <span class=\"built_in\">number</span>; <span class=\"comment\">//类里面可以访问， 子类和其它任何地方都不可以访问</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span>,money:<span class=\"built_in\">number</span></span>) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.money=money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName():<span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name:<span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Child <span class=\"keyword\">extends</span> Father&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span>,money:<span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name,age,money);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    desc() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.age&#125;</span> <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.money&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'zf'</span>,<span class=\"number\">10</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.age);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.money);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"静态属性-静态方法\"><a href=\"#静态属性-静态方法\" class=\"headerlink\" title=\"静态属性 静态方法\"></a>静态属性 静态方法</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Father &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> className=<span class=\"string\">'Father'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> getClassName() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Father.className;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span></span>) &#123;<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Father.className);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Father.getClassName());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><ul>\n<li>装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为</li>\n<li>常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器</li>\n<li>装饰器的写法分为普通装饰器和装饰器工厂</li>\n</ul>\n<h4 id=\"类装饰器\"><a href=\"#类装饰器\" class=\"headerlink\" title=\"类装饰器\"></a>类装饰器</h4><p>类装饰器在类声明之前声明，用来监视、修改或替换类定义</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> a &#123;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">        name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">        eat: <span class=\"built_in\">any</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">        target.prototype.name = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">        target.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'eat'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@enhancer</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> b &#123;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">        name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">        eat: <span class=\"built_in\">any</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">            target.prototype.name = name;</span><br><span class=\"line\">            target.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'eat'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@enhancer</span>(<span class=\"string\">'zf'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> c &#123;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">        name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">        eat: <span class=\"built_in\">any</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhancer</span>(<span class=\"params\">target: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">class</span> &#123;</span><br><span class=\"line\">            name: <span class=\"built_in\">string</span> = <span class=\"string\">'jiagou'</span></span><br><span class=\"line\">            eat() &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'吃饭饭'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@enhancer</span></span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.name);</span><br><span class=\"line\">    p.eat();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"属性装饰器\"><a href=\"#属性装饰器\" class=\"headerlink\" title=\"属性装饰器\"></a>属性装饰器</h4><ul>\n<li>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数</li>\n<li>属性装饰器用来装饰属性</li>\n<li>第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第二个参数是属性的名称</li>\n<li>方法装饰器用来装饰方法</li>\n<li>第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第二个参数是方法的名称</li>\n<li>第三个参数是方法描述符</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> d &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upperCase</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyKey: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = target[propertyKey];</span><br><span class=\"line\">        <span class=\"keyword\">const</span> getter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 用来替换的setter</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> setter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">            value = newVal.toUpperCase()</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 替换属性，先删除原先的属性，再重新定义属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">delete</span> target[propertyKey]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(target, propertyKey, &#123;</span><br><span class=\"line\">                <span class=\"keyword\">get</span>: getter,</span><br><span class=\"line\">                <span class=\"keyword\">set</span>: setter,</span><br><span class=\"line\">                enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                configurable: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">noEnumerable</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, property: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target.getName'</span>, target.getName);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'target.getAge'</span>, target.getAge);</span><br><span class=\"line\">        descriptor.enumerable = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toNumber</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, methodName: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> oldMethod = descriptor.value;</span><br><span class=\"line\">        descriptor.value = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...args: <span class=\"built_in\">any</span>[]</span>) </span>&#123;</span><br><span class=\"line\">            args = args.map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">parseFloat</span>(item));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldMethod.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        <span class=\"meta\">@upperCase</span></span><br><span class=\"line\">        name: <span class=\"built_in\">string</span> = <span class=\"string\">'zf'</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> age: <span class=\"built_in\">number</span> = <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">        <span class=\"meta\">@noEnumerable</span></span><br><span class=\"line\">        getName() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@toNumber</span></span><br><span class=\"line\">        sum(...args: <span class=\"built_in\">any</span>[]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> args.reduce(<span class=\"function\">(<span class=\"params\">accu: <span class=\"built_in\">number</span>, item: <span class=\"built_in\">number</span></span>) =&gt;</span> accu + item, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p: Person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> attr <span class=\"keyword\">in</span> p) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'attr='</span>, attr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p.name = <span class=\"string\">'jiagou'</span>;</span><br><span class=\"line\">    p.getName();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p.sum(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数装饰器\"><a href=\"#参数装饰器\" class=\"headerlink\" title=\"参数装饰器\"></a>参数装饰器</h4><ul>\n<li>会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据</li>\n<li>第1个参数对于静态成员是类的构造函数，对于实例成员是类的原型对象</li>\n<li>第2个参数的名称</li>\n<li>第3个参数在函数列表中的索引</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> d &#123;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">        age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addAge</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, methodName: <span class=\"built_in\">string</span>, paramsIndex: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(target);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(methodName);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(paramsIndex);</span><br><span class=\"line\">        target.age = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        login(username: <span class=\"built_in\">string</span>, <span class=\"meta\">@addAge</span> password: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age, username, password);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">    p.login(<span class=\"string\">'zf'</span>, <span class=\"string\">'123456'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器执行顺序\"><a href=\"#装饰器执行顺序\" class=\"headerlink\" title=\"装饰器执行顺序\"></a>装饰器执行顺序</h3><ul>\n<li>有多个参数装饰器时：从最后一个参数依次向前执行</li>\n<li>方法和方法参数中参数装饰器先执行。</li>\n<li>类装饰器总是最后执行</li>\n<li>方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> e &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Class1Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"类1装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Class2Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"类2装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MethodDecorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, methodName: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"方法装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Param1Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, methodName: <span class=\"built_in\">string</span>, paramIndex: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"参数1装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Param2Decorator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, methodName: <span class=\"built_in\">string</span>, paramIndex: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"参数2装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">PropertyDecorator</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(name + <span class=\"string\">\"属性装饰器\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Class1Decorator</span>()</span><br><span class=\"line\">    <span class=\"meta\">@Class2Decorator</span>()</span><br><span class=\"line\">    <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">        <span class=\"meta\">@PropertyDecorator</span>(<span class=\"string\">'name'</span>)</span><br><span class=\"line\">        name: <span class=\"built_in\">string</span> = <span class=\"string\">'zf'</span>;</span><br><span class=\"line\">        <span class=\"meta\">@PropertyDecorator</span>(<span class=\"string\">'age'</span>)</span><br><span class=\"line\">        age: <span class=\"built_in\">number</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"meta\">@MethodDecorator</span>()</span><br><span class=\"line\">        greet(<span class=\"meta\">@Param1Decorator</span>() p1: <span class=\"built_in\">string</span>, <span class=\"meta\">@Param2Decorator</span>() p2: <span class=\"built_in\">string</span>) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>/**<br>name属性装饰器<br>age属性装饰器<br>参数2装饰器<br>参数1装饰器<br>方法装饰器<br>类2装饰器<br>类1装饰器<br> */</p>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>抽象描述一种抽象的概念，无法被实例化，只能被继承</li>\n<li>无法创建抽象类的实例\\</li>\n<li>抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现，而且必须实现</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    name!:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> speak():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Cat <span class=\"keyword\">extends</span> Animal&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'喵喵喵'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal();<span class=\"comment\">//Cannot create an instance of an abstract class</span></span><br><span class=\"line\">animal.speak();</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">cat.speak();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>访问控制修饰符 private protected public</li>\n<li>只读属性 readonly</li>\n<li>静态属性 static</li>\n<li>抽象类、抽象方法 abstract</li>\n</ul>\n<h4 id=\"抽象类-vs-接口\"><a href=\"#抽象类-vs-接口\" class=\"headerlink\" title=\"抽象类 vs 接口\"></a>抽象类 vs 接口</h4><ul>\n<li>不同类之间公有的属性或方法，可以抽象成一个接口（Interfaces）</li>\n<li>而抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>\n<li>抽象类本质是一个无法被实例化的类，其中能够实现方法和初始化属性，而接口仅能够用于描述,既不提供方法的实现，也不为属性进行初始化</li>\n<li>一个类可以继承一个类或抽象类，但可以实现（implements）多个接口</li>\n<li>抽象类也可以实现接口</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span></span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> speak():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Flying&#123;</span><br><span class=\"line\">      fly():<span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Duck <span class=\"keyword\">extends</span> Animal <span class=\"keyword\">implements</span> Flying&#123;</span><br><span class=\"line\">      speak()&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'汪汪汪'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      fly()&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">'我会飞'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> duck = <span class=\"keyword\">new</span> Duck(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">duck.speak();</span><br><span class=\"line\">duck.fly();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"抽象方法\"><a href=\"#抽象方法\" class=\"headerlink\" title=\"抽象方法\"></a>抽象方法</h4><ul>\n<li>抽象类和方法不包含具体实现，必须在子类中实现</li>\n<li>抽象方法只能出现在抽象类中</li>\n<li>子类可以对抽象类进行不同的实现</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> speak():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span>  Animal&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'小狗汪汪汪'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Cat <span class=\"keyword\">extends</span>  Animal&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'小猫喵喵喵'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog=<span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat=<span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">dog.speak();</span><br><span class=\"line\">cat.speak();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重写-override-vs-重载-overload\"><a href=\"#重写-override-vs-重载-overload\" class=\"headerlink\" title=\"重写(override) vs 重载(overload)\"></a>重写(override) vs 重载(overload)</h3><ul>\n<li>重写是指子类重写继承自父类中的方法</li>\n<li>重载是指为同一个函数提供多个类型定义</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">    speak(word:<span class=\"built_in\">string</span>):<span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'动作叫:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Cat <span class=\"keyword\">extends</span> Animal&#123;</span><br><span class=\"line\">    speak(word:<span class=\"built_in\">string</span>):<span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'猫叫:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.speak(<span class=\"string\">'hello'</span>));</span><br><span class=\"line\"><span class=\"comment\">//--------------------------------------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:<span class=\"built_in\">number</span></span>):<span class=\"title\">number</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:<span class=\"built_in\">string</span></span>):<span class=\"title\">string</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">val:<span class=\"built_in\">any</span></span>):<span class=\"title\">any</span></span>&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\">  <span class=\"title\">if</span>(<span class=\"params\"><span class=\"keyword\">typeof</span> val == '<span class=\"built_in\">number</span>'</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">return</span> <span class=\"title\">val</span> *2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val + val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> r = double(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(r);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承-vs-多态\"><a href=\"#继承-vs-多态\" class=\"headerlink\" title=\"继承 vs 多态\"></a>继承 vs 多态</h3><ul>\n<li>继承(Inheritance)子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>\n<li>多态(Polymorphism)由继承而产生了相关的不同的类，对同一个方法可以有不同的行为</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">    speak(word:<span class=\"built_in\">string</span>):<span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Animal: '</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Cat <span class=\"keyword\">extends</span> Animal&#123;</span><br><span class=\"line\">    speak(word:<span class=\"built_in\">string</span>):<span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Cat:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal&#123;</span><br><span class=\"line\">    speak(word:<span class=\"built_in\">string</span>):<span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Dog:'</span>+word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.speak(<span class=\"string\">'hello'</span>));</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dog.speak(<span class=\"string\">'hello'</span>));</span><br></pre></td></tr></table></figure>\n"},{"title":"typescript接口和泛型","author":"lz_allen","date":"2019-06-03T12:33:24.000Z","_content":"\n## 接口\n\n- 接口一方面可以在面向对象编程中表示为行为的抽象，另外可以用来描述对象的形状\n- 接口就是把一些类中共有的属性和方法抽象出来,可以用来约束实现此接口的类\n- 一个类可以继承另一个类并实现多个接口\n接口像插件一样是用来增强类的，而抽象类是具体类的抽象概念\n一个类可以实现多个接口，一个接口也可以被多个类实现，但一个类的可以有多个子类，但只能有一个父类\n\n### interface中可以用分号或者逗号分割每一项，也可以什么都不加\n\n### 对象的形状\n\n```typescript\n//接口可以用来描述`对象的形状`,少属性或者多属性都会报错\ninterface Speakable{\n    speak():void;\n    name?:string;//？表示可选属性\n}\n\nlet speakman:Speakable = {\n    speak(){},//少属性会报错\n    name,\n    age//多属性也会报错\n}\n```\n\n### 行为的抽象\n\n```typescript\n//接口可以在面向对象编程中表示为行为的抽象\ninterface Speakable{\n    speak():void;\n}\ninterface Eatable{\n    eat():void\n}\n//一个类可以实现多个接口\nclass Person implements Speakable,Eatable{\n    speak(){\n        console.log('Person说话');\n    }\n    eat(){}\n}\nclass TangDuck implements Speakable{\n    speak(){\n        console.log('TangDuck说话');\n    }\n    eat(){}\n}\n```\n\n### 任意属性\n\n```typescript\n//无法预先知道有哪些新的属性的时候,可以使用 `[propName:string]:any`,propName名字是任意的\ninterface Person {\n  readonly id: number;\n  name: string;\n  [propName: string]: any;\n}\n\nlet p1 = {\n  id:1,\n  name:'zf',\n  age:10\n}\n```\n\n### 接口的继承\n\n一个接口可以继承自另外一个接口\n\n```typescript\ninterface Speakable {\n    speak(): void\n}\ninterface SpeakChinese extends Speakable {\n    speakChinese(): void\n}\nclass Person implements SpeakChinese {\n    speak() {\n        console.log('Person')\n    }\n    speakChinese() {\n        console.log('speakChinese')\n    }\n}\n```\n\n#### readonly\n\n```typescript\n用 readonly 定义只读属性可以避免由于多人协作或者项目较为复杂等因素造成对象的值被重写\ninterface Person{\n  readonly id:number;\n  name:string\n}\nlet tom:Person = {\n  id :1,\n  name:'zf'\n}\ntom.id = 1;\n```\n\n### 函数类型接口\n\n```typescript\n对方法传入的参数和返回值进行约束\ninterface discount{\n  (price:number):number\n}\nlet cost:discount = function(price:number):number{\n   return price * .8;\n}\n```\n\n### 可索引接口\n\n```typescript\n对数组和对象进行约束\nuserInterface 表示index的类型是 number，那么值的类型必须是 string\nUserInterface2 表示：index 的类型是 string，那么值的类型必须是 string\ninterface UserInterface {\n  [index:number]:string\n}\nlet arr:UserInterface = ['zf1','zf2'];\nconsole.log(arr);\n\ninterface UserInterface2 {\n  [index:string]:string\n}\nlet obj:UserInterface2 = {name:'zf'};\n```\n\n### 类接口\n\n```typescript\n对类的约束\ninterface Speakable {\n    name: string;\n    speak(words: string): void\n}\nclass Dog implements Speakable {\n    name!: string;\n    speak(words:string) {\n        console.log(words);\n    }\n}\nlet dog = new Dog();\ndog.speak('汪汪汪');\n```\n\n### 构造函数的类型\n\n```typescript\n在 TypeScript 中，我们可以用 interface 来描述类\n同时也可以使用interface里特殊的new()关键字来描述类的构造函数类型\nclass Animal{\n  constructor(public name:string){\n  }\n}\ninterface WithNameClass{\n  new(name:string):Animal\n}\nfunction createAnimal(clazz:WithNameClass,name:string){\n   return new clazz(name);\n}\nlet a = createAnimal(Animal,'zf');\nconsole.log(a.name);\n```\n\n## 泛型\n\n- 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性\n- 泛型T作用域只限于函数内部使用\n\n### 泛型函数\n\n```typescript\n首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值\nfunction createArray(length: number, value: any): Array<any> {\n  let result: any = [];\n  for (let i = 0; i < length; i++) {\n    result[i] = value;\n  }\n  return result;\n}\nlet result = createArray(3,'x');\nconsole.log(result);\n使用了泛型\n\nfunction createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n      result[i] = value;\n    }\n    return result;\n  }\nlet result = createArray2<string>(3,'x');\nconsole.log(result);\n```\n\n### 类数组\n\n```typescript\n类数组（Array-like Object）不是数组类型，比如 arguments\nfunction sum() {\n    let args: IArguments = arguments;\n    for (let i = 0; i < args.length; i++) {\n        console.log(args[i]);\n    }\n}\nsum(1, 2, 3);\n\nlet root = document.getElementById('root');\nlet children: HTMLCollection = (root as HTMLElement).children;\nchildren.length;\nlet nodeList: NodeList = (root as HTMLElement).childNodes;\nnodeList.length;\n```\n\n### 泛型类\n\n```typescript\nclass MyArray<T>{\n    private list:T[]=[];\n    add(value:T) {\n        this.list.push(value);\n    }\n    getMax():T {\n        let result=this.list[0];\n        for (let i=0;i<this.list.length;i++){\n            if (this.list[i]>result) {\n                result=this.list[i];\n            }\n        }\n        return result;\n    }\n}\nlet arr=new MyArray();\narr.add(1); arr.add(2); arr.add(3);\nlet ret = arr.getMax();\nconsole.log(ret);\n```\n\n### 泛型接口\n\n泛型接口可以用来约束函数\n\n```typescript\ninterface Calculate{\n  <T>(a:T,b:T):T\n}\nlet add:Calculate = function<T>(a:T,b:T){\n  return a;\n}\nadd<number>(1,2);\n```\n\n### 多个类型参数\n\n```typescript\n泛型可以有多个\nfunction swap<A,B>(tuple:[A,B]):[B,A]{\n  return [tuple[1],tuple[0]];\n}\nlet swapped = swap<string,number>(['a',1]);\nconsole.log(swapped);\nconsole.log(swapped[0].toFixed(2));\nconsole.log(swapped[1].length);\n7.7 默认泛型类型\nfunction createArray3<T=number>(length: number, value: T): Array<T> {\n  let result: T[] = [];\n  for (let i = 0; i < length; i++) {\n    result[i] = value;\n  }\n  return result;\n}\nlet result2 = createArray3(3,'x');\nconsole.log(result2);\n```\n\n### 泛型约束\n\n在函数中使用泛型的时候，由于预先并不知道泛型的类型，所以不能随意访问相应类型的属性或方法。\n\n```typescript\nfunction logger<T>(val: T) {\n    console.log(val.length); //直接访问会报错\n}\n//可以让泛型继承一个接口\ninterface LengthWise {\n    length: number\n}\n//可以让泛型继承一个接口\nfunction logger2<T extends LengthWise>(val: T) {\n    console.log(val.length)\n}\nlogger2('zf');\nlogger2(1);\n```\n\n### 泛型接口定义\n\n```typescript\n定义接口的时候也可以指定泛型\ninterface Cart<T>{\n  list:T[]\n}\nlet cart:Cart<{name:string,price:number}> = {\n  list:[{name:'zf',price:10}]\n}\nconsole.log(cart.list[0].name,cart.list[0].price);\n```\n\n### 泛型类型别名\n\n泛型类型别名可以表达更复杂的类型\n\n```typescript\ntype Cart<T> = {list:T[]} | T[];\nlet c1:Cart<string> = {list:['1']};\nlet c2:Cart<number> = [1];\n```\n\n### 泛型接口 vs 泛型类型别名\n\n- 接口创建了一个新的名字，它可以在其他任意地方被调用。而类型别名并不创建新的名字，例如报错信息就不会使用别名\n- 类型别名不能被 extends和 implements,这时我们应该尽量使用接口代替类型别名\n- 当我们需要使用联合类型或者元组类型的时候，类型别名会更合适\n","source":"_posts/page/typescript接口和泛型.md","raw":"---\ntitle: typescript接口和泛型\ncategories: web前端\nauthor: lz_allen\ntags:\n  - typescript\ndate: 2019-06-03 20:33:24\n---\n\n## 接口\n\n- 接口一方面可以在面向对象编程中表示为行为的抽象，另外可以用来描述对象的形状\n- 接口就是把一些类中共有的属性和方法抽象出来,可以用来约束实现此接口的类\n- 一个类可以继承另一个类并实现多个接口\n接口像插件一样是用来增强类的，而抽象类是具体类的抽象概念\n一个类可以实现多个接口，一个接口也可以被多个类实现，但一个类的可以有多个子类，但只能有一个父类\n\n### interface中可以用分号或者逗号分割每一项，也可以什么都不加\n\n### 对象的形状\n\n```typescript\n//接口可以用来描述`对象的形状`,少属性或者多属性都会报错\ninterface Speakable{\n    speak():void;\n    name?:string;//？表示可选属性\n}\n\nlet speakman:Speakable = {\n    speak(){},//少属性会报错\n    name,\n    age//多属性也会报错\n}\n```\n\n### 行为的抽象\n\n```typescript\n//接口可以在面向对象编程中表示为行为的抽象\ninterface Speakable{\n    speak():void;\n}\ninterface Eatable{\n    eat():void\n}\n//一个类可以实现多个接口\nclass Person implements Speakable,Eatable{\n    speak(){\n        console.log('Person说话');\n    }\n    eat(){}\n}\nclass TangDuck implements Speakable{\n    speak(){\n        console.log('TangDuck说话');\n    }\n    eat(){}\n}\n```\n\n### 任意属性\n\n```typescript\n//无法预先知道有哪些新的属性的时候,可以使用 `[propName:string]:any`,propName名字是任意的\ninterface Person {\n  readonly id: number;\n  name: string;\n  [propName: string]: any;\n}\n\nlet p1 = {\n  id:1,\n  name:'zf',\n  age:10\n}\n```\n\n### 接口的继承\n\n一个接口可以继承自另外一个接口\n\n```typescript\ninterface Speakable {\n    speak(): void\n}\ninterface SpeakChinese extends Speakable {\n    speakChinese(): void\n}\nclass Person implements SpeakChinese {\n    speak() {\n        console.log('Person')\n    }\n    speakChinese() {\n        console.log('speakChinese')\n    }\n}\n```\n\n#### readonly\n\n```typescript\n用 readonly 定义只读属性可以避免由于多人协作或者项目较为复杂等因素造成对象的值被重写\ninterface Person{\n  readonly id:number;\n  name:string\n}\nlet tom:Person = {\n  id :1,\n  name:'zf'\n}\ntom.id = 1;\n```\n\n### 函数类型接口\n\n```typescript\n对方法传入的参数和返回值进行约束\ninterface discount{\n  (price:number):number\n}\nlet cost:discount = function(price:number):number{\n   return price * .8;\n}\n```\n\n### 可索引接口\n\n```typescript\n对数组和对象进行约束\nuserInterface 表示index的类型是 number，那么值的类型必须是 string\nUserInterface2 表示：index 的类型是 string，那么值的类型必须是 string\ninterface UserInterface {\n  [index:number]:string\n}\nlet arr:UserInterface = ['zf1','zf2'];\nconsole.log(arr);\n\ninterface UserInterface2 {\n  [index:string]:string\n}\nlet obj:UserInterface2 = {name:'zf'};\n```\n\n### 类接口\n\n```typescript\n对类的约束\ninterface Speakable {\n    name: string;\n    speak(words: string): void\n}\nclass Dog implements Speakable {\n    name!: string;\n    speak(words:string) {\n        console.log(words);\n    }\n}\nlet dog = new Dog();\ndog.speak('汪汪汪');\n```\n\n### 构造函数的类型\n\n```typescript\n在 TypeScript 中，我们可以用 interface 来描述类\n同时也可以使用interface里特殊的new()关键字来描述类的构造函数类型\nclass Animal{\n  constructor(public name:string){\n  }\n}\ninterface WithNameClass{\n  new(name:string):Animal\n}\nfunction createAnimal(clazz:WithNameClass,name:string){\n   return new clazz(name);\n}\nlet a = createAnimal(Animal,'zf');\nconsole.log(a.name);\n```\n\n## 泛型\n\n- 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性\n- 泛型T作用域只限于函数内部使用\n\n### 泛型函数\n\n```typescript\n首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值\nfunction createArray(length: number, value: any): Array<any> {\n  let result: any = [];\n  for (let i = 0; i < length; i++) {\n    result[i] = value;\n  }\n  return result;\n}\nlet result = createArray(3,'x');\nconsole.log(result);\n使用了泛型\n\nfunction createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n      result[i] = value;\n    }\n    return result;\n  }\nlet result = createArray2<string>(3,'x');\nconsole.log(result);\n```\n\n### 类数组\n\n```typescript\n类数组（Array-like Object）不是数组类型，比如 arguments\nfunction sum() {\n    let args: IArguments = arguments;\n    for (let i = 0; i < args.length; i++) {\n        console.log(args[i]);\n    }\n}\nsum(1, 2, 3);\n\nlet root = document.getElementById('root');\nlet children: HTMLCollection = (root as HTMLElement).children;\nchildren.length;\nlet nodeList: NodeList = (root as HTMLElement).childNodes;\nnodeList.length;\n```\n\n### 泛型类\n\n```typescript\nclass MyArray<T>{\n    private list:T[]=[];\n    add(value:T) {\n        this.list.push(value);\n    }\n    getMax():T {\n        let result=this.list[0];\n        for (let i=0;i<this.list.length;i++){\n            if (this.list[i]>result) {\n                result=this.list[i];\n            }\n        }\n        return result;\n    }\n}\nlet arr=new MyArray();\narr.add(1); arr.add(2); arr.add(3);\nlet ret = arr.getMax();\nconsole.log(ret);\n```\n\n### 泛型接口\n\n泛型接口可以用来约束函数\n\n```typescript\ninterface Calculate{\n  <T>(a:T,b:T):T\n}\nlet add:Calculate = function<T>(a:T,b:T){\n  return a;\n}\nadd<number>(1,2);\n```\n\n### 多个类型参数\n\n```typescript\n泛型可以有多个\nfunction swap<A,B>(tuple:[A,B]):[B,A]{\n  return [tuple[1],tuple[0]];\n}\nlet swapped = swap<string,number>(['a',1]);\nconsole.log(swapped);\nconsole.log(swapped[0].toFixed(2));\nconsole.log(swapped[1].length);\n7.7 默认泛型类型\nfunction createArray3<T=number>(length: number, value: T): Array<T> {\n  let result: T[] = [];\n  for (let i = 0; i < length; i++) {\n    result[i] = value;\n  }\n  return result;\n}\nlet result2 = createArray3(3,'x');\nconsole.log(result2);\n```\n\n### 泛型约束\n\n在函数中使用泛型的时候，由于预先并不知道泛型的类型，所以不能随意访问相应类型的属性或方法。\n\n```typescript\nfunction logger<T>(val: T) {\n    console.log(val.length); //直接访问会报错\n}\n//可以让泛型继承一个接口\ninterface LengthWise {\n    length: number\n}\n//可以让泛型继承一个接口\nfunction logger2<T extends LengthWise>(val: T) {\n    console.log(val.length)\n}\nlogger2('zf');\nlogger2(1);\n```\n\n### 泛型接口定义\n\n```typescript\n定义接口的时候也可以指定泛型\ninterface Cart<T>{\n  list:T[]\n}\nlet cart:Cart<{name:string,price:number}> = {\n  list:[{name:'zf',price:10}]\n}\nconsole.log(cart.list[0].name,cart.list[0].price);\n```\n\n### 泛型类型别名\n\n泛型类型别名可以表达更复杂的类型\n\n```typescript\ntype Cart<T> = {list:T[]} | T[];\nlet c1:Cart<string> = {list:['1']};\nlet c2:Cart<number> = [1];\n```\n\n### 泛型接口 vs 泛型类型别名\n\n- 接口创建了一个新的名字，它可以在其他任意地方被调用。而类型别名并不创建新的名字，例如报错信息就不会使用别名\n- 类型别名不能被 extends和 implements,这时我们应该尽量使用接口代替类型别名\n- 当我们需要使用联合类型或者元组类型的时候，类型别名会更合适\n","slug":"page/typescript接口和泛型","published":1,"updated":"2020-08-14T10:20:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdydrm4d00004tiv0rwk27e3","content":"<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><ul>\n<li>接口一方面可以在面向对象编程中表示为行为的抽象，另外可以用来描述对象的形状</li>\n<li>接口就是把一些类中共有的属性和方法抽象出来,可以用来约束实现此接口的类</li>\n<li>一个类可以继承另一个类并实现多个接口<br>接口像插件一样是用来增强类的，而抽象类是具体类的抽象概念<br>一个类可以实现多个接口，一个接口也可以被多个类实现，但一个类的可以有多个子类，但只能有一个父类</li>\n</ul>\n<h3 id=\"interface中可以用分号或者逗号分割每一项，也可以什么都不加\"><a href=\"#interface中可以用分号或者逗号分割每一项，也可以什么都不加\" class=\"headerlink\" title=\"interface中可以用分号或者逗号分割每一项，也可以什么都不加\"></a>interface中可以用分号或者逗号分割每一项，也可以什么都不加</h3><h3 id=\"对象的形状\"><a href=\"#对象的形状\" class=\"headerlink\" title=\"对象的形状\"></a>对象的形状</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口可以用来描述`对象的形状`,少属性或者多属性都会报错</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Speakable&#123;</span><br><span class=\"line\">    speak():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">    name?:<span class=\"built_in\">string</span>;<span class=\"comment\">//？表示可选属性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> speakman:Speakable = &#123;</span><br><span class=\"line\">    speak()&#123;&#125;,<span class=\"comment\">//少属性会报错</span></span><br><span class=\"line\">    name,</span><br><span class=\"line\">    age<span class=\"comment\">//多属性也会报错</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"行为的抽象\"><a href=\"#行为的抽象\" class=\"headerlink\" title=\"行为的抽象\"></a>行为的抽象</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口可以在面向对象编程中表示为行为的抽象</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Speakable&#123;</span><br><span class=\"line\">    speak():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Eatable&#123;</span><br><span class=\"line\">    eat():<span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//一个类可以实现多个接口</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Person <span class=\"keyword\">implements</span> Speakable,Eatable&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Person说话'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> TangDuck <span class=\"keyword\">implements</span> Speakable&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'TangDuck说话'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//无法预先知道有哪些新的属性的时候,可以使用 `[propName:string]:any`,propName名字是任意的</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  readonly id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = &#123;</span><br><span class=\"line\">  id:<span class=\"number\">1</span>,</span><br><span class=\"line\">  name:<span class=\"string\">'zf'</span>,</span><br><span class=\"line\">  age:<span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"接口的继承\"><a href=\"#接口的继承\" class=\"headerlink\" title=\"接口的继承\"></a>接口的继承</h3><p>一个接口可以继承自另外一个接口</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Speakable &#123;</span><br><span class=\"line\">    speak(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> SpeakChinese <span class=\"keyword\">extends</span> Speakable &#123;</span><br><span class=\"line\">    speakChinese(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Person <span class=\"keyword\">implements</span> SpeakChinese &#123;</span><br><span class=\"line\">    speak() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Person'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    speakChinese() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'speakChinese'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"readonly\"><a href=\"#readonly\" class=\"headerlink\" title=\"readonly\"></a>readonly</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">用 readonly 定义只读属性可以避免由于多人协作或者项目较为复杂等因素造成对象的值被重写</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">  readonly id:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> tom:Person = &#123;</span><br><span class=\"line\">  id :<span class=\"number\">1</span>,</span><br><span class=\"line\">  name:<span class=\"string\">'zf'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tom.id = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数类型接口\"><a href=\"#函数类型接口\" class=\"headerlink\" title=\"函数类型接口\"></a>函数类型接口</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">对方法传入的参数和返回值进行约束</span><br><span class=\"line\"><span class=\"keyword\">interface</span> discount&#123;</span><br><span class=\"line\">  (price:<span class=\"built_in\">number</span>):<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cost:discount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">price:<span class=\"built_in\">number</span></span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> price * <span class=\"number\">.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可索引接口\"><a href=\"#可索引接口\" class=\"headerlink\" title=\"可索引接口\"></a>可索引接口</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">对数组和对象进行约束</span><br><span class=\"line\">userInterface 表示index的类型是 <span class=\"built_in\">number</span>，那么值的类型必须是 <span class=\"built_in\">string</span></span><br><span class=\"line\">UserInterface2 表示：index 的类型是 <span class=\"built_in\">string</span>，那么值的类型必须是 <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> UserInterface &#123;</span><br><span class=\"line\">  [index:<span class=\"built_in\">number</span>]:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr:UserInterface = [<span class=\"string\">'zf1'</span>,<span class=\"string\">'zf2'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> UserInterface2 &#123;</span><br><span class=\"line\">  [index:<span class=\"built_in\">string</span>]:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj:UserInterface2 = &#123;name:<span class=\"string\">'zf'</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类接口\"><a href=\"#类接口\" class=\"headerlink\" title=\"类接口\"></a>类接口</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">对类的约束</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Speakable &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    speak(words: <span class=\"built_in\">string</span>): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">implements</span> Speakable &#123;</span><br><span class=\"line\">    name!: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    speak(words:<span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(words);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\">dog.speak(<span class=\"string\">'汪汪汪'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造函数的类型\"><a href=\"#构造函数的类型\" class=\"headerlink\" title=\"构造函数的类型\"></a>构造函数的类型</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">在 TypeScript 中，我们可以用 <span class=\"keyword\">interface</span> 来描述类</span><br><span class=\"line\">同时也可以使用<span class=\"keyword\">interface</span>里特殊的new()关键字来描述类的构造函数类型</span><br><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> name:<span class=\"built_in\">string</span></span>)&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> WithNameClass&#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span>(name:<span class=\"built_in\">string</span>):Animal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnimal</span>(<span class=\"params\">clazz:WithNameClass,name:<span class=\"built_in\">string</span></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> clazz(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = createAnimal(Animal,<span class=\"string\">'zf'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.name);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><ul>\n<li>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</li>\n<li>泛型T作用域只限于函数内部使用</li>\n</ul>\n<h3 id=\"泛型函数\"><a href=\"#泛型函数\" class=\"headerlink\" title=\"泛型函数\"></a>泛型函数</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createArray</span>(<span class=\"params\">length: <span class=\"built_in\">number</span>, value: <span class=\"built_in\">any</span></span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">any</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result: <span class=\"built_in\">any</span> = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    result[i] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = createArray(<span class=\"number\">3</span>,<span class=\"string\">'x'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">使用了泛型</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createArray</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">length: <span class=\"built_in\">number</span>, value: T</span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result: T[] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">      result[i] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = createArray2&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"number\">3</span>,<span class=\"string\">'x'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">类数组（<span class=\"built_in\">Array</span>-like <span class=\"built_in\">Object</span>）不是数组类型，比如 <span class=\"built_in\">arguments</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> args: IArguments = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; args.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(args[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> root = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> children: HTMLCollection = (root <span class=\"keyword\">as</span> HTMLElement).children;</span><br><span class=\"line\">children.length;</span><br><span class=\"line\"><span class=\"keyword\">let</span> nodeList: NodeList = (root <span class=\"keyword\">as</span> HTMLElement).childNodes;</span><br><span class=\"line\">nodeList.length;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> MyArray&lt;T&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> list:T[]=[];</span><br><span class=\"line\">    add(value:T) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.list.push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getMax():T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> result=<span class=\"keyword\">this</span>.list[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"keyword\">this</span>.list.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.list[i]&gt;result) &#123;</span><br><span class=\"line\">                result=<span class=\"keyword\">this</span>.list[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr=<span class=\"keyword\">new</span> MyArray();</span><br><span class=\"line\">arr.add(<span class=\"number\">1</span>); arr.add(<span class=\"number\">2</span>); arr.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> ret = arr.getMax();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ret);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h3><p>泛型接口可以用来约束函数</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Calculate&#123;</span><br><span class=\"line\">  &lt;T&gt;(a:T,b:T):T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> add:Calculate = <span class=\"function\"><span class=\"keyword\">function</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">a:T,b:T</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add&lt;<span class=\"built_in\">number</span>&gt;(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个类型参数\"><a href=\"#多个类型参数\" class=\"headerlink\" title=\"多个类型参数\"></a>多个类型参数</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">泛型可以有多个</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>&lt;<span class=\"title\">A</span>,<span class=\"title\">B</span>&gt;(<span class=\"params\">tuple:[A,B]</span>):[<span class=\"title\">B</span>,<span class=\"title\">A</span>]</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [tuple[<span class=\"number\">1</span>],tuple[<span class=\"number\">0</span>]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> swapped = swap&lt;<span class=\"built_in\">string</span>,<span class=\"built_in\">number</span>&gt;([<span class=\"string\">'a'</span>,<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(swapped);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(swapped[<span class=\"number\">0</span>].toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(swapped[<span class=\"number\">1</span>].length);</span><br><span class=\"line\"><span class=\"number\">7.7</span> 默认泛型类型</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createArray3</span>&lt;<span class=\"title\">T</span>=<span class=\"title\">number</span>&gt;(<span class=\"params\">length: <span class=\"built_in\">number</span>, value: T</span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result: T[] = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    result[i] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = createArray3(<span class=\"number\">3</span>,<span class=\"string\">'x'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result2);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型约束\"><a href=\"#泛型约束\" class=\"headerlink\" title=\"泛型约束\"></a>泛型约束</h3><p>在函数中使用泛型的时候，由于预先并不知道泛型的类型，所以不能随意访问相应类型的属性或方法。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logger</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">val: T</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val.length); <span class=\"comment\">//直接访问会报错</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//可以让泛型继承一个接口</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> LengthWise &#123;</span><br><span class=\"line\">    length: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//可以让泛型继承一个接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logger2</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">LengthWise</span>&gt;(<span class=\"params\">val: T</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val.length)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">logger2(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">logger2(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型接口定义\"><a href=\"#泛型接口定义\" class=\"headerlink\" title=\"泛型接口定义\"></a>泛型接口定义</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">定义接口的时候也可以指定泛型</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cart&lt;T&gt;&#123;</span><br><span class=\"line\">  list:T[]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cart:Cart&lt;&#123;name:<span class=\"built_in\">string</span>,price:<span class=\"built_in\">number</span>&#125;&gt; = &#123;</span><br><span class=\"line\">  list:[&#123;name:<span class=\"string\">'zf'</span>,price:<span class=\"number\">10</span>&#125;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cart.list[<span class=\"number\">0</span>].name,cart.list[<span class=\"number\">0</span>].price);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型类型别名\"><a href=\"#泛型类型别名\" class=\"headerlink\" title=\"泛型类型别名\"></a>泛型类型别名</h3><p>泛型类型别名可以表达更复杂的类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Cart&lt;T&gt; = &#123;list:T[]&#125; | T[];</span><br><span class=\"line\"><span class=\"keyword\">let</span> c1:Cart&lt;<span class=\"built_in\">string</span>&gt; = &#123;list:[<span class=\"string\">'1'</span>]&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c2:Cart&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型接口-vs-泛型类型别名\"><a href=\"#泛型接口-vs-泛型类型别名\" class=\"headerlink\" title=\"泛型接口 vs 泛型类型别名\"></a>泛型接口 vs 泛型类型别名</h3><ul>\n<li>接口创建了一个新的名字，它可以在其他任意地方被调用。而类型别名并不创建新的名字，例如报错信息就不会使用别名</li>\n<li>类型别名不能被 extends和 implements,这时我们应该尽量使用接口代替类型别名</li>\n<li>当我们需要使用联合类型或者元组类型的时候，类型别名会更合适</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><ul>\n<li>接口一方面可以在面向对象编程中表示为行为的抽象，另外可以用来描述对象的形状</li>\n<li>接口就是把一些类中共有的属性和方法抽象出来,可以用来约束实现此接口的类</li>\n<li>一个类可以继承另一个类并实现多个接口<br>接口像插件一样是用来增强类的，而抽象类是具体类的抽象概念<br>一个类可以实现多个接口，一个接口也可以被多个类实现，但一个类的可以有多个子类，但只能有一个父类</li>\n</ul>\n<h3 id=\"interface中可以用分号或者逗号分割每一项，也可以什么都不加\"><a href=\"#interface中可以用分号或者逗号分割每一项，也可以什么都不加\" class=\"headerlink\" title=\"interface中可以用分号或者逗号分割每一项，也可以什么都不加\"></a>interface中可以用分号或者逗号分割每一项，也可以什么都不加</h3><h3 id=\"对象的形状\"><a href=\"#对象的形状\" class=\"headerlink\" title=\"对象的形状\"></a>对象的形状</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口可以用来描述`对象的形状`,少属性或者多属性都会报错</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Speakable&#123;</span><br><span class=\"line\">    speak():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">    name?:<span class=\"built_in\">string</span>;<span class=\"comment\">//？表示可选属性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> speakman:Speakable = &#123;</span><br><span class=\"line\">    speak()&#123;&#125;,<span class=\"comment\">//少属性会报错</span></span><br><span class=\"line\">    name,</span><br><span class=\"line\">    age<span class=\"comment\">//多属性也会报错</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"行为的抽象\"><a href=\"#行为的抽象\" class=\"headerlink\" title=\"行为的抽象\"></a>行为的抽象</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口可以在面向对象编程中表示为行为的抽象</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Speakable&#123;</span><br><span class=\"line\">    speak():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Eatable&#123;</span><br><span class=\"line\">    eat():<span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//一个类可以实现多个接口</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Person <span class=\"keyword\">implements</span> Speakable,Eatable&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Person说话'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> TangDuck <span class=\"keyword\">implements</span> Speakable&#123;</span><br><span class=\"line\">    speak()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'TangDuck说话'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    eat()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//无法预先知道有哪些新的属性的时候,可以使用 `[propName:string]:any`,propName名字是任意的</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  readonly id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = &#123;</span><br><span class=\"line\">  id:<span class=\"number\">1</span>,</span><br><span class=\"line\">  name:<span class=\"string\">'zf'</span>,</span><br><span class=\"line\">  age:<span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"接口的继承\"><a href=\"#接口的继承\" class=\"headerlink\" title=\"接口的继承\"></a>接口的继承</h3><p>一个接口可以继承自另外一个接口</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Speakable &#123;</span><br><span class=\"line\">    speak(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> SpeakChinese <span class=\"keyword\">extends</span> Speakable &#123;</span><br><span class=\"line\">    speakChinese(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Person <span class=\"keyword\">implements</span> SpeakChinese &#123;</span><br><span class=\"line\">    speak() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Person'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    speakChinese() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'speakChinese'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"readonly\"><a href=\"#readonly\" class=\"headerlink\" title=\"readonly\"></a>readonly</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">用 readonly 定义只读属性可以避免由于多人协作或者项目较为复杂等因素造成对象的值被重写</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">  readonly id:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> tom:Person = &#123;</span><br><span class=\"line\">  id :<span class=\"number\">1</span>,</span><br><span class=\"line\">  name:<span class=\"string\">'zf'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tom.id = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数类型接口\"><a href=\"#函数类型接口\" class=\"headerlink\" title=\"函数类型接口\"></a>函数类型接口</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">对方法传入的参数和返回值进行约束</span><br><span class=\"line\"><span class=\"keyword\">interface</span> discount&#123;</span><br><span class=\"line\">  (price:<span class=\"built_in\">number</span>):<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cost:discount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">price:<span class=\"built_in\">number</span></span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> price * <span class=\"number\">.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可索引接口\"><a href=\"#可索引接口\" class=\"headerlink\" title=\"可索引接口\"></a>可索引接口</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">对数组和对象进行约束</span><br><span class=\"line\">userInterface 表示index的类型是 <span class=\"built_in\">number</span>，那么值的类型必须是 <span class=\"built_in\">string</span></span><br><span class=\"line\">UserInterface2 表示：index 的类型是 <span class=\"built_in\">string</span>，那么值的类型必须是 <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> UserInterface &#123;</span><br><span class=\"line\">  [index:<span class=\"built_in\">number</span>]:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr:UserInterface = [<span class=\"string\">'zf1'</span>,<span class=\"string\">'zf2'</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> UserInterface2 &#123;</span><br><span class=\"line\">  [index:<span class=\"built_in\">string</span>]:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj:UserInterface2 = &#123;name:<span class=\"string\">'zf'</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类接口\"><a href=\"#类接口\" class=\"headerlink\" title=\"类接口\"></a>类接口</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">对类的约束</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Speakable &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    speak(words: <span class=\"built_in\">string</span>): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">implements</span> Speakable &#123;</span><br><span class=\"line\">    name!: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    speak(words:<span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(words);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"keyword\">new</span> Dog();</span><br><span class=\"line\">dog.speak(<span class=\"string\">'汪汪汪'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造函数的类型\"><a href=\"#构造函数的类型\" class=\"headerlink\" title=\"构造函数的类型\"></a>构造函数的类型</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">在 TypeScript 中，我们可以用 <span class=\"keyword\">interface</span> 来描述类</span><br><span class=\"line\">同时也可以使用<span class=\"keyword\">interface</span>里特殊的new()关键字来描述类的构造函数类型</span><br><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> name:<span class=\"built_in\">string</span></span>)&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> WithNameClass&#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span>(name:<span class=\"built_in\">string</span>):Animal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnimal</span>(<span class=\"params\">clazz:WithNameClass,name:<span class=\"built_in\">string</span></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> clazz(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = createAnimal(Animal,<span class=\"string\">'zf'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.name);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><ul>\n<li>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</li>\n<li>泛型T作用域只限于函数内部使用</li>\n</ul>\n<h3 id=\"泛型函数\"><a href=\"#泛型函数\" class=\"headerlink\" title=\"泛型函数\"></a>泛型函数</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createArray</span>(<span class=\"params\">length: <span class=\"built_in\">number</span>, value: <span class=\"built_in\">any</span></span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">any</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result: <span class=\"built_in\">any</span> = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    result[i] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = createArray(<span class=\"number\">3</span>,<span class=\"string\">'x'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">使用了泛型</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createArray</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">length: <span class=\"built_in\">number</span>, value: T</span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result: T[] = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">      result[i] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = createArray2&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"number\">3</span>,<span class=\"string\">'x'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">类数组（<span class=\"built_in\">Array</span>-like <span class=\"built_in\">Object</span>）不是数组类型，比如 <span class=\"built_in\">arguments</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> args: IArguments = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; args.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(args[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> root = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> children: HTMLCollection = (root <span class=\"keyword\">as</span> HTMLElement).children;</span><br><span class=\"line\">children.length;</span><br><span class=\"line\"><span class=\"keyword\">let</span> nodeList: NodeList = (root <span class=\"keyword\">as</span> HTMLElement).childNodes;</span><br><span class=\"line\">nodeList.length;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> MyArray&lt;T&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> list:T[]=[];</span><br><span class=\"line\">    add(value:T) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.list.push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getMax():T &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> result=<span class=\"keyword\">this</span>.list[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"keyword\">this</span>.list.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.list[i]&gt;result) &#123;</span><br><span class=\"line\">                result=<span class=\"keyword\">this</span>.list[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr=<span class=\"keyword\">new</span> MyArray();</span><br><span class=\"line\">arr.add(<span class=\"number\">1</span>); arr.add(<span class=\"number\">2</span>); arr.add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> ret = arr.getMax();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ret);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h3><p>泛型接口可以用来约束函数</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Calculate&#123;</span><br><span class=\"line\">  &lt;T&gt;(a:T,b:T):T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> add:Calculate = <span class=\"function\"><span class=\"keyword\">function</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">a:T,b:T</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add&lt;<span class=\"built_in\">number</span>&gt;(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个类型参数\"><a href=\"#多个类型参数\" class=\"headerlink\" title=\"多个类型参数\"></a>多个类型参数</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">泛型可以有多个</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>&lt;<span class=\"title\">A</span>,<span class=\"title\">B</span>&gt;(<span class=\"params\">tuple:[A,B]</span>):[<span class=\"title\">B</span>,<span class=\"title\">A</span>]</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [tuple[<span class=\"number\">1</span>],tuple[<span class=\"number\">0</span>]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> swapped = swap&lt;<span class=\"built_in\">string</span>,<span class=\"built_in\">number</span>&gt;([<span class=\"string\">'a'</span>,<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(swapped);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(swapped[<span class=\"number\">0</span>].toFixed(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(swapped[<span class=\"number\">1</span>].length);</span><br><span class=\"line\"><span class=\"number\">7.7</span> 默认泛型类型</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createArray3</span>&lt;<span class=\"title\">T</span>=<span class=\"title\">number</span>&gt;(<span class=\"params\">length: <span class=\"built_in\">number</span>, value: T</span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result: T[] = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    result[i] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = createArray3(<span class=\"number\">3</span>,<span class=\"string\">'x'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result2);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型约束\"><a href=\"#泛型约束\" class=\"headerlink\" title=\"泛型约束\"></a>泛型约束</h3><p>在函数中使用泛型的时候，由于预先并不知道泛型的类型，所以不能随意访问相应类型的属性或方法。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logger</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">val: T</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val.length); <span class=\"comment\">//直接访问会报错</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//可以让泛型继承一个接口</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> LengthWise &#123;</span><br><span class=\"line\">    length: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//可以让泛型继承一个接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logger2</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">LengthWise</span>&gt;(<span class=\"params\">val: T</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val.length)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">logger2(<span class=\"string\">'zf'</span>);</span><br><span class=\"line\">logger2(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型接口定义\"><a href=\"#泛型接口定义\" class=\"headerlink\" title=\"泛型接口定义\"></a>泛型接口定义</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">定义接口的时候也可以指定泛型</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cart&lt;T&gt;&#123;</span><br><span class=\"line\">  list:T[]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cart:Cart&lt;&#123;name:<span class=\"built_in\">string</span>,price:<span class=\"built_in\">number</span>&#125;&gt; = &#123;</span><br><span class=\"line\">  list:[&#123;name:<span class=\"string\">'zf'</span>,price:<span class=\"number\">10</span>&#125;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cart.list[<span class=\"number\">0</span>].name,cart.list[<span class=\"number\">0</span>].price);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型类型别名\"><a href=\"#泛型类型别名\" class=\"headerlink\" title=\"泛型类型别名\"></a>泛型类型别名</h3><p>泛型类型别名可以表达更复杂的类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Cart&lt;T&gt; = &#123;list:T[]&#125; | T[];</span><br><span class=\"line\"><span class=\"keyword\">let</span> c1:Cart&lt;<span class=\"built_in\">string</span>&gt; = &#123;list:[<span class=\"string\">'1'</span>]&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c2:Cart&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型接口-vs-泛型类型别名\"><a href=\"#泛型接口-vs-泛型类型别名\" class=\"headerlink\" title=\"泛型接口 vs 泛型类型别名\"></a>泛型接口 vs 泛型类型别名</h3><ul>\n<li>接口创建了一个新的名字，它可以在其他任意地方被调用。而类型别名并不创建新的名字，例如报错信息就不会使用别名</li>\n<li>类型别名不能被 extends和 implements,这时我们应该尽量使用接口代替类型别名</li>\n<li>当我们需要使用联合类型或者元组类型的时候，类型别名会更合适</li>\n</ul>\n"},{"title":"typescript类型申明、保护、命名空间","author":"lz_allen","date":"2020-05-26T12:50:49.000Z","_content":"\n## 结构类型系统\n\n### 接口的兼容性\n\n```typescript\n- 如果传入的变量和声明的类型不匹配，TS就会进行兼容性检查\n- 原理是Duck-Check,就是说只要目标类型中声明的属性变量在源类型中都存在就是兼容的\n\ninterface Animal {\n    name: string;\n    age: number;\n}\n\ninterface Person {\n    name: string;\n    age: number;\n    gender: number\n}\n// 要判断目标类型`Person`是否能够兼容输入的源类型`Animal`\nfunction getName(animal: Animal): string {\n    return animal.name;\n}\n\nlet p = {\n    name: 'zf',\n    age: 10,\n    gender: 0\n}\n\ngetName(p);\n//只有在传参的时候两个变量之间才会进行兼容性的比较，赋值的时候并不会比较,会直接报错\nlet a: Animal = {\n    name: 'zf',\n    age: 10,\n    gender: 0\n}\n```\n\n### 基本类型的兼容性\n\n```typescript\n//基本数据类型也有兼容性判断\nlet num : string|number;\nlet str:string='zf';\nnum = str;\n\n//只要有toString()方法就可以赋给字符串变量\nlet num2 : {\n  toString():string\n}\n\nlet str2:string='jiagou';\nnum2 = str2;\n```\n\n### 类的兼容性\n\n在TS中是结构类型系统，只会对比结构而不在意类型\n\n```typescript\nclass Animal{\n    name:string\n}\nclass Bird extends Animal{\n   swing:number\n}\n\nlet a:Animal;\na = new Bird();\n\nlet b:Bird;\n//并不是父类兼容子类，子类不兼容父类\nb = new Animal();\n\nclass Animal{\n  name:string\n}\n//如果父类和子类结构一样，也可以的\nclass Bird extends Animal{}\n\nlet a:Animal;\na = new Bird();\n\nlet b:Bird;\nb = new Animal();\n\n//甚至没有关系的两个类的实例也是可以的\nclass Animal{\n  name:string\n}\nclass Bird{\n  name:string\n}\nlet a:Animal ;\na = new Bird();\nlet b:Bird;\nb = new Animal();\n```\n\n### 函数的兼容性\n\n比较函数的时候是要先比较函数的参数，再比较函数的返回值\n\n#### 比较参数\n\n```typescript\ntype sumFunc = (a:number,b:number)=>number;\nlet sum:sumFunc;\nfunction f1(a:number,b:number):number{\n  return a+b;\n}\nsum = f1;\n\n//可以省略一个参数\nfunction f2(a:number):number{\n   return a;\n}\nsum = f2;\n\n//可以省略二个参数\nfunction f3():number{\n    return 0;\n}\nsum = f3;\n\n //多一个参数可不行\nfunction f4(a:number,b:number,c:number){\n    return a+b+c;\n}\nsum = f4;\n```\n\n#### 比较返回值\n\n```typescript\ntype GetPerson = ()=>{name:string,age:number};\nlet getPerson:GetPerson;\n//返回值一样可以\nfunction g1(){\n    return {name:'zf',age:10};\n}\ngetPerson = g1;\n//返回值多一个属性也可以\nfunction g2(){\n    return {name:'zf',age:10,gender:'male'};\n}\ngetPerson = g2;\n//返回值少一个属性可不行\nfunction g3(){\n    return {name:'zf'};\n}\ngetPerson = g3;\n//因为有可能要调用返回值上的方法\ngetPerson().age.toFixed();\n```\n\n### 函数参数的协变\n\n当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功\n\n```TYPESCRIPT\n\"strictFunctionTypes\": false\nlet sourceFunc = (args: number | string) => { }\nlet target1Func = (args: number | string) => { }\nlet target2Func = (args: number | string | boolean) => { }\nsourceFunc = target1Func;\nsourceFunc = target2Func;\n\ninterface Event {\n    timestamp: number;\n}\n\ninterface MouseEvent extends Event {\n    eventX: number;\n    eventY: number;\n}\n\ninterface KeyEvent extends Event {\n    keyCode: number;\n}\n\nfunction addEventListener(eventType: EventType, handler: (n: Event) => void) { }\n\naddEventListener(EventType.Mouse, (e: MouseEvent) => console.log(e.eventX + ', ' + e.eventY));\naddEventListener(EventType.Mouse, <(e: Event) => void>((e: MouseEvent) => console.log(e.eventX + ', ' + e.eventY)));\n```\n\n### 泛型的兼容性\n\n泛型在判断兼容性的时候会先判断具体的类型,然后再进行兼容性判断\n\n1. 接口内容为空没用到泛型的时候是可以的\n\n```typescript\ninterface Empty<T>{}\nlet x!:Empty<string>;\nlet y!:Empty<number>;\nx = y;\n```\n\n2. 接口内容不为空的时候不可以\n\n```typescript\ninterface NotEmpty<T>{\n  data:T\n}\nlet x1!:NotEmpty<string>;\nlet y1!:NotEmpty<number>;\nx1 = y1;\n\n//实现原理如下,称判断具体的类型再判断兼容性\ninterface NotEmptyString{\n    data:string\n}\n\ninterface NotEmptyNumber{\n    data:number\n}\nlet xx2!:NotEmptyString;\nlet yy2!:NotEmptyNumber;\nxx2 = yy2;\n```\n\n### 枚举的兼容性\n\n- 枚举类型与数字类型兼容，并且数字类型与枚举类型兼容\n- 不同枚举类型之间是不兼容的\n\n//数字可以赋给枚举\n\n```typescript\nenum Colors {Red,Yellow}\nlet c:Colors;\nc = Colors.Red;\nc = 1;\nc = '1';\n\n//枚举值可以赋给数字\nlet n:number;\nn = 1;\nn = Colors.Red;\n```\n\n## 类型保护\n\n- 类型保护就是一些表达式，他们在编译的时候就能通过类型信息确保某个作用域内变量的类型\n- 类型保护就是能够通过关键字判断出分支中的类型\n\n### typeof 类型保护\n\n```typescript\nfunction double(input: string | number | boolean) {\n    if (typeof input === 'string') {\n        return input + input;\n    } else {\n        if (typeof input === 'number') {\n            return input * 2;\n        } else {\n            return !input;\n        }\n    }\n}\n```\n\n### instanceof类型保护\n\n```typescript\nclass Animal {\n    name!: string;\n}\nclass Bird extends Animal {\n    swing!: number\n}\nfunction getName(animal: Animal) {\n    if (animal instanceof Bird) {\n        console.log(animal.swing);\n    } else {\n        console.log(animal.name);\n    }\n}\n```\n\n### null保护\n\n如果开启了strictNullChecks选项，那么对于可能为null的变量不能调用它上面的方法和属性\n\n```typescript\nfunction getFirstLetter(s: string | null) {\n    //第一种方式是加上null判断\n    if (s == null) {\n        return '';\n    }\n    //第二种处理是增加一个或的处理\n    s = s || '';\n    return s.charAt(0);\n}\n//它并不能处理一些复杂的判断，需要加非空断言操作符\nfunction getFirstLetter2(s: string | null) {\n    function log() {\n        console.log(s!.trim());\n    }\n    s = s || '';\n    log();\n    return s.charAt(0);\n}\n```\n\n### 链判断运算符\n\n- 链判断运算符是一种先检查属性是否存在，再尝试访问该属性的运算符，其符号为 ?.\n- 如果运算符左侧的操作数 ?. 计算为 undefined 或 null，则表达式求值为 undefined 。否则，正常触发目标属性访问，方法或函数调用。\n- 链判断运算符 还处于 stage1 阶段,TS 也暂时不支持\n\n```typescript\na?.b; //如果a是null/undefined,那么返回undefined，否则返回a.b的值.\na == null ? undefined : a.b;\n\na?.[x]; //如果a是null/undefined,那么返回undefined，否则返回a[x]的值\na == null ? undefined : a[x];\n\na?.b(); // 如果a是null/undefined,那么返回undefined\na == null ? undefined : a.b(); //如果a.b不函数的话抛类型错误异常,否则计算a.b()的结果\n\na?.(); //如果a是null/undefined,那么返回undefined\na == null ? undefined : a(); //如果A不是函数会抛出类型错误\n//否则 调用a这个函数\n```\n\n### 可辨识的联合类型\n\n- 就是利用联合类型中的共有字段进行类型保护的一种技巧\n- 相同字段的不同取值就是可辨识\n\n```typescript\ninterface WarningButton{\n  class:'warning',\n  text1:'修改'\n}\ninterface DangerButton{\n  class:'danger',\n  text2:'删除'\n}\ntype Button = WarningButton|DangerButton;\nfunction getButton(button:Button){\n if(button.class=='warning'){\n  console.log(button.text1);\n }\n if(button.class=='danger'){\n  console.log(button.text2);\n }\n}\n```\n\n### in操作符\n\nin 运算符可以被用于参数类型的判断\n\n```typescript\ninterface Bird {\n    swing: number;\n}\n\ninterface Dog {\n    leg: number;\n}\n\nfunction getNumber(x: Bird | Dog) {\n    if (\"swing\" in x) {\n      return x.swing;\n    }\n    return x.leg;\n}\n```\n\n### 自定义的类型保护\n\n- TypeScript 里的类型保护本质上就是一些表达式，它们会在运行时检查类型信息，以确保在某个作用域里的类型是符合预期的\n- type is Type1Class就是类型谓词\n- 谓词为 parameterName is Type这种形式,parameterName必须是来自于当前函数签名里的一个参数名\n- 每当使用一些变量调用isType1时，如果原始类型兼容，TypeScript会将该变量缩小到该特定类型\n\n```typescript\nfunction isType1(type: Type1Class | Type2Class): type is Type1Class {\n    return (<Type1Class>type).func1 !== undefined;\n}\ninterface Bird {\n  swing: number;\n}\n\ninterface Dog {\n  leg: number;\n}\n\n//没有相同字段可以定义一个类型保护函数\nfunction isBird(x:Bird|Dog): x is Bird{\n  return (<Bird>x).swing == 2;\n  //return (x as Bird).swing == 2;\n}\n\nfunction getAnimal(x: Bird | Dog) {\n  if (isBird(x)) {\n    return x.swing;\n  }\n  return x.leg;\n}\n```\n\n### unknown\n\n- TypeScript 3.0 引入了新的unknown 类型，它是 any 类型对应的安全类型\n- unknown 和 any 的主要区别是 unknown 类型会更加严格：在对 unknown 类型的值执行大多数操作之前，我们必须进行某种形式的检查。而在对 any 类型的值执行操作之前，我们不必进行任何检查\n\n#### any 类型\n\n- 在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的 顶级类型 (也被称作 全局超级类型)。\n- TypeScript允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查\n\n```typescript\nlet value: any;\n\nvalue = true;             // OK\nvalue = 42;               // OK\nvalue = \"Hello World\";    // OK\nvalue = [];               // OK\nvalue = {};               // OK\nvalue = Math.random;      // OK\nvalue = null;             // OK\nvalue = undefined;        // OK\n\n\nlet value: any;\nvalue.foo.bar;  // OK\nvalue.trim();   // OK\nvalue();        // OK\nnew value();    // OK\n```\n\n#### unknown 类型\n\n- 就像所有类型都可以被归为 any，所有类型也都可以被归为 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）\n- 任何类型都可以赋值给unknown类型\n- `unknown`类型只能被赋值给`any`类型和`unknown`类型本身\n\n```typescript\nlet value: unknown;\nvalue = true; // OK\nvalue = 42; // OK\nvalue = \"Hello World\"; // OK\nvalue = []; // OK\nvalue = {}; // OK\nvalue = Math.random; // OK\nvalue = null; // OK\nvalue = undefined; // OK\nvalue = new TypeError(); // OK\n```\n\n```typescript\nlet value: unknown;\n\nlet value1: unknown = value;   // OK\nlet value2: any = value;       // OK\nlet value3: boolean = value;   // Error\nlet value4: number = value;    // Error\nlet value5: string = value;    // Error\nlet value6: object = value;    // Error\nlet value7: any[] = value;     // Error\nlet value8: Function = value;  // Error\n```\n\n### 缩小 unknown 类型范围\n\n- 如果没有类型断言或类型细化时，不能在unknown上面进行任何操作\n- typeof\n- instanceof\n- 自定义类型保护函数\n- 可以对 unknown 类型使用类型断言\n\n```typescript\nconst value: unknown = \"Hello World\";\nconst someString: string = value as string;\n```\n\n### 联合类型中的 unknown 类型\n\n在联合类型中，unknown 类型会吸收任何类型。这就意味着如果任一组成类型是 unknown，联合类型也会相当于 unknown：\n\n```typescript\ntype UnionType1 = unknown | null;       // unknown\ntype UnionType2 = unknown | undefined;  // unknown\ntype UnionType3 = unknown | string;     // unknown\ntype UnionType4 = unknown | number[];   // unknown\n```\n\n### 交叉类型中的 unknown 类型\n\n在交叉类型中，任何类型都可以吸收 unknown 类型。这意味着将任何类型与 unknown 相交不会改变结果类型\n\n```typescript\ntype IntersectionType1 = unknown & null;       // null\ntype IntersectionType2 = unknown & undefined;  // undefined\ntype IntersectionType3 = unknown & string;     // string\ntype IntersectionType4 = unknown & number[];   // number[]\ntype IntersectionType5 = unknown & any;        // any\n// never是unknown的子类型\ntype isNever = never extends unknown ? true : false;\n// keyof unknown 等于never\ntype key = keyof unknown;\n// 只能对unknown进行等或不等操作，不能进行其它操作\nun1===un2;\nun1!==un2;\nun1 += un2;\n// 不能做任何操作\n// 不能访问属性\n// 不能作为函数调用\n// 不能当作类的构造函数不能创建实例\nun.name\nun();\nnew un();\n```\n\n### 映射属性\n\n- 如果映射类型遍历的时候是unknown,不会映射属性\n\n```typescript\ntype getType<T> = {\n  [P in keyof T]:number\n}\ntype t = getType<unknown>;\n```\n\n## 类型变换\n\n### 交叉类型\n\n- 交叉类型（Intersection Types）表示将多个类型合并为一个类型\n  \n```typescript\ninterface Bird {\n    name: string,\n    fly(): void\n}\ninterface Person {\n    name: string,\n    talk(): void\n}\ntype BirdPerson = Bird & Person;\nlet p: BirdPerson = { name: 'zf', fly() { }, talk() { } };\np.fly;\np.name\np.talk;\n```\n\n### typeof\n\n- 可以获取一个变量的类型\n- 先定义类型，再定义变量\n\n```typescript\ntype People = {\n    name:string,\n    age:number,\n    gender:string\n}\nlet p1:People = {\n    name:'zf',\n    age:10,\n    gender:'male'\n}\n//先定义变量，再定义类型\nlet p1 = {\n    name:'zf',\n    age:10,\n    gender:'male'\n}\ntype People = typeof p1;\nfunction getName(p:People):string{\n    return p.name;\n}\ngetName(p1);\n```\n\n### 索引访问操作符\n\n- 可以通过[]获取一个类型的子类型\n\n```typescript\ninterface Person{\n    name:string;\n    age:number;\n    job:{\n        name:string\n    };\n    interests:{name:string,level:number}[]\n}\nlet FrontEndJob:Person['job'] = {\n    name:'前端工程师'\n}\nlet interestLevel:Person['interests'][0]['level'] = 2;\n```\n\n### keyof\n\n- 索引类型查询操作符\n\n```typescript\ninterface Person{\n  name:string;\n  age:number;\n  gender:'male'|'female';\n}\n//type PersonKey = 'name'|'age'|'gender';\ntype PersonKey = keyof Person;\n\nfunction getValueByKey(p:Person,key:PersonKey){\n  return p[key];\n}\nlet val = getValueByKey({name:'zf',age:10,gender:'male'},'name');\nconsole.log(val);\n```\n\n### 映射类型\n\n- 在定义的时候用in操作符去批量定义类型中的属性\n\n```typescript\ninterface Person{\n  name:string;\n  age:number;\n  gender:'male'|'female';\n}\n//批量把一个接口中的属性都变成可选的\ntype PartPerson = {\n  [Key in keyof Person]?:Person[Key]\n}\n\nlet p1:PartPerson={};\n//也可以使用泛型\ntype Part<T> = {\n  [key in keyof T]?:T[key]\n}\nlet p2:Part<Person>={};\n```\n\n### 内置工具类型\n\n- TS 中内置了一些工具类型来帮助我们更好地使用类型系统\n  \n符号| 含义\n+?|变为可远\n->|变为必选\n\n#### Partial\n\n- Partial 可以将传入的属性由非可选变为可选，具体使用如下：\n\n```typescript\ntype Partial<T> = { [P in keyof T]?: T[P] };\ninterface A {\n  a1: string;\n  a2: number;\n  a3: boolean;\n}\ntype aPartial = Partial<A>;\nconst a: aPartial = {}; // 不会报错\n```\n\n#### Required\n\n- Required 可以将传入的属性中的可选项变为必选项，这里用了 -? 修饰符来实现。\n\n```typescript\n//type Required<T> = { [P in keyof T]-?: T[P] };\n\ninterface Person{\n  name:string;\n  age:number;\n  gender?:'male'|'female';\n}\n/**\n * type Require<T> = { [P in keyof T]-?: T[P] };\n */\nlet p:Required<Person> = {\n  name:'zf',\n  age:10,\n  //gender:'male'\n}\n```\n\n#### Readonly\n\n- Readonly 通过为传入的属性每一项都加上 readonly 修饰符来实现。\n\n```typescript\ninterface Person{\n  name:string;\n  age:number;\n  gender?:'male'|'female';\n}\n//type Readonly<T> = { readonly [P in keyof T]: T[P] };\nlet p:Readonly<Person> = {\n  name:'zf',\n  age:10,\n  gender:'male'\n}\np.age = 11;\n```\n\n#### Pick\n\n- Pick 能够帮助我们从传入的属性中摘取某一项返回\n\n```typescript\ninterface Animal {\n  name: string;\n  age: number;\n  gender:number\n}\n/**\n * From T pick a set of properties K\n * type Pick<T, K extends keyof T> = { [P in K]: T[P] };\n */\n// 摘取 Animal 中的 name 属性\ninterface Person {\n    name: string;\n    age: number;\n    married: boolean\n}\nfunction pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n    const result: any = {};\n    keys.map(key => {\n        result[key] = obj[key];\n    });\n    return result\n}\nlet person: Person = { name: 'zf', age: 10, married: true };\nlet result: Pick<Person, 'name' | 'age'> = pick<Person, 'name' | 'age'>(person, ['name', 'age']);\nconsole.log(result);\n```\n\n#### Record\n\n```typescript\nfunction mapObject<K extends string | number, T, U>(obj: Record<K, T>, map: (x: T) => U): Record<K, U> {\n    let result: any = {};\n    for (const key in obj) {\n        result[key] = map(obj[key]);\n    }\n    return result;\n}\nlet names = { 0: 'hello', 1: 'world' };\nlet lengths = mapObject<string | number, string, number>(names, (s: string) => s.length);\nconsole.log(lengths);//{ '0': 5, '1': 5 }\n```\n\n#### Proxy\n\n```typescript\ntype Proxy<T> = {\n    get(): T;\n    set(value: T): void;\n}\ntype Proxify<T> = {\n    [P in keyof T]: Proxy<T[P]>\n}\nfunction proxify<T>(obj: T): Proxify<T> {\n    let result = {} as Proxify<T>;\n    for (const key in obj) {\n        result[key] = {\n            get: () => obj[key],\n            set: (value) => obj[key] = value\n        }\n    }\n    return result;\n}\nlet props = {\n    name: 'zf',\n    age: 10\n}\nlet proxyProps = proxify(props);\nconsole.log(proxyProps);\n\nfunction unProxify<T>(t: Proxify<T>): T {\n    let result = {} as T;\n    for (const k in t) {\n        result[k] = t[k].get();\n    }\n    return result;\n}\n\nlet originProps = unProxify(proxyProps);\nconsole.log(originProps);\n```\n\n### 映射类型修饰符的控制\n\n- TypeScript中增加了对映射类型修饰符的控制\n- 具体而言，一个 readonly 或 ? 修饰符在一个映射类型里可以用前缀 + 或-来表示这个修饰符应该被添加或移除\n- TS 中部分内置工具类型就利用了这个特性（Partial、Required、Readonly...），这里我们可以参考 Partial、Required 的实现\n\n## 条件类型\n\n- 在定义泛型的时候能够添加进逻辑分支，以后泛型更加灵活\nutility-types\n\n### 定义条件类型\n\n```typescript\ninterface Fish {\n    name: string\n}\ninterface Water {\n    name: string\n}\ninterface Bird {\n    name: string\n}\ninterface Sky {\n    name: string\n}\n//三元运算符\ntype Condition<T> = T extends Fish ? Water : Sky;\nlet condition: Condition<Fish> = { name: '水' };\n```\n\n### 条件类型的分发\n\n```typescript\ninterface Fish {\n    fish: string\n}\ninterface Water {\n    water: string\n}\ninterface Bird {\n    bird: string\n}\ninterface Sky {\n    sky: string\n}\n\ntype Condition<T> = T extends Fish ? Water : Sky;\n//(Fish extends Fish ? Water : Sky) | (Bird extends Fish ? Water : Sky)\n// Water|Sky\nlet condition1: Condition<Fish | Bird> = { water: '水' };\nlet condition2: Condition<Fish | Bird> = { sky: '天空' };\n```\n\n### 内置条件类型\n\n- TS 在内置了一些常用的条件类型，可以在 lib.es5.d.ts 中查看：\n- infer最早出现在此 PR 中，表示在 extends 条件语句中待推断的类型变量\n\n#### Exclude\n\n- 从 T 可分配给的类型中排除 U `js type Exclude<T, U> = T extends U ? never : T;\n\n```typescript\ntype E = Exclude<string|number,string>; let e:E = 10;\n```\n\n#### Extract<T, U>\n\n- 从 T 可分配的类型中提取 U\n\n```typescript\ntype Extract<T, U> = T extends U ? T : never;\n\ntype  E = Extract<string|number,string>;\nlet e:E = '1';\n```\n\n#### NonNullable\n\n- 从 T 中排除 null 和 undefined\n\n```typescript\ntype NonNullable<T> = T extends null | undefined ? never : T;\ntype  E = NonNullable<string|number|null|undefined>;\nlet e:E = null;\n```\n\n#### ReturnType\n\n- 获取函数类型的返回类型\n\n```typescript\nfunction getUserInfo() {\n  return { name: \"zf\", age: 10 };\n}\n\n// 通过 ReturnType 将 getUserInfo 的返回值类型赋给了 UserInfo\ntype UserInfo = ReturnType<typeof getUserInfo>;\n\nconst userA: UserInfo = {\n  name: \"zf\",\n  age: 10\n};\n\ntype ReturnType2<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : any;\ntype AnyFunction = (...args: any[]) => any;\ntype ReturnType2<T extends AnyFunction> = T extends (...args: any[]) => infer R ? R : any\n```\n\n#### Parameters\n\nConstructs a tuple type of the types of the parameters of a function type T\nParameters\n\n```typescrript\ndeclare function f1(arg: { a: number, b: string }): void\ntype T0 = Parameters2<() => string>;  // []\ntype T1 = Parameters2<(s: string) => void>;  // [string]\ntype T2 = Parameters2<(<T>(arg: T) => T)>;  // [unknown]\ntype AnyFunction = (...args: any[]) => any;\n//type ReturnType2<T extends AnyFunction> = T extends (...args: any[]) => infer R ? R : any;\ntype Parameters2<T extends AnyFunction> = T extends (...args: infer R) => any ? R : any;\n```\n\n#### InstanceType\n\n- 获取构造函数类型的实例类型\n- InstanceType\n\n```typescript\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    getName() { console.log(this.name) }\n}\ntype constructorParameters = ConstructorParameters<typeof Person>;\nlet params: constructorParameters = ['zf']\ntype Instance = InstanceType<typeof Person>;\nlet instance: Instance = { name: 'zf', getName() { } };\ntype Constructor = new (...args: any[]) => any;\ntype ConstructorParameters<T extends Constructor> = T extends new (...args: infer P) => any ? P : never;\ntype InstanceType<T extends Constructor> = T extends new (...args: any[]) => infer R ? R : any;\n```\n\n#### infer\n\n- typescript_zh\n- codesandbox\n\n```typescript\ntype ElementType<T> = T extends any[] ? T[number] : T;\ntype e1 = ElementType<string[]>;\ntype e2 = ElementType<string>;\ntype GetElementType<T> = T extends Array<infer U> ? U : T;\ntype e3 = GetElementType<string[]>;\ntype e4 = GetElementType<string>;\n\ninterface Action<T> {\n    payload?: T\n    type: string\n}\n\nclass EffectModule {\n  count = 1;\n  message = \"hello!\";\n  delay(input: Promise<number>) {\n      return input.then(i => ({\n          payload: `hello ${i}!`,\n          type: 'delay'\n      });\n  }\n  setMessage(action: Action<Date>) {\n    return {\n        payload: action.payload!.getMilliseconds(),\n        type: \"set-message\"\n    };\n  }\n}\n\ntype FuncName<T> = {\n    [P in keyof T]: T[P] extends Function ? P : never;\n}[keyof T];\ntype ts = FuncName<EffectModule>;\ntype Connect = (module: EffectModule) => { [T in FuncName<EffectModule>]: EffectModule[T] }\n\n\ntype TransformResultType<RT> = {\n    [s in keyof RT]:\n    RT[s] extends (input: Promise<infer T>) => Promise<Action<infer U>> ?\n    (input: T) => Action<U> : (\n        RT[s] extends (action: Action<infer T>) => Action<infer U> ? (action: T) => Action<U> : never\n    )\n}\ntype connectedResultType = ReturnType<Connect>;\ntype result = TransformResultType<connectedResultType>\nexport { };\n```\n\n## 模块VS命名空间\n\n### 模块\n\n- 模块是TS中外部模块的简称，侧重于代码和复用\n- 模块在期自身的作用域里执行，而不是在全局作用域里\n- 一个模块里的变量、函数、类等在外部是不可见的，除非你把它导出\n- 如果想要使用一个模块里导出的变量，则需要导入\n\n```typescript\nexport const a = 1;\nexport const b = 2;\nexport default 'zf';\nimport name, { a, b } from './1';\nconsole.log(name, a, b);\n```\n\n## 命名空间\n\n- 在代码量较大的情况下，为了避免命名空间冲突，可以将相似的函数、类、接口放置到命名空间内\n- 命名空间可以将代码包裹起来，只对外暴露需要在外部访问的对象，命名空间内通过export向外导出\n- 命名空间是内部模块，主要用于组织代码，避免命名冲突\n\n### 内部划分\n\n```typescript\nexport namespace zoo {\n    export class Dog { eat() { console.log('zoo dog'); } }\n}\nexport namespace home {\n    export class Dog { eat() { console.log('home dog'); } }\n}\nlet dog_of_zoo = new zoo.Dog();\ndog_of_zoo.eat();\nlet dog_of_home = new home.Dog();\ndog_of_home.eat();\nimport { zoo } from './3';\nlet dog_of_zoo = new zoo.Dog();\ndog_of_zoo.eat();\n```\n\n## 类型声明\n\n- 声明文件可以让我们不需要将JS重构为TS，只需要加上声明文件就可以使用系统\n- 类型声明在编译的时候都会被删除，不会影响真正的代码\n\n### 普通类型声明\n\n```typescript\ndeclare const $: (selector: string) => { //变量\n    click(): void;\n    width(length: number): void;\n};\n$('#root').click();\nconsole.log($('#root').width);\ndeclare let name: string;  //变量\ndeclare let age: number;  //变量\ndeclare function getName(): string;  //方法\ndeclare class Animal { name: string }  //类\nconsole.log(name, age);\ngetName();\nnew Animal();\nexport default {};\n```\n\n### 外部枚举\n\n- 外部枚举是使用declare enum定义的枚举类型\n- 外部枚举用来描述已经存在的枚举类型的形状\n\n```typescript\ndeclare enum Seasons {\n    Spring,\n    Summer,\n    Autumn,\n    Winter\n}\n\nlet seasons = [\n    Seasons.Spring,\n    Seasons.Summer,\n    Seasons.Autumn,\n    Seasons.Winter\n];\ndeclare 定义的类型只会用于编译时的检查，编译结果中会被删除。上例的编译结果如下\n\nvar seasons = [\n    Seasons.Spring,\n    Seasons.Summer,\n    Seasons.Autumn,\n    Seasons.Winter\n];\n\n// 也可以同时使用declare 和 const\n\ndeclare const enum Seasons {\n    Spring,\n    Summer,\n    Autumn,\n    Winter\n}\n\nlet seasons = [\n    Seasons.Spring,\n    Seasons.Summer,\n    Seasons.Autumn,\n    Seasons.Winter\n];\n\n//编译结果\n\nvar seasons = [\n    0 /* Spring */,\n    1 /* Summer */,\n    2 /* Autumn */,\n    3 /* Winter */\n];\n```\n\n## namespace\n\n- 如果一个全局变量包括了很多子属性，可能使用namespace\n- 在声明文件中的namespace表示一个全局变量包含很多子属性\n- 在命名空间内部不需要使用 declare 声明属性或方法\n\n```typescript\ndeclare namespace ${\n    function ajax(url:string,settings:any):void;\n    let name:string;\n    namespace fn {\n        function extend(object:any):void;\n    }\n}\n$.ajax('/api/users',{});\n$.fn.extend({\n    log:function(message:any){\n        console.log(message);\n    }\n});\nexport {};\n```\n\n### 类型声明文件\n\n- 我们可以把类型声明放在一个单独的类型声明文件中\n- 可以在类型声明文件中使用类型声明\n- 文件命名规范为*.d.ts\n- 观看类型声明文件有助于了解库的使用方式\n\n#### jquery.d.ts\n\ntypings\\jquery.d.ts\n\n```typescript\ndeclare const $:(selector:string)=>{\n    click():void;\n    width(length:number):void;\n}\n```\n\n### tsconfig.json\n\ntsconfig.json\n\n```typescript\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"ES2015\",  \n    \"outDir\":\"lib\"\n  },\n  \"include\": [\n    \"src/**/*\",\n    \"typings/**/*\"\n  ]\n}\n```\n\n#### test.js\n\nsrc\\test.ts\n\n```typescript\n$('#button').click();\n$('#button').width(100);\nexport {};\n```\n\n## 第三方声明文件\n\n- 可以安装使用第三方的声明文件\n- @types是一个约定的前缀，所有的第三方声明的类型库都会带有这样的前缀\n- JavaScript 中有很多内置对象，它们可以在 TypeScript 中被当做声明好了的类型\n- 内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准\n- 这些内置对象的类型声明文件，就包含在TypeScript 核心库的类型声明文件中\n\n### 使用jquery\n\ncnpm i jquery -S\n对于common.js风格的模块必须使用 import * as \nimport * as jQuery from 'jquery';\njQuery.ajax('/user/1');\n\n### 安装声明文件\n\ncnpm i @types/jquery -S\n\n### 自己编写声明文件\n\n- 模块查找规则\n- `node_modules\\@types\\jquery/index.d.ts\n- 我们可以自己编写声明文件并配置tsconfig.json\n\n```typescript\n// index.d.ts\n// types\\jquery\\index.d.ts\n\ndeclare function jQuery(selector:string):HTMLElement;\ndeclare namespace jQuery{\n  function ajax(url:string):void\n}\nexport default jQuery;\n```\n \n### tsconfig.json\n\n- 如果配置了paths,那么在引入包的的时候会自动去paths目录里找类型声明文件\n- 在 tsconfig.json 中，我们通过 compilerOptions 里的 paths 属性来配置路径映射\n- paths是模块名到基于baseUrl的路径映射的列表\n\n```typescript\n{\n\"baseUrl\": \"./\",// 使用 paths 属性的话必须要指定 baseUrl 的值\n\"paths\": {\n\"*\":[\"types/*\"]\n}\n```\n\n### npm声明文件可能的位置\n\nnode_modules/jquery/package.json\n\"types\":\"types/xxx.d.ts\"\nnode_modules/jquery/index.d.ts\nnode_modules/@types/jquery/index.d.ts\n\n### 扩展全局变量的类型\n\n#### 扩展局部变量类型\n\n```typescript\ndeclare var String: StringConstructor;\ninterface StringConstructor {\n    new(value?: any): String;\n    (value?: any): string;\n    readonly prototype: String;\n}\ninterface String {\n    toString(): string;\n}\n//扩展类的原型\ninterface String {\n    double():string;\n}\n\nString.prototype.double = function(){\n    return this+'+'+this;\n}\nconsole.log('hello'.double());\n\n//扩展类的实例\ninterface Window{\n    myname:string\n}\nconsole.log(window.myname);\n//export {} 没有导出就是全局扩展\n```\n\n### 模块内全局扩展\n\ntypes\\global\\index.d.ts\n\n```typescript\ndeclare global{\n    interface String {\n        double():string;\n    }\n    interface Window{\n        myname:string\n    }\n}\n\nexport  {}\n```\n\n## 合并声明\n\n- 同一名称的两个独立声明会被合并成一个单一声明\n- 合并后的声明拥有原先两个声明的特性  \n\n关键字|作为类型使用|作为值使用\nclass|yes|yes\nenum|yes|yes\ninterface|yes|no\ntype|yes|no\nfunction|no|yes\nvar,let,const|no|yes\n\n- 类既可以作为类型使用，也可以作为值使用，接口只能作为类型使用\n\n```typescript\n\nclass Person{\n    name:string=''\n}\nlet p1:Person;//作为类型使用\nlet p2 = new Person();//作为值使用\n\ninterface Animal{\n    name:string\n}\nlet a1:Animal;\nlet a2 = Animal;//接口类型不能用作值\n```\n\n### 合并类型声明\n\n- 可以通过接口合并的特性给一个第三方为扩展类型声明\nuse.js\n\n```typescript\ninterface Animal{\n    name:string\n}\nlet a1:Animal={name:'zf',age:10};\nconsole.log(a1.name);\nconsole.log(a1.age);\n//注意不要加export {} ,这是全局的\ntypes\\animal\\index.d.ts\n\ninterface Animal{\n    age:number\n}\n```\n\n###  使用命名空间扩展类\n\n- 我们可以使用 namespace 来扩展类，用于表示内部类\n\n```typescript\nclass Form {\n  username: Form.Item='';\n  password: Form.Item='';\n}\n//Item为Form的内部类\nnamespace Form {\n  export class Item {}\n}\nlet item:Form.Item = new Form.Item();\nconsole.log(item);\n```\n\n### 使用命名空间扩展函数\n\n- 我们也可以使用 namespace 来扩展函数\n\n```typescript\nfunction greeting(name: string): string {\n    return greeting.words+name;\n}\n\nnamespace greeting {\n    export let words = \"Hello,\";\n}\nconsole.log(greeting('zf'))\n```\n\n### 使用命名空间扩展枚举类型\n\n```typescript\nenum Color {\n    red = 1,\n    yellow = 2,\n    blue = 3\n}\n\nnamespace Color {\n    export const green=4;\n    export const purple=5;\n}\nconsole.log(Color.green)\n```\n\n### 扩展Store\n\n```typescript\nimport { createStore, Store } from 'redux';\ntype StoreExt = Store & {\n    ext: string\n}\nlet store: StoreExt = createStore(state => state);\nstore.ext = 'hello';\n```\n\n### 生成声明文件\n\n- 把TS编译成JS后丢失类型声明，我们可以在编译的时候自动生成一份JS文件\n\n```typescript\n{\n  \"compilerOptions\": {\n     \"declaration\": true, /* Generates corresponding '.d.ts' file.*/\n  }\n}\n```\n","source":"_posts/page/typescript类型申明、保护、命名空间.md","raw":"---\ntitle: typescript类型申明、保护、命名空间\ncategories: web前端\nauthor: lz_allen\ntags:\n  - typescript\ndate: 2020-05-26 20:50:49\n---\n\n## 结构类型系统\n\n### 接口的兼容性\n\n```typescript\n- 如果传入的变量和声明的类型不匹配，TS就会进行兼容性检查\n- 原理是Duck-Check,就是说只要目标类型中声明的属性变量在源类型中都存在就是兼容的\n\ninterface Animal {\n    name: string;\n    age: number;\n}\n\ninterface Person {\n    name: string;\n    age: number;\n    gender: number\n}\n// 要判断目标类型`Person`是否能够兼容输入的源类型`Animal`\nfunction getName(animal: Animal): string {\n    return animal.name;\n}\n\nlet p = {\n    name: 'zf',\n    age: 10,\n    gender: 0\n}\n\ngetName(p);\n//只有在传参的时候两个变量之间才会进行兼容性的比较，赋值的时候并不会比较,会直接报错\nlet a: Animal = {\n    name: 'zf',\n    age: 10,\n    gender: 0\n}\n```\n\n### 基本类型的兼容性\n\n```typescript\n//基本数据类型也有兼容性判断\nlet num : string|number;\nlet str:string='zf';\nnum = str;\n\n//只要有toString()方法就可以赋给字符串变量\nlet num2 : {\n  toString():string\n}\n\nlet str2:string='jiagou';\nnum2 = str2;\n```\n\n### 类的兼容性\n\n在TS中是结构类型系统，只会对比结构而不在意类型\n\n```typescript\nclass Animal{\n    name:string\n}\nclass Bird extends Animal{\n   swing:number\n}\n\nlet a:Animal;\na = new Bird();\n\nlet b:Bird;\n//并不是父类兼容子类，子类不兼容父类\nb = new Animal();\n\nclass Animal{\n  name:string\n}\n//如果父类和子类结构一样，也可以的\nclass Bird extends Animal{}\n\nlet a:Animal;\na = new Bird();\n\nlet b:Bird;\nb = new Animal();\n\n//甚至没有关系的两个类的实例也是可以的\nclass Animal{\n  name:string\n}\nclass Bird{\n  name:string\n}\nlet a:Animal ;\na = new Bird();\nlet b:Bird;\nb = new Animal();\n```\n\n### 函数的兼容性\n\n比较函数的时候是要先比较函数的参数，再比较函数的返回值\n\n#### 比较参数\n\n```typescript\ntype sumFunc = (a:number,b:number)=>number;\nlet sum:sumFunc;\nfunction f1(a:number,b:number):number{\n  return a+b;\n}\nsum = f1;\n\n//可以省略一个参数\nfunction f2(a:number):number{\n   return a;\n}\nsum = f2;\n\n//可以省略二个参数\nfunction f3():number{\n    return 0;\n}\nsum = f3;\n\n //多一个参数可不行\nfunction f4(a:number,b:number,c:number){\n    return a+b+c;\n}\nsum = f4;\n```\n\n#### 比较返回值\n\n```typescript\ntype GetPerson = ()=>{name:string,age:number};\nlet getPerson:GetPerson;\n//返回值一样可以\nfunction g1(){\n    return {name:'zf',age:10};\n}\ngetPerson = g1;\n//返回值多一个属性也可以\nfunction g2(){\n    return {name:'zf',age:10,gender:'male'};\n}\ngetPerson = g2;\n//返回值少一个属性可不行\nfunction g3(){\n    return {name:'zf'};\n}\ngetPerson = g3;\n//因为有可能要调用返回值上的方法\ngetPerson().age.toFixed();\n```\n\n### 函数参数的协变\n\n当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功\n\n```TYPESCRIPT\n\"strictFunctionTypes\": false\nlet sourceFunc = (args: number | string) => { }\nlet target1Func = (args: number | string) => { }\nlet target2Func = (args: number | string | boolean) => { }\nsourceFunc = target1Func;\nsourceFunc = target2Func;\n\ninterface Event {\n    timestamp: number;\n}\n\ninterface MouseEvent extends Event {\n    eventX: number;\n    eventY: number;\n}\n\ninterface KeyEvent extends Event {\n    keyCode: number;\n}\n\nfunction addEventListener(eventType: EventType, handler: (n: Event) => void) { }\n\naddEventListener(EventType.Mouse, (e: MouseEvent) => console.log(e.eventX + ', ' + e.eventY));\naddEventListener(EventType.Mouse, <(e: Event) => void>((e: MouseEvent) => console.log(e.eventX + ', ' + e.eventY)));\n```\n\n### 泛型的兼容性\n\n泛型在判断兼容性的时候会先判断具体的类型,然后再进行兼容性判断\n\n1. 接口内容为空没用到泛型的时候是可以的\n\n```typescript\ninterface Empty<T>{}\nlet x!:Empty<string>;\nlet y!:Empty<number>;\nx = y;\n```\n\n2. 接口内容不为空的时候不可以\n\n```typescript\ninterface NotEmpty<T>{\n  data:T\n}\nlet x1!:NotEmpty<string>;\nlet y1!:NotEmpty<number>;\nx1 = y1;\n\n//实现原理如下,称判断具体的类型再判断兼容性\ninterface NotEmptyString{\n    data:string\n}\n\ninterface NotEmptyNumber{\n    data:number\n}\nlet xx2!:NotEmptyString;\nlet yy2!:NotEmptyNumber;\nxx2 = yy2;\n```\n\n### 枚举的兼容性\n\n- 枚举类型与数字类型兼容，并且数字类型与枚举类型兼容\n- 不同枚举类型之间是不兼容的\n\n//数字可以赋给枚举\n\n```typescript\nenum Colors {Red,Yellow}\nlet c:Colors;\nc = Colors.Red;\nc = 1;\nc = '1';\n\n//枚举值可以赋给数字\nlet n:number;\nn = 1;\nn = Colors.Red;\n```\n\n## 类型保护\n\n- 类型保护就是一些表达式，他们在编译的时候就能通过类型信息确保某个作用域内变量的类型\n- 类型保护就是能够通过关键字判断出分支中的类型\n\n### typeof 类型保护\n\n```typescript\nfunction double(input: string | number | boolean) {\n    if (typeof input === 'string') {\n        return input + input;\n    } else {\n        if (typeof input === 'number') {\n            return input * 2;\n        } else {\n            return !input;\n        }\n    }\n}\n```\n\n### instanceof类型保护\n\n```typescript\nclass Animal {\n    name!: string;\n}\nclass Bird extends Animal {\n    swing!: number\n}\nfunction getName(animal: Animal) {\n    if (animal instanceof Bird) {\n        console.log(animal.swing);\n    } else {\n        console.log(animal.name);\n    }\n}\n```\n\n### null保护\n\n如果开启了strictNullChecks选项，那么对于可能为null的变量不能调用它上面的方法和属性\n\n```typescript\nfunction getFirstLetter(s: string | null) {\n    //第一种方式是加上null判断\n    if (s == null) {\n        return '';\n    }\n    //第二种处理是增加一个或的处理\n    s = s || '';\n    return s.charAt(0);\n}\n//它并不能处理一些复杂的判断，需要加非空断言操作符\nfunction getFirstLetter2(s: string | null) {\n    function log() {\n        console.log(s!.trim());\n    }\n    s = s || '';\n    log();\n    return s.charAt(0);\n}\n```\n\n### 链判断运算符\n\n- 链判断运算符是一种先检查属性是否存在，再尝试访问该属性的运算符，其符号为 ?.\n- 如果运算符左侧的操作数 ?. 计算为 undefined 或 null，则表达式求值为 undefined 。否则，正常触发目标属性访问，方法或函数调用。\n- 链判断运算符 还处于 stage1 阶段,TS 也暂时不支持\n\n```typescript\na?.b; //如果a是null/undefined,那么返回undefined，否则返回a.b的值.\na == null ? undefined : a.b;\n\na?.[x]; //如果a是null/undefined,那么返回undefined，否则返回a[x]的值\na == null ? undefined : a[x];\n\na?.b(); // 如果a是null/undefined,那么返回undefined\na == null ? undefined : a.b(); //如果a.b不函数的话抛类型错误异常,否则计算a.b()的结果\n\na?.(); //如果a是null/undefined,那么返回undefined\na == null ? undefined : a(); //如果A不是函数会抛出类型错误\n//否则 调用a这个函数\n```\n\n### 可辨识的联合类型\n\n- 就是利用联合类型中的共有字段进行类型保护的一种技巧\n- 相同字段的不同取值就是可辨识\n\n```typescript\ninterface WarningButton{\n  class:'warning',\n  text1:'修改'\n}\ninterface DangerButton{\n  class:'danger',\n  text2:'删除'\n}\ntype Button = WarningButton|DangerButton;\nfunction getButton(button:Button){\n if(button.class=='warning'){\n  console.log(button.text1);\n }\n if(button.class=='danger'){\n  console.log(button.text2);\n }\n}\n```\n\n### in操作符\n\nin 运算符可以被用于参数类型的判断\n\n```typescript\ninterface Bird {\n    swing: number;\n}\n\ninterface Dog {\n    leg: number;\n}\n\nfunction getNumber(x: Bird | Dog) {\n    if (\"swing\" in x) {\n      return x.swing;\n    }\n    return x.leg;\n}\n```\n\n### 自定义的类型保护\n\n- TypeScript 里的类型保护本质上就是一些表达式，它们会在运行时检查类型信息，以确保在某个作用域里的类型是符合预期的\n- type is Type1Class就是类型谓词\n- 谓词为 parameterName is Type这种形式,parameterName必须是来自于当前函数签名里的一个参数名\n- 每当使用一些变量调用isType1时，如果原始类型兼容，TypeScript会将该变量缩小到该特定类型\n\n```typescript\nfunction isType1(type: Type1Class | Type2Class): type is Type1Class {\n    return (<Type1Class>type).func1 !== undefined;\n}\ninterface Bird {\n  swing: number;\n}\n\ninterface Dog {\n  leg: number;\n}\n\n//没有相同字段可以定义一个类型保护函数\nfunction isBird(x:Bird|Dog): x is Bird{\n  return (<Bird>x).swing == 2;\n  //return (x as Bird).swing == 2;\n}\n\nfunction getAnimal(x: Bird | Dog) {\n  if (isBird(x)) {\n    return x.swing;\n  }\n  return x.leg;\n}\n```\n\n### unknown\n\n- TypeScript 3.0 引入了新的unknown 类型，它是 any 类型对应的安全类型\n- unknown 和 any 的主要区别是 unknown 类型会更加严格：在对 unknown 类型的值执行大多数操作之前，我们必须进行某种形式的检查。而在对 any 类型的值执行操作之前，我们不必进行任何检查\n\n#### any 类型\n\n- 在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的 顶级类型 (也被称作 全局超级类型)。\n- TypeScript允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查\n\n```typescript\nlet value: any;\n\nvalue = true;             // OK\nvalue = 42;               // OK\nvalue = \"Hello World\";    // OK\nvalue = [];               // OK\nvalue = {};               // OK\nvalue = Math.random;      // OK\nvalue = null;             // OK\nvalue = undefined;        // OK\n\n\nlet value: any;\nvalue.foo.bar;  // OK\nvalue.trim();   // OK\nvalue();        // OK\nnew value();    // OK\n```\n\n#### unknown 类型\n\n- 就像所有类型都可以被归为 any，所有类型也都可以被归为 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）\n- 任何类型都可以赋值给unknown类型\n- `unknown`类型只能被赋值给`any`类型和`unknown`类型本身\n\n```typescript\nlet value: unknown;\nvalue = true; // OK\nvalue = 42; // OK\nvalue = \"Hello World\"; // OK\nvalue = []; // OK\nvalue = {}; // OK\nvalue = Math.random; // OK\nvalue = null; // OK\nvalue = undefined; // OK\nvalue = new TypeError(); // OK\n```\n\n```typescript\nlet value: unknown;\n\nlet value1: unknown = value;   // OK\nlet value2: any = value;       // OK\nlet value3: boolean = value;   // Error\nlet value4: number = value;    // Error\nlet value5: string = value;    // Error\nlet value6: object = value;    // Error\nlet value7: any[] = value;     // Error\nlet value8: Function = value;  // Error\n```\n\n### 缩小 unknown 类型范围\n\n- 如果没有类型断言或类型细化时，不能在unknown上面进行任何操作\n- typeof\n- instanceof\n- 自定义类型保护函数\n- 可以对 unknown 类型使用类型断言\n\n```typescript\nconst value: unknown = \"Hello World\";\nconst someString: string = value as string;\n```\n\n### 联合类型中的 unknown 类型\n\n在联合类型中，unknown 类型会吸收任何类型。这就意味着如果任一组成类型是 unknown，联合类型也会相当于 unknown：\n\n```typescript\ntype UnionType1 = unknown | null;       // unknown\ntype UnionType2 = unknown | undefined;  // unknown\ntype UnionType3 = unknown | string;     // unknown\ntype UnionType4 = unknown | number[];   // unknown\n```\n\n### 交叉类型中的 unknown 类型\n\n在交叉类型中，任何类型都可以吸收 unknown 类型。这意味着将任何类型与 unknown 相交不会改变结果类型\n\n```typescript\ntype IntersectionType1 = unknown & null;       // null\ntype IntersectionType2 = unknown & undefined;  // undefined\ntype IntersectionType3 = unknown & string;     // string\ntype IntersectionType4 = unknown & number[];   // number[]\ntype IntersectionType5 = unknown & any;        // any\n// never是unknown的子类型\ntype isNever = never extends unknown ? true : false;\n// keyof unknown 等于never\ntype key = keyof unknown;\n// 只能对unknown进行等或不等操作，不能进行其它操作\nun1===un2;\nun1!==un2;\nun1 += un2;\n// 不能做任何操作\n// 不能访问属性\n// 不能作为函数调用\n// 不能当作类的构造函数不能创建实例\nun.name\nun();\nnew un();\n```\n\n### 映射属性\n\n- 如果映射类型遍历的时候是unknown,不会映射属性\n\n```typescript\ntype getType<T> = {\n  [P in keyof T]:number\n}\ntype t = getType<unknown>;\n```\n\n## 类型变换\n\n### 交叉类型\n\n- 交叉类型（Intersection Types）表示将多个类型合并为一个类型\n  \n```typescript\ninterface Bird {\n    name: string,\n    fly(): void\n}\ninterface Person {\n    name: string,\n    talk(): void\n}\ntype BirdPerson = Bird & Person;\nlet p: BirdPerson = { name: 'zf', fly() { }, talk() { } };\np.fly;\np.name\np.talk;\n```\n\n### typeof\n\n- 可以获取一个变量的类型\n- 先定义类型，再定义变量\n\n```typescript\ntype People = {\n    name:string,\n    age:number,\n    gender:string\n}\nlet p1:People = {\n    name:'zf',\n    age:10,\n    gender:'male'\n}\n//先定义变量，再定义类型\nlet p1 = {\n    name:'zf',\n    age:10,\n    gender:'male'\n}\ntype People = typeof p1;\nfunction getName(p:People):string{\n    return p.name;\n}\ngetName(p1);\n```\n\n### 索引访问操作符\n\n- 可以通过[]获取一个类型的子类型\n\n```typescript\ninterface Person{\n    name:string;\n    age:number;\n    job:{\n        name:string\n    };\n    interests:{name:string,level:number}[]\n}\nlet FrontEndJob:Person['job'] = {\n    name:'前端工程师'\n}\nlet interestLevel:Person['interests'][0]['level'] = 2;\n```\n\n### keyof\n\n- 索引类型查询操作符\n\n```typescript\ninterface Person{\n  name:string;\n  age:number;\n  gender:'male'|'female';\n}\n//type PersonKey = 'name'|'age'|'gender';\ntype PersonKey = keyof Person;\n\nfunction getValueByKey(p:Person,key:PersonKey){\n  return p[key];\n}\nlet val = getValueByKey({name:'zf',age:10,gender:'male'},'name');\nconsole.log(val);\n```\n\n### 映射类型\n\n- 在定义的时候用in操作符去批量定义类型中的属性\n\n```typescript\ninterface Person{\n  name:string;\n  age:number;\n  gender:'male'|'female';\n}\n//批量把一个接口中的属性都变成可选的\ntype PartPerson = {\n  [Key in keyof Person]?:Person[Key]\n}\n\nlet p1:PartPerson={};\n//也可以使用泛型\ntype Part<T> = {\n  [key in keyof T]?:T[key]\n}\nlet p2:Part<Person>={};\n```\n\n### 内置工具类型\n\n- TS 中内置了一些工具类型来帮助我们更好地使用类型系统\n  \n符号| 含义\n+?|变为可远\n->|变为必选\n\n#### Partial\n\n- Partial 可以将传入的属性由非可选变为可选，具体使用如下：\n\n```typescript\ntype Partial<T> = { [P in keyof T]?: T[P] };\ninterface A {\n  a1: string;\n  a2: number;\n  a3: boolean;\n}\ntype aPartial = Partial<A>;\nconst a: aPartial = {}; // 不会报错\n```\n\n#### Required\n\n- Required 可以将传入的属性中的可选项变为必选项，这里用了 -? 修饰符来实现。\n\n```typescript\n//type Required<T> = { [P in keyof T]-?: T[P] };\n\ninterface Person{\n  name:string;\n  age:number;\n  gender?:'male'|'female';\n}\n/**\n * type Require<T> = { [P in keyof T]-?: T[P] };\n */\nlet p:Required<Person> = {\n  name:'zf',\n  age:10,\n  //gender:'male'\n}\n```\n\n#### Readonly\n\n- Readonly 通过为传入的属性每一项都加上 readonly 修饰符来实现。\n\n```typescript\ninterface Person{\n  name:string;\n  age:number;\n  gender?:'male'|'female';\n}\n//type Readonly<T> = { readonly [P in keyof T]: T[P] };\nlet p:Readonly<Person> = {\n  name:'zf',\n  age:10,\n  gender:'male'\n}\np.age = 11;\n```\n\n#### Pick\n\n- Pick 能够帮助我们从传入的属性中摘取某一项返回\n\n```typescript\ninterface Animal {\n  name: string;\n  age: number;\n  gender:number\n}\n/**\n * From T pick a set of properties K\n * type Pick<T, K extends keyof T> = { [P in K]: T[P] };\n */\n// 摘取 Animal 中的 name 属性\ninterface Person {\n    name: string;\n    age: number;\n    married: boolean\n}\nfunction pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n    const result: any = {};\n    keys.map(key => {\n        result[key] = obj[key];\n    });\n    return result\n}\nlet person: Person = { name: 'zf', age: 10, married: true };\nlet result: Pick<Person, 'name' | 'age'> = pick<Person, 'name' | 'age'>(person, ['name', 'age']);\nconsole.log(result);\n```\n\n#### Record\n\n```typescript\nfunction mapObject<K extends string | number, T, U>(obj: Record<K, T>, map: (x: T) => U): Record<K, U> {\n    let result: any = {};\n    for (const key in obj) {\n        result[key] = map(obj[key]);\n    }\n    return result;\n}\nlet names = { 0: 'hello', 1: 'world' };\nlet lengths = mapObject<string | number, string, number>(names, (s: string) => s.length);\nconsole.log(lengths);//{ '0': 5, '1': 5 }\n```\n\n#### Proxy\n\n```typescript\ntype Proxy<T> = {\n    get(): T;\n    set(value: T): void;\n}\ntype Proxify<T> = {\n    [P in keyof T]: Proxy<T[P]>\n}\nfunction proxify<T>(obj: T): Proxify<T> {\n    let result = {} as Proxify<T>;\n    for (const key in obj) {\n        result[key] = {\n            get: () => obj[key],\n            set: (value) => obj[key] = value\n        }\n    }\n    return result;\n}\nlet props = {\n    name: 'zf',\n    age: 10\n}\nlet proxyProps = proxify(props);\nconsole.log(proxyProps);\n\nfunction unProxify<T>(t: Proxify<T>): T {\n    let result = {} as T;\n    for (const k in t) {\n        result[k] = t[k].get();\n    }\n    return result;\n}\n\nlet originProps = unProxify(proxyProps);\nconsole.log(originProps);\n```\n\n### 映射类型修饰符的控制\n\n- TypeScript中增加了对映射类型修饰符的控制\n- 具体而言，一个 readonly 或 ? 修饰符在一个映射类型里可以用前缀 + 或-来表示这个修饰符应该被添加或移除\n- TS 中部分内置工具类型就利用了这个特性（Partial、Required、Readonly...），这里我们可以参考 Partial、Required 的实现\n\n## 条件类型\n\n- 在定义泛型的时候能够添加进逻辑分支，以后泛型更加灵活\nutility-types\n\n### 定义条件类型\n\n```typescript\ninterface Fish {\n    name: string\n}\ninterface Water {\n    name: string\n}\ninterface Bird {\n    name: string\n}\ninterface Sky {\n    name: string\n}\n//三元运算符\ntype Condition<T> = T extends Fish ? Water : Sky;\nlet condition: Condition<Fish> = { name: '水' };\n```\n\n### 条件类型的分发\n\n```typescript\ninterface Fish {\n    fish: string\n}\ninterface Water {\n    water: string\n}\ninterface Bird {\n    bird: string\n}\ninterface Sky {\n    sky: string\n}\n\ntype Condition<T> = T extends Fish ? Water : Sky;\n//(Fish extends Fish ? Water : Sky) | (Bird extends Fish ? Water : Sky)\n// Water|Sky\nlet condition1: Condition<Fish | Bird> = { water: '水' };\nlet condition2: Condition<Fish | Bird> = { sky: '天空' };\n```\n\n### 内置条件类型\n\n- TS 在内置了一些常用的条件类型，可以在 lib.es5.d.ts 中查看：\n- infer最早出现在此 PR 中，表示在 extends 条件语句中待推断的类型变量\n\n#### Exclude\n\n- 从 T 可分配给的类型中排除 U `js type Exclude<T, U> = T extends U ? never : T;\n\n```typescript\ntype E = Exclude<string|number,string>; let e:E = 10;\n```\n\n#### Extract<T, U>\n\n- 从 T 可分配的类型中提取 U\n\n```typescript\ntype Extract<T, U> = T extends U ? T : never;\n\ntype  E = Extract<string|number,string>;\nlet e:E = '1';\n```\n\n#### NonNullable\n\n- 从 T 中排除 null 和 undefined\n\n```typescript\ntype NonNullable<T> = T extends null | undefined ? never : T;\ntype  E = NonNullable<string|number|null|undefined>;\nlet e:E = null;\n```\n\n#### ReturnType\n\n- 获取函数类型的返回类型\n\n```typescript\nfunction getUserInfo() {\n  return { name: \"zf\", age: 10 };\n}\n\n// 通过 ReturnType 将 getUserInfo 的返回值类型赋给了 UserInfo\ntype UserInfo = ReturnType<typeof getUserInfo>;\n\nconst userA: UserInfo = {\n  name: \"zf\",\n  age: 10\n};\n\ntype ReturnType2<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : any;\ntype AnyFunction = (...args: any[]) => any;\ntype ReturnType2<T extends AnyFunction> = T extends (...args: any[]) => infer R ? R : any\n```\n\n#### Parameters\n\nConstructs a tuple type of the types of the parameters of a function type T\nParameters\n\n```typescrript\ndeclare function f1(arg: { a: number, b: string }): void\ntype T0 = Parameters2<() => string>;  // []\ntype T1 = Parameters2<(s: string) => void>;  // [string]\ntype T2 = Parameters2<(<T>(arg: T) => T)>;  // [unknown]\ntype AnyFunction = (...args: any[]) => any;\n//type ReturnType2<T extends AnyFunction> = T extends (...args: any[]) => infer R ? R : any;\ntype Parameters2<T extends AnyFunction> = T extends (...args: infer R) => any ? R : any;\n```\n\n#### InstanceType\n\n- 获取构造函数类型的实例类型\n- InstanceType\n\n```typescript\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    getName() { console.log(this.name) }\n}\ntype constructorParameters = ConstructorParameters<typeof Person>;\nlet params: constructorParameters = ['zf']\ntype Instance = InstanceType<typeof Person>;\nlet instance: Instance = { name: 'zf', getName() { } };\ntype Constructor = new (...args: any[]) => any;\ntype ConstructorParameters<T extends Constructor> = T extends new (...args: infer P) => any ? P : never;\ntype InstanceType<T extends Constructor> = T extends new (...args: any[]) => infer R ? R : any;\n```\n\n#### infer\n\n- typescript_zh\n- codesandbox\n\n```typescript\ntype ElementType<T> = T extends any[] ? T[number] : T;\ntype e1 = ElementType<string[]>;\ntype e2 = ElementType<string>;\ntype GetElementType<T> = T extends Array<infer U> ? U : T;\ntype e3 = GetElementType<string[]>;\ntype e4 = GetElementType<string>;\n\ninterface Action<T> {\n    payload?: T\n    type: string\n}\n\nclass EffectModule {\n  count = 1;\n  message = \"hello!\";\n  delay(input: Promise<number>) {\n      return input.then(i => ({\n          payload: `hello ${i}!`,\n          type: 'delay'\n      });\n  }\n  setMessage(action: Action<Date>) {\n    return {\n        payload: action.payload!.getMilliseconds(),\n        type: \"set-message\"\n    };\n  }\n}\n\ntype FuncName<T> = {\n    [P in keyof T]: T[P] extends Function ? P : never;\n}[keyof T];\ntype ts = FuncName<EffectModule>;\ntype Connect = (module: EffectModule) => { [T in FuncName<EffectModule>]: EffectModule[T] }\n\n\ntype TransformResultType<RT> = {\n    [s in keyof RT]:\n    RT[s] extends (input: Promise<infer T>) => Promise<Action<infer U>> ?\n    (input: T) => Action<U> : (\n        RT[s] extends (action: Action<infer T>) => Action<infer U> ? (action: T) => Action<U> : never\n    )\n}\ntype connectedResultType = ReturnType<Connect>;\ntype result = TransformResultType<connectedResultType>\nexport { };\n```\n\n## 模块VS命名空间\n\n### 模块\n\n- 模块是TS中外部模块的简称，侧重于代码和复用\n- 模块在期自身的作用域里执行，而不是在全局作用域里\n- 一个模块里的变量、函数、类等在外部是不可见的，除非你把它导出\n- 如果想要使用一个模块里导出的变量，则需要导入\n\n```typescript\nexport const a = 1;\nexport const b = 2;\nexport default 'zf';\nimport name, { a, b } from './1';\nconsole.log(name, a, b);\n```\n\n## 命名空间\n\n- 在代码量较大的情况下，为了避免命名空间冲突，可以将相似的函数、类、接口放置到命名空间内\n- 命名空间可以将代码包裹起来，只对外暴露需要在外部访问的对象，命名空间内通过export向外导出\n- 命名空间是内部模块，主要用于组织代码，避免命名冲突\n\n### 内部划分\n\n```typescript\nexport namespace zoo {\n    export class Dog { eat() { console.log('zoo dog'); } }\n}\nexport namespace home {\n    export class Dog { eat() { console.log('home dog'); } }\n}\nlet dog_of_zoo = new zoo.Dog();\ndog_of_zoo.eat();\nlet dog_of_home = new home.Dog();\ndog_of_home.eat();\nimport { zoo } from './3';\nlet dog_of_zoo = new zoo.Dog();\ndog_of_zoo.eat();\n```\n\n## 类型声明\n\n- 声明文件可以让我们不需要将JS重构为TS，只需要加上声明文件就可以使用系统\n- 类型声明在编译的时候都会被删除，不会影响真正的代码\n\n### 普通类型声明\n\n```typescript\ndeclare const $: (selector: string) => { //变量\n    click(): void;\n    width(length: number): void;\n};\n$('#root').click();\nconsole.log($('#root').width);\ndeclare let name: string;  //变量\ndeclare let age: number;  //变量\ndeclare function getName(): string;  //方法\ndeclare class Animal { name: string }  //类\nconsole.log(name, age);\ngetName();\nnew Animal();\nexport default {};\n```\n\n### 外部枚举\n\n- 外部枚举是使用declare enum定义的枚举类型\n- 外部枚举用来描述已经存在的枚举类型的形状\n\n```typescript\ndeclare enum Seasons {\n    Spring,\n    Summer,\n    Autumn,\n    Winter\n}\n\nlet seasons = [\n    Seasons.Spring,\n    Seasons.Summer,\n    Seasons.Autumn,\n    Seasons.Winter\n];\ndeclare 定义的类型只会用于编译时的检查，编译结果中会被删除。上例的编译结果如下\n\nvar seasons = [\n    Seasons.Spring,\n    Seasons.Summer,\n    Seasons.Autumn,\n    Seasons.Winter\n];\n\n// 也可以同时使用declare 和 const\n\ndeclare const enum Seasons {\n    Spring,\n    Summer,\n    Autumn,\n    Winter\n}\n\nlet seasons = [\n    Seasons.Spring,\n    Seasons.Summer,\n    Seasons.Autumn,\n    Seasons.Winter\n];\n\n//编译结果\n\nvar seasons = [\n    0 /* Spring */,\n    1 /* Summer */,\n    2 /* Autumn */,\n    3 /* Winter */\n];\n```\n\n## namespace\n\n- 如果一个全局变量包括了很多子属性，可能使用namespace\n- 在声明文件中的namespace表示一个全局变量包含很多子属性\n- 在命名空间内部不需要使用 declare 声明属性或方法\n\n```typescript\ndeclare namespace ${\n    function ajax(url:string,settings:any):void;\n    let name:string;\n    namespace fn {\n        function extend(object:any):void;\n    }\n}\n$.ajax('/api/users',{});\n$.fn.extend({\n    log:function(message:any){\n        console.log(message);\n    }\n});\nexport {};\n```\n\n### 类型声明文件\n\n- 我们可以把类型声明放在一个单独的类型声明文件中\n- 可以在类型声明文件中使用类型声明\n- 文件命名规范为*.d.ts\n- 观看类型声明文件有助于了解库的使用方式\n\n#### jquery.d.ts\n\ntypings\\jquery.d.ts\n\n```typescript\ndeclare const $:(selector:string)=>{\n    click():void;\n    width(length:number):void;\n}\n```\n\n### tsconfig.json\n\ntsconfig.json\n\n```typescript\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"target\": \"ES2015\",  \n    \"outDir\":\"lib\"\n  },\n  \"include\": [\n    \"src/**/*\",\n    \"typings/**/*\"\n  ]\n}\n```\n\n#### test.js\n\nsrc\\test.ts\n\n```typescript\n$('#button').click();\n$('#button').width(100);\nexport {};\n```\n\n## 第三方声明文件\n\n- 可以安装使用第三方的声明文件\n- @types是一个约定的前缀，所有的第三方声明的类型库都会带有这样的前缀\n- JavaScript 中有很多内置对象，它们可以在 TypeScript 中被当做声明好了的类型\n- 内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准\n- 这些内置对象的类型声明文件，就包含在TypeScript 核心库的类型声明文件中\n\n### 使用jquery\n\ncnpm i jquery -S\n对于common.js风格的模块必须使用 import * as \nimport * as jQuery from 'jquery';\njQuery.ajax('/user/1');\n\n### 安装声明文件\n\ncnpm i @types/jquery -S\n\n### 自己编写声明文件\n\n- 模块查找规则\n- `node_modules\\@types\\jquery/index.d.ts\n- 我们可以自己编写声明文件并配置tsconfig.json\n\n```typescript\n// index.d.ts\n// types\\jquery\\index.d.ts\n\ndeclare function jQuery(selector:string):HTMLElement;\ndeclare namespace jQuery{\n  function ajax(url:string):void\n}\nexport default jQuery;\n```\n \n### tsconfig.json\n\n- 如果配置了paths,那么在引入包的的时候会自动去paths目录里找类型声明文件\n- 在 tsconfig.json 中，我们通过 compilerOptions 里的 paths 属性来配置路径映射\n- paths是模块名到基于baseUrl的路径映射的列表\n\n```typescript\n{\n\"baseUrl\": \"./\",// 使用 paths 属性的话必须要指定 baseUrl 的值\n\"paths\": {\n\"*\":[\"types/*\"]\n}\n```\n\n### npm声明文件可能的位置\n\nnode_modules/jquery/package.json\n\"types\":\"types/xxx.d.ts\"\nnode_modules/jquery/index.d.ts\nnode_modules/@types/jquery/index.d.ts\n\n### 扩展全局变量的类型\n\n#### 扩展局部变量类型\n\n```typescript\ndeclare var String: StringConstructor;\ninterface StringConstructor {\n    new(value?: any): String;\n    (value?: any): string;\n    readonly prototype: String;\n}\ninterface String {\n    toString(): string;\n}\n//扩展类的原型\ninterface String {\n    double():string;\n}\n\nString.prototype.double = function(){\n    return this+'+'+this;\n}\nconsole.log('hello'.double());\n\n//扩展类的实例\ninterface Window{\n    myname:string\n}\nconsole.log(window.myname);\n//export {} 没有导出就是全局扩展\n```\n\n### 模块内全局扩展\n\ntypes\\global\\index.d.ts\n\n```typescript\ndeclare global{\n    interface String {\n        double():string;\n    }\n    interface Window{\n        myname:string\n    }\n}\n\nexport  {}\n```\n\n## 合并声明\n\n- 同一名称的两个独立声明会被合并成一个单一声明\n- 合并后的声明拥有原先两个声明的特性  \n\n关键字|作为类型使用|作为值使用\nclass|yes|yes\nenum|yes|yes\ninterface|yes|no\ntype|yes|no\nfunction|no|yes\nvar,let,const|no|yes\n\n- 类既可以作为类型使用，也可以作为值使用，接口只能作为类型使用\n\n```typescript\n\nclass Person{\n    name:string=''\n}\nlet p1:Person;//作为类型使用\nlet p2 = new Person();//作为值使用\n\ninterface Animal{\n    name:string\n}\nlet a1:Animal;\nlet a2 = Animal;//接口类型不能用作值\n```\n\n### 合并类型声明\n\n- 可以通过接口合并的特性给一个第三方为扩展类型声明\nuse.js\n\n```typescript\ninterface Animal{\n    name:string\n}\nlet a1:Animal={name:'zf',age:10};\nconsole.log(a1.name);\nconsole.log(a1.age);\n//注意不要加export {} ,这是全局的\ntypes\\animal\\index.d.ts\n\ninterface Animal{\n    age:number\n}\n```\n\n###  使用命名空间扩展类\n\n- 我们可以使用 namespace 来扩展类，用于表示内部类\n\n```typescript\nclass Form {\n  username: Form.Item='';\n  password: Form.Item='';\n}\n//Item为Form的内部类\nnamespace Form {\n  export class Item {}\n}\nlet item:Form.Item = new Form.Item();\nconsole.log(item);\n```\n\n### 使用命名空间扩展函数\n\n- 我们也可以使用 namespace 来扩展函数\n\n```typescript\nfunction greeting(name: string): string {\n    return greeting.words+name;\n}\n\nnamespace greeting {\n    export let words = \"Hello,\";\n}\nconsole.log(greeting('zf'))\n```\n\n### 使用命名空间扩展枚举类型\n\n```typescript\nenum Color {\n    red = 1,\n    yellow = 2,\n    blue = 3\n}\n\nnamespace Color {\n    export const green=4;\n    export const purple=5;\n}\nconsole.log(Color.green)\n```\n\n### 扩展Store\n\n```typescript\nimport { createStore, Store } from 'redux';\ntype StoreExt = Store & {\n    ext: string\n}\nlet store: StoreExt = createStore(state => state);\nstore.ext = 'hello';\n```\n\n### 生成声明文件\n\n- 把TS编译成JS后丢失类型声明，我们可以在编译的时候自动生成一份JS文件\n\n```typescript\n{\n  \"compilerOptions\": {\n     \"declaration\": true, /* Generates corresponding '.d.ts' file.*/\n  }\n}\n```\n","slug":"page/typescript类型申明、保护、命名空间","published":1,"updated":"2020-08-14T10:20:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdydrm4u00014tiva9gp6vry","content":"<h2 id=\"结构类型系统\"><a href=\"#结构类型系统\" class=\"headerlink\" title=\"结构类型系统\"></a>结构类型系统</h2><h3 id=\"接口的兼容性\"><a href=\"#接口的兼容性\" class=\"headerlink\" title=\"接口的兼容性\"></a>接口的兼容性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">- 如果传入的变量和声明的类型不匹配，TS就会进行兼容性检查</span><br><span class=\"line\">- 原理是Duck-Check,就是说只要目标类型中声明的属性变量在源类型中都存在就是兼容的</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Animal &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    gender: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 要判断目标类型`Person`是否能够兼容输入的源类型`Animal`</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">animal: Animal</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> animal.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'zf'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">10</span>,</span><br><span class=\"line\">    gender: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getName(p);</span><br><span class=\"line\"><span class=\"comment\">//只有在传参的时候两个变量之间才会进行兼容性的比较，赋值的时候并不会比较,会直接报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: Animal = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'zf'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">10</span>,</span><br><span class=\"line\">    gender: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本类型的兼容性\"><a href=\"#基本类型的兼容性\" class=\"headerlink\" title=\"基本类型的兼容性\"></a>基本类型的兼容性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本数据类型也有兼容性判断</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num : <span class=\"built_in\">string</span>|<span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> str:<span class=\"built_in\">string</span>=<span class=\"string\">'zf'</span>;</span><br><span class=\"line\">num = str;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//只要有toString()方法就可以赋给字符串变量</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num2 : &#123;</span><br><span class=\"line\">  toString():<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> str2:<span class=\"built_in\">string</span>=<span class=\"string\">'jiagou'</span>;</span><br><span class=\"line\">num2 = str2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类的兼容性\"><a href=\"#类的兼容性\" class=\"headerlink\" title=\"类的兼容性\"></a>类的兼容性</h3><p>在TS中是结构类型系统，只会对比结构而不在意类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Bird <span class=\"keyword\">extends</span> Animal&#123;</span><br><span class=\"line\">   swing:<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a:Animal;</span><br><span class=\"line\">a = <span class=\"keyword\">new</span> Bird();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b:Bird;</span><br><span class=\"line\"><span class=\"comment\">//并不是父类兼容子类，子类不兼容父类</span></span><br><span class=\"line\">b = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果父类和子类结构一样，也可以的</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Bird <span class=\"keyword\">extends</span> Animal&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a:Animal;</span><br><span class=\"line\">a = <span class=\"keyword\">new</span> Bird();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b:Bird;</span><br><span class=\"line\">b = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//甚至没有关系的两个类的实例也是可以的</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Bird&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a:Animal ;</span><br><span class=\"line\">a = <span class=\"keyword\">new</span> Bird();</span><br><span class=\"line\"><span class=\"keyword\">let</span> b:Bird;</span><br><span class=\"line\">b = <span class=\"keyword\">new</span> Animal();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数的兼容性\"><a href=\"#函数的兼容性\" class=\"headerlink\" title=\"函数的兼容性\"></a>函数的兼容性</h3><p>比较函数的时候是要先比较函数的参数，再比较函数的返回值</p>\n<h4 id=\"比较参数\"><a href=\"#比较参数\" class=\"headerlink\" title=\"比较参数\"></a>比较参数</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> sumFunc = <span class=\"function\">(<span class=\"params\">a:<span class=\"built_in\">number</span>,b:<span class=\"built_in\">number</span></span>)=&gt;</span><span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sum:sumFunc;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">a:<span class=\"built_in\">number</span>,b:<span class=\"built_in\">number</span></span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum = f1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可以省略一个参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\">a:<span class=\"built_in\">number</span></span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum = f2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可以省略二个参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f3</span>(<span class=\"params\"></span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum = f3;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//多一个参数可不行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f4</span>(<span class=\"params\">a:<span class=\"built_in\">number</span>,b:<span class=\"built_in\">number</span>,c:<span class=\"built_in\">number</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b+c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum = f4;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"比较返回值\"><a href=\"#比较返回值\" class=\"headerlink\" title=\"比较返回值\"></a>比较返回值</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> GetPerson = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> getPerson:GetPerson;</span><br><span class=\"line\"><span class=\"comment\">//返回值一样可以</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;name:<span class=\"string\">'zf'</span>,age:<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getPerson = g1;</span><br><span class=\"line\"><span class=\"comment\">//返回值多一个属性也可以</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;name:<span class=\"string\">'zf'</span>,age:<span class=\"number\">10</span>,gender:<span class=\"string\">'male'</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getPerson = g2;</span><br><span class=\"line\"><span class=\"comment\">//返回值少一个属性可不行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g3</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;name:<span class=\"string\">'zf'</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getPerson = g3;</span><br><span class=\"line\"><span class=\"comment\">//因为有可能要调用返回值上的方法</span></span><br><span class=\"line\">getPerson().age.toFixed();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数参数的协变\"><a href=\"#函数参数的协变\" class=\"headerlink\" title=\"函数参数的协变\"></a>函数参数的协变</h3><p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"strictFunctionTypes\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sourceFunc = <span class=\"function\">(<span class=\"params\">args: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) =&gt;</span> &#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> target1Func = <span class=\"function\">(<span class=\"params\">args: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) =&gt;</span> &#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> target2Func = <span class=\"function\">(<span class=\"params\">args: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span> | <span class=\"built_in\">boolean</span></span>) =&gt;</span> &#123; &#125;</span><br><span class=\"line\">sourceFunc = target1Func;</span><br><span class=\"line\">sourceFunc = target2Func;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Event &#123;</span><br><span class=\"line\">    timestamp: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> MouseEvent <span class=\"keyword\">extends</span> Event &#123;</span><br><span class=\"line\">    eventX: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    eventY: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> KeyEvent <span class=\"keyword\">extends</span> Event &#123;</span><br><span class=\"line\">    keyCode: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEventListener</span>(<span class=\"params\">eventType: EventType, handler: (n: Event) =&gt; <span class=\"built_in\">void</span></span>) </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener(EventType.Mouse, <span class=\"function\">(<span class=\"params\">e: MouseEvent</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(e.eventX + <span class=\"string\">', '</span> + e.eventY));</span><br><span class=\"line\">addEventListener(EventType.Mouse, &lt;<span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;<span class=\"function\">(<span class=\"params\">(<span class=\"params\">e: MouseEvent</span>) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"params\">e.eventX + ', ' + e.eventY</span>)</span>));</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型的兼容性\"><a href=\"#泛型的兼容性\" class=\"headerlink\" title=\"泛型的兼容性\"></a>泛型的兼容性</h3><p>泛型在判断兼容性的时候会先判断具体的类型,然后再进行兼容性判断</p>\n<ol>\n<li>接口内容为空没用到泛型的时候是可以的</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Empty&lt;T&gt;&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x!:Empty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y!:Empty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">x = y;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>接口内容不为空的时候不可以</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NotEmpty&lt;T&gt;&#123;</span><br><span class=\"line\">  data:T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x1!:NotEmpty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y1!:NotEmpty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">x1 = y1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现原理如下,称判断具体的类型再判断兼容性</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> NotEmptyString&#123;</span><br><span class=\"line\">    data:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> NotEmptyNumber&#123;</span><br><span class=\"line\">    data:<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> xx2!:NotEmptyString;</span><br><span class=\"line\"><span class=\"keyword\">let</span> yy2!:NotEmptyNumber;</span><br><span class=\"line\">xx2 = yy2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"枚举的兼容性\"><a href=\"#枚举的兼容性\" class=\"headerlink\" title=\"枚举的兼容性\"></a>枚举的兼容性</h3><ul>\n<li>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容</li>\n<li>不同枚举类型之间是不兼容的</li>\n</ul>\n<p>//数字可以赋给枚举</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Colors &#123;Red,Yellow&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c:Colors;</span><br><span class=\"line\">c = Colors.Red;</span><br><span class=\"line\">c = <span class=\"number\">1</span>;</span><br><span class=\"line\">c = <span class=\"string\">'1'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//枚举值可以赋给数字</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">n = <span class=\"number\">1</span>;</span><br><span class=\"line\">n = Colors.Red;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类型保护\"><a href=\"#类型保护\" class=\"headerlink\" title=\"类型保护\"></a>类型保护</h2><ul>\n<li>类型保护就是一些表达式，他们在编译的时候就能通过类型信息确保某个作用域内变量的类型</li>\n<li>类型保护就是能够通过关键字判断出分支中的类型</li>\n</ul>\n<h3 id=\"typeof-类型保护\"><a href=\"#typeof-类型保护\" class=\"headerlink\" title=\"typeof 类型保护\"></a>typeof 类型保护</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">input: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> input === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> input + input;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> input === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input * <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> !input;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"instanceof类型保护\"><a href=\"#instanceof类型保护\" class=\"headerlink\" title=\"instanceof类型保护\"></a>instanceof类型保护</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    name!: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Bird <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">    swing!: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">animal: Animal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (animal <span class=\"keyword\">instanceof</span> Bird) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(animal.swing);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(animal.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"null保护\"><a href=\"#null保护\" class=\"headerlink\" title=\"null保护\"></a>null保护</h3><p>如果开启了strictNullChecks选项，那么对于可能为null的变量不能调用它上面的方法和属性</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFirstLetter</span>(<span class=\"params\">s: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//第一种方式是加上null判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//第二种处理是增加一个或的处理</span></span><br><span class=\"line\">    s = s || <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//它并不能处理一些复杂的判断，需要加非空断言操作符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFirstLetter2</span>(<span class=\"params\">s: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(s!.trim());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = s || <span class=\"string\">''</span>;</span><br><span class=\"line\">    log();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"链判断运算符\"><a href=\"#链判断运算符\" class=\"headerlink\" title=\"链判断运算符\"></a>链判断运算符</h3><ul>\n<li>链判断运算符是一种先检查属性是否存在，再尝试访问该属性的运算符，其符号为 ?.</li>\n<li>如果运算符左侧的操作数 ?. 计算为 undefined 或 null，则表达式求值为 undefined 。否则，正常触发目标属性访问，方法或函数调用。</li>\n<li>链判断运算符 还处于 stage1 阶段,TS 也暂时不支持</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">a?.b; <span class=\"comment\">//如果a是null/undefined,那么返回undefined，否则返回a.b的值.</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a.b;</span><br><span class=\"line\"></span><br><span class=\"line\">a?.[x]; <span class=\"comment\">//如果a是null/undefined,那么返回undefined，否则返回a[x]的值</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a[x];</span><br><span class=\"line\"></span><br><span class=\"line\">a?.b(); <span class=\"comment\">// 如果a是null/undefined,那么返回undefined</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a.b(); <span class=\"comment\">//如果a.b不函数的话抛类型错误异常,否则计算a.b()的结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">a?.(); <span class=\"comment\">//如果a是null/undefined,那么返回undefined</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a(); <span class=\"comment\">//如果A不是函数会抛出类型错误</span></span><br><span class=\"line\"><span class=\"comment\">//否则 调用a这个函数</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可辨识的联合类型\"><a href=\"#可辨识的联合类型\" class=\"headerlink\" title=\"可辨识的联合类型\"></a>可辨识的联合类型</h3><ul>\n<li>就是利用联合类型中的共有字段进行类型保护的一种技巧</li>\n<li>相同字段的不同取值就是可辨识</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> WarningButton&#123;</span><br><span class=\"line\">  <span class=\"keyword\">class</span>:<span class=\"string\">'warning'</span>,</span><br><span class=\"line\">  text1:<span class=\"string\">'修改'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> DangerButton&#123;</span><br><span class=\"line\">  <span class=\"keyword\">class</span>:<span class=\"string\">'danger'</span>,</span><br><span class=\"line\">  text2:<span class=\"string\">'删除'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Button = WarningButton|DangerButton;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getButton</span>(<span class=\"params\">button:Button</span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(button.class==<span class=\"string\">'warning'</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(button.text1);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(button.class==<span class=\"string\">'danger'</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(button.text2);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"in操作符\"><a href=\"#in操作符\" class=\"headerlink\" title=\"in操作符\"></a>in操作符</h3><p>in 运算符可以被用于参数类型的判断</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    swing: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Dog &#123;</span><br><span class=\"line\">    leg: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNumber</span>(<span class=\"params\">x: Bird | Dog</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"swing\"</span> <span class=\"keyword\">in</span> x) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> x.swing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.leg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义的类型保护\"><a href=\"#自定义的类型保护\" class=\"headerlink\" title=\"自定义的类型保护\"></a>自定义的类型保护</h3><ul>\n<li>TypeScript 里的类型保护本质上就是一些表达式，它们会在运行时检查类型信息，以确保在某个作用域里的类型是符合预期的</li>\n<li>type is Type1Class就是类型谓词</li>\n<li>谓词为 parameterName is Type这种形式,parameterName必须是来自于当前函数签名里的一个参数名</li>\n<li>每当使用一些变量调用isType1时，如果原始类型兼容，TypeScript会将该变量缩小到该特定类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isType1</span>(<span class=\"params\"><span class=\"keyword\">type</span>: Type1Class | Type2Class</span>): <span class=\"title\">type</span> <span class=\"title\">is</span> <span class=\"title\">Type1Class</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (&lt;Type1Class&gt;<span class=\"keyword\">type</span>).func1 !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  swing: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Dog &#123;</span><br><span class=\"line\">  leg: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//没有相同字段可以定义一个类型保护函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isBird</span>(<span class=\"params\">x:Bird|Dog</span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">Bird</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (&lt;Bird&gt;x).swing == <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"comment\">//return (x as Bird).swing == 2;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAnimal</span>(<span class=\"params\">x: Bird | Dog</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isBird(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.swing;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.leg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"unknown\"><a href=\"#unknown\" class=\"headerlink\" title=\"unknown\"></a>unknown</h3><ul>\n<li>TypeScript 3.0 引入了新的unknown 类型，它是 any 类型对应的安全类型</li>\n<li>unknown 和 any 的主要区别是 unknown 类型会更加严格：在对 unknown 类型的值执行大多数操作之前，我们必须进行某种形式的检查。而在对 any 类型的值执行操作之前，我们不必进行任何检查</li>\n</ul>\n<h4 id=\"any-类型\"><a href=\"#any-类型\" class=\"headerlink\" title=\"any 类型\"></a>any 类型</h4><ul>\n<li>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的 顶级类型 (也被称作 全局超级类型)。</li>\n<li>TypeScript允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> value: <span class=\"built_in\">any</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">value = <span class=\"literal\">true</span>;             <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"number\">42</span>;               <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"string\">\"Hello World\"</span>;    <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = [];               <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = &#123;&#125;;               <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"built_in\">Math</span>.random;      <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"literal\">null</span>;             <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"literal\">undefined</span>;        <span class=\"comment\">// OK</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> value: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">value.foo.bar;  <span class=\"comment\">// OK</span></span><br><span class=\"line\">value.trim();   <span class=\"comment\">// OK</span></span><br><span class=\"line\">value();        <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> value();    <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"unknown-类型\"><a href=\"#unknown-类型\" class=\"headerlink\" title=\"unknown 类型\"></a>unknown 类型</h4><ul>\n<li>就像所有类型都可以被归为 any，所有类型也都可以被归为 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）</li>\n<li>任何类型都可以赋值给unknown类型</li>\n<li><code>unknown</code>类型只能被赋值给<code>any</code>类型和<code>unknown</code>类型本身</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> value: unknown;</span><br><span class=\"line\">value = <span class=\"literal\">true</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"number\">42</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"string\">\"Hello World\"</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = []; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = &#123;&#125;; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"built_in\">Math</span>.random; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"literal\">null</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"literal\">undefined</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> value: unknown;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> value1: unknown = value;   <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value2: <span class=\"built_in\">any</span> = value;       <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value3: <span class=\"built_in\">boolean</span> = value;   <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value4: <span class=\"built_in\">number</span> = value;    <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value5: <span class=\"built_in\">string</span> = value;    <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value6: object = value;    <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value7: <span class=\"built_in\">any</span>[] = value;     <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value8: <span class=\"built_in\">Function</span> = value;  <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"缩小-unknown-类型范围\"><a href=\"#缩小-unknown-类型范围\" class=\"headerlink\" title=\"缩小 unknown 类型范围\"></a>缩小 unknown 类型范围</h3><ul>\n<li>如果没有类型断言或类型细化时，不能在unknown上面进行任何操作</li>\n<li>typeof</li>\n<li>instanceof</li>\n<li>自定义类型保护函数</li>\n<li>可以对 unknown 类型使用类型断言</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value: unknown = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> someString: <span class=\"built_in\">string</span> = value <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"联合类型中的-unknown-类型\"><a href=\"#联合类型中的-unknown-类型\" class=\"headerlink\" title=\"联合类型中的 unknown 类型\"></a>联合类型中的 unknown 类型</h3><p>在联合类型中，unknown 类型会吸收任何类型。这就意味着如果任一组成类型是 unknown，联合类型也会相当于 unknown：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> UnionType1 = unknown | <span class=\"literal\">null</span>;       <span class=\"comment\">// unknown</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> UnionType2 = unknown | <span class=\"literal\">undefined</span>;  <span class=\"comment\">// unknown</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> UnionType3 = unknown | <span class=\"built_in\">string</span>;     <span class=\"comment\">// unknown</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> UnionType4 = unknown | <span class=\"built_in\">number</span>[];   <span class=\"comment\">// unknown</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"交叉类型中的-unknown-类型\"><a href=\"#交叉类型中的-unknown-类型\" class=\"headerlink\" title=\"交叉类型中的 unknown 类型\"></a>交叉类型中的 unknown 类型</h3><p>在交叉类型中，任何类型都可以吸收 unknown 类型。这意味着将任何类型与 unknown 相交不会改变结果类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IntersectionType1 = unknown &amp; <span class=\"literal\">null</span>;       <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IntersectionType2 = unknown &amp; <span class=\"literal\">undefined</span>;  <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IntersectionType3 = unknown &amp; <span class=\"built_in\">string</span>;     <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IntersectionType4 = unknown &amp; <span class=\"built_in\">number</span>[];   <span class=\"comment\">// number[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IntersectionType5 = unknown &amp; <span class=\"built_in\">any</span>;        <span class=\"comment\">// any</span></span><br><span class=\"line\"><span class=\"comment\">// never是unknown的子类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> isNever = never <span class=\"keyword\">extends</span> unknown ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">// keyof unknown 等于never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> key = keyof unknown;</span><br><span class=\"line\"><span class=\"comment\">// 只能对unknown进行等或不等操作，不能进行其它操作</span></span><br><span class=\"line\">un1===un2;</span><br><span class=\"line\">un1!==un2;</span><br><span class=\"line\">un1 += un2;</span><br><span class=\"line\"><span class=\"comment\">// 不能做任何操作</span></span><br><span class=\"line\"><span class=\"comment\">// 不能访问属性</span></span><br><span class=\"line\"><span class=\"comment\">// 不能作为函数调用</span></span><br><span class=\"line\"><span class=\"comment\">// 不能当作类的构造函数不能创建实例</span></span><br><span class=\"line\">un.name</span><br><span class=\"line\">un();</span><br><span class=\"line\"><span class=\"keyword\">new</span> un();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射属性\"><a href=\"#映射属性\" class=\"headerlink\" title=\"映射属性\"></a>映射属性</h3><ul>\n<li>如果映射类型遍历的时候是unknown,不会映射属性</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> getType&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]:<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> t = getType&lt;unknown&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类型变换\"><a href=\"#类型变换\" class=\"headerlink\" title=\"类型变换\"></a>类型变换</h2><h3 id=\"交叉类型\"><a href=\"#交叉类型\" class=\"headerlink\" title=\"交叉类型\"></a>交叉类型</h3><ul>\n<li>交叉类型（Intersection Types）表示将多个类型合并为一个类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">    fly(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">    talk(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> BirdPerson = Bird &amp; Person;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p: BirdPerson = &#123; name: <span class=\"string\">'zf'</span>, fly() &#123; &#125;, talk() &#123; &#125; &#125;;</span><br><span class=\"line\">p.fly;</span><br><span class=\"line\">p.name</span><br><span class=\"line\">p.talk;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h3><ul>\n<li>可以获取一个变量的类型</li>\n<li>先定义类型，再定义变量</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> People = &#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>,</span><br><span class=\"line\">    age:<span class=\"built_in\">number</span>,</span><br><span class=\"line\">    gender:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1:People = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">'zf'</span>,</span><br><span class=\"line\">    age:<span class=\"number\">10</span>,</span><br><span class=\"line\">    gender:<span class=\"string\">'male'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//先定义变量，再定义类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">'zf'</span>,</span><br><span class=\"line\">    age:<span class=\"number\">10</span>,</span><br><span class=\"line\">    gender:<span class=\"string\">'male'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> People = <span class=\"keyword\">typeof</span> p1;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">p:People</span>):<span class=\"title\">string</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getName(p1);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"索引访问操作符\"><a href=\"#索引访问操作符\" class=\"headerlink\" title=\"索引访问操作符\"></a>索引访问操作符</h3><ul>\n<li>可以通过[]获取一个类型的子类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">    job:&#123;</span><br><span class=\"line\">        name:<span class=\"built_in\">string</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    interests:&#123;name:<span class=\"built_in\">string</span>,level:<span class=\"built_in\">number</span>&#125;[]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> FrontEndJob:Person[<span class=\"string\">'job'</span>] = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">'前端工程师'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> interestLevel:Person[<span class=\"string\">'interests'</span>][<span class=\"number\">0</span>][<span class=\"string\">'level'</span>] = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"keyof\"><a href=\"#keyof\" class=\"headerlink\" title=\"keyof\"></a>keyof</h3><ul>\n<li>索引类型查询操作符</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">  gender:<span class=\"string\">'male'</span>|<span class=\"string\">'female'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//type PersonKey = 'name'|'age'|'gender';</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PersonKey = keyof Person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getValueByKey</span>(<span class=\"params\">p:Person,key:PersonKey</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> val = getValueByKey(&#123;name:<span class=\"string\">'zf'</span>,age:<span class=\"number\">10</span>,gender:<span class=\"string\">'male'</span>&#125;,<span class=\"string\">'name'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(val);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射类型\"><a href=\"#映射类型\" class=\"headerlink\" title=\"映射类型\"></a>映射类型</h3><ul>\n<li>在定义的时候用in操作符去批量定义类型中的属性</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">  gender:<span class=\"string\">'male'</span>|<span class=\"string\">'female'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//批量把一个接口中的属性都变成可选的</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PartPerson = &#123;</span><br><span class=\"line\">  [Key <span class=\"keyword\">in</span> keyof Person]?:Person[Key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p1:PartPerson=&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//也可以使用泛型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Part&lt;T&gt; = &#123;</span><br><span class=\"line\">  [key <span class=\"keyword\">in</span> keyof T]?:T[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p2:Part&lt;Person&gt;=&#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内置工具类型\"><a href=\"#内置工具类型\" class=\"headerlink\" title=\"内置工具类型\"></a>内置工具类型</h3><ul>\n<li>TS 中内置了一些工具类型来帮助我们更好地使用类型系统</li>\n</ul>\n<p>符号| 含义<br>+?|变为可远<br>-&gt;|变为必选</p>\n<h4 id=\"Partial\"><a href=\"#Partial\" class=\"headerlink\" title=\"Partial\"></a>Partial</h4><ul>\n<li>Partial 可以将传入的属性由非可选变为可选，具体使用如下：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Partial&lt;T&gt; = &#123; [P <span class=\"keyword\">in</span> keyof T]?: T[P] &#125;;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> A &#123;</span><br><span class=\"line\">  a1: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  a2: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  a3: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> aPartial = Partial&lt;A&gt;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a: aPartial = &#123;&#125;; <span class=\"comment\">// 不会报错</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Required\"><a href=\"#Required\" class=\"headerlink\" title=\"Required\"></a>Required</h4><ul>\n<li>Required 可以将传入的属性中的可选项变为必选项，这里用了 -? 修饰符来实现。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">  gender?:<span class=\"string\">'male'</span>|<span class=\"string\">'female'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * type Require&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p:Required&lt;Person&gt; = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">'zf'</span>,</span><br><span class=\"line\">  age:<span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"comment\">//gender:'male'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Readonly\"><a href=\"#Readonly\" class=\"headerlink\" title=\"Readonly\"></a>Readonly</h4><ul>\n<li>Readonly 通过为传入的属性每一项都加上 readonly 修饰符来实现。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">  gender?:<span class=\"string\">'male'</span>|<span class=\"string\">'female'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p:Readonly&lt;Person&gt; = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">'zf'</span>,</span><br><span class=\"line\">  age:<span class=\"number\">10</span>,</span><br><span class=\"line\">  gender:<span class=\"string\">'male'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p.age = <span class=\"number\">11</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Pick\"><a href=\"#Pick\" class=\"headerlink\" title=\"Pick\"></a>Pick</h4><ul>\n<li>Pick 能够帮助我们从传入的属性中摘取某一项返回</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Animal &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  gender:<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * From T pick a set of properties K</span></span><br><span class=\"line\"><span class=\"comment\"> * type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P] &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 摘取 Animal 中的 name 属性</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    married: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pick</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">obj: T, keys: K[]</span>): <span class=\"title\">Pick</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result: <span class=\"built_in\">any</span> = &#123;&#125;;</span><br><span class=\"line\">    keys.map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        result[key] = obj[key];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person: Person = &#123; name: <span class=\"string\">'zf'</span>, age: <span class=\"number\">10</span>, married: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result: Pick&lt;Person, <span class=\"string\">'name'</span> | <span class=\"string\">'age'</span>&gt; = pick&lt;Person, <span class=\"string\">'name'</span> | <span class=\"string\">'age'</span>&gt;(person, [<span class=\"string\">'name'</span>, <span class=\"string\">'age'</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Record\"><a href=\"#Record\" class=\"headerlink\" title=\"Record\"></a>Record</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapObject</span>&lt;<span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">string</span> | <span class=\"title\">number</span>, <span class=\"title\">T</span>, <span class=\"title\">U</span>&gt;(<span class=\"params\">obj: Record&lt;K, T&gt;, map: (x: T) =&gt; U</span>): <span class=\"title\">Record</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">U</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result: <span class=\"built_in\">any</span> = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        result[key] = map(obj[key]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> names = &#123; <span class=\"number\">0</span>: <span class=\"string\">'hello'</span>, <span class=\"number\">1</span>: <span class=\"string\">'world'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> lengths = mapObject&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>&gt;<span class=\"function\">(<span class=\"params\">names, (<span class=\"params\">s: <span class=\"built_in\">string</span></span>) =&gt; s.length</span>);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">console</span>.<span class=\"params\">log</span>(<span class=\"params\">lengths</span>);//&#123; '0': 5, '1': 5 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Proxy&lt;T&gt; = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>(): T;</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(value: T): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Proxify&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]: Proxy&lt;T[P]&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">proxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">obj: T</span>): <span class=\"title\">Proxify</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> Proxify&lt;T&gt;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        result[key] = &#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> obj[key],</span><br><span class=\"line\">            <span class=\"keyword\">set</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> obj[key] = value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> props = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'zf'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyProps = proxify(props);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(proxyProps);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unProxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">t: Proxify&lt;T&gt;</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> T;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> t) &#123;</span><br><span class=\"line\">        result[k] = t[k].get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> originProps = unProxify(proxyProps);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(originProps);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射类型修饰符的控制\"><a href=\"#映射类型修饰符的控制\" class=\"headerlink\" title=\"映射类型修饰符的控制\"></a>映射类型修饰符的控制</h3><ul>\n<li>TypeScript中增加了对映射类型修饰符的控制</li>\n<li>具体而言，一个 readonly 或 ? 修饰符在一个映射类型里可以用前缀 + 或-来表示这个修饰符应该被添加或移除</li>\n<li>TS 中部分内置工具类型就利用了这个特性（Partial、Required、Readonly…），这里我们可以参考 Partial、Required 的实现</li>\n</ul>\n<h2 id=\"条件类型\"><a href=\"#条件类型\" class=\"headerlink\" title=\"条件类型\"></a>条件类型</h2><ul>\n<li>在定义泛型的时候能够添加进逻辑分支，以后泛型更加灵活<br>utility-types</li>\n</ul>\n<h3 id=\"定义条件类型\"><a href=\"#定义条件类型\" class=\"headerlink\" title=\"定义条件类型\"></a>定义条件类型</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Water &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Sky &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//三元运算符</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Condition&lt;T&gt; = T <span class=\"keyword\">extends</span> Fish ? Water : Sky;</span><br><span class=\"line\"><span class=\"keyword\">let</span> condition: Condition&lt;Fish&gt; = &#123; name: <span class=\"string\">'水'</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件类型的分发\"><a href=\"#条件类型的分发\" class=\"headerlink\" title=\"条件类型的分发\"></a>条件类型的分发</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">    fish: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Water &#123;</span><br><span class=\"line\">    water: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    bird: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Sky &#123;</span><br><span class=\"line\">    sky: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Condition&lt;T&gt; = T <span class=\"keyword\">extends</span> Fish ? Water : Sky;</span><br><span class=\"line\"><span class=\"comment\">//(Fish extends Fish ? Water : Sky) | (Bird extends Fish ? Water : Sky)</span></span><br><span class=\"line\"><span class=\"comment\">// Water|Sky</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> condition1: Condition&lt;Fish | Bird&gt; = &#123; water: <span class=\"string\">'水'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> condition2: Condition&lt;Fish | Bird&gt; = &#123; sky: <span class=\"string\">'天空'</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内置条件类型\"><a href=\"#内置条件类型\" class=\"headerlink\" title=\"内置条件类型\"></a>内置条件类型</h3><ul>\n<li>TS 在内置了一些常用的条件类型，可以在 lib.es5.d.ts 中查看：</li>\n<li>infer最早出现在此 PR 中，表示在 extends 条件语句中待推断的类型变量</li>\n</ul>\n<h4 id=\"Exclude\"><a href=\"#Exclude\" class=\"headerlink\" title=\"Exclude\"></a>Exclude</h4><ul>\n<li>从 T 可分配给的类型中排除 U `js type Exclude&lt;T, U&gt; = T extends U ? never : T;</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> E = Exclude&lt;<span class=\"built_in\">string</span>|<span class=\"built_in\">number</span>,<span class=\"built_in\">string</span>&gt;; <span class=\"keyword\">let</span> e:E = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Extract-lt-T-U-gt\"><a href=\"#Extract-lt-T-U-gt\" class=\"headerlink\" title=\"Extract&lt;T, U&gt;\"></a>Extract&lt;T, U&gt;</h4><ul>\n<li>从 T 可分配的类型中提取 U</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Extract&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? T : never;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span>  E = Extract&lt;<span class=\"built_in\">string</span>|<span class=\"built_in\">number</span>,<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> e:E = <span class=\"string\">'1'</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NonNullable\"><a href=\"#NonNullable\" class=\"headerlink\" title=\"NonNullable\"></a>NonNullable</h4><ul>\n<li>从 T 中排除 null 和 undefined</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> NonNullable&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span> ? never : T;</span><br><span class=\"line\"><span class=\"keyword\">type</span>  E = NonNullable&lt;<span class=\"built_in\">string</span>|<span class=\"built_in\">number</span>|<span class=\"literal\">null</span>|<span class=\"literal\">undefined</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> e:E = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ReturnType\"><a href=\"#ReturnType\" class=\"headerlink\" title=\"ReturnType\"></a>ReturnType</h4><ul>\n<li>获取函数类型的返回类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserInfo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; name: <span class=\"string\">\"zf\"</span>, age: <span class=\"number\">10</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过 ReturnType 将 getUserInfo 的返回值类型赋给了 UserInfo</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> UserInfo = ReturnType&lt;<span class=\"keyword\">typeof</span> getUserInfo&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> userA: UserInfo = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"zf\"</span>,</span><br><span class=\"line\">  age: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReturnType2&lt;T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> AnyFunction = <span class=\"function\">(<span class=\"params\">...args: <span class=\"built_in\">any</span>[]</span>) =&gt;</span> <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ReturnType2&lt;T <span class=\"keyword\">extends</span> AnyFunction&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Parameters\"><a href=\"#Parameters\" class=\"headerlink\" title=\"Parameters\"></a>Parameters</h4><p>Constructs a tuple type of the types of the parameters of a function type T<br>Parameters</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare function f1(arg: &#123; a: number, b: string &#125;): void</span><br><span class=\"line\">type T0 &#x3D; Parameters2&lt;() &#x3D;&gt; string&gt;;  &#x2F;&#x2F; []</span><br><span class=\"line\">type T1 &#x3D; Parameters2&lt;(s: string) &#x3D;&gt; void&gt;;  &#x2F;&#x2F; [string]</span><br><span class=\"line\">type T2 &#x3D; Parameters2&lt;(&lt;T&gt;(arg: T) &#x3D;&gt; T)&gt;;  &#x2F;&#x2F; [unknown]</span><br><span class=\"line\">type AnyFunction &#x3D; (...args: any[]) &#x3D;&gt; any;</span><br><span class=\"line\">&#x2F;&#x2F;type ReturnType2&lt;T extends AnyFunction&gt; &#x3D; T extends (...args: any[]) &#x3D;&gt; infer R ? R : any;</span><br><span class=\"line\">type Parameters2&lt;T extends AnyFunction&gt; &#x3D; T extends (...args: infer R) &#x3D;&gt; any ? R : any;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"InstanceType\"><a href=\"#InstanceType\" class=\"headerlink\" title=\"InstanceType\"></a>InstanceType</h4><ul>\n<li>获取构造函数类型的实例类型</li>\n<li>InstanceType</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName() &#123; <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> constructorParameters = ConstructorParameters&lt;<span class=\"keyword\">typeof</span> Person&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> params: constructorParameters = [<span class=\"string\">'zf'</span>]</span><br><span class=\"line\"><span class=\"keyword\">type</span> Instance = InstanceType&lt;<span class=\"keyword\">typeof</span> Person&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> instance: Instance = &#123; name: <span class=\"string\">'zf'</span>, getName() &#123; &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Constructor = <span class=\"keyword\">new</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ConstructorParameters&lt;T <span class=\"keyword\">extends</span> Constructor&gt; = T <span class=\"keyword\">extends</span> <span class=\"keyword\">new</span> (...args: infer P) =&gt; <span class=\"built_in\">any</span> ? P : never;</span><br><span class=\"line\"><span class=\"keyword\">type</span> InstanceType&lt;T <span class=\"keyword\">extends</span> Constructor&gt; = T <span class=\"keyword\">extends</span> <span class=\"keyword\">new</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"infer\"><a href=\"#infer\" class=\"headerlink\" title=\"infer\"></a>infer</h4><ul>\n<li>typescript_zh</li>\n<li>codesandbox</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ElementType&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[] ? T[<span class=\"built_in\">number</span>] : T;</span><br><span class=\"line\"><span class=\"keyword\">type</span> e1 = ElementType&lt;<span class=\"built_in\">string</span>[]&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> e2 = ElementType&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> GetElementType&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">Array</span>&lt;infer U&gt; ? U : T;</span><br><span class=\"line\"><span class=\"keyword\">type</span> e3 = GetElementType&lt;<span class=\"built_in\">string</span>[]&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> e4 = GetElementType&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Action&lt;T&gt; &#123;</span><br><span class=\"line\">    payload?: T</span><br><span class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> EffectModule &#123;</span><br><span class=\"line\">  count = <span class=\"number\">1</span>;</span><br><span class=\"line\">  message = <span class=\"string\">\"hello!\"</span>;</span><br><span class=\"line\">  delay(input: <span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">number</span>&gt;) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> input.then(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> (&#123;</span><br><span class=\"line\">          payload: <span class=\"string\">`hello <span class=\"subst\">$&#123;i&#125;</span>!`</span>,</span><br><span class=\"line\">          <span class=\"keyword\">type</span>: <span class=\"string\">'delay'</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setMessage(action: Action&lt;<span class=\"built_in\">Date</span>&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        payload: action.payload!.getMilliseconds(),</span><br><span class=\"line\">        <span class=\"keyword\">type</span>: <span class=\"string\">\"set-message\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> FuncName&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]: T[P] <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span> ? P : never;</span><br><span class=\"line\">&#125;[keyof T];</span><br><span class=\"line\"><span class=\"keyword\">type</span> ts = FuncName&lt;EffectModule&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Connect = <span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span>: EffectModule</span>) =&gt;</span> &#123; [T <span class=\"keyword\">in</span> FuncName&lt;EffectModule&gt;]: EffectModule[T] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> TransformResultType&lt;RT&gt; = &#123;</span><br><span class=\"line\">    [s <span class=\"keyword\">in</span> keyof RT]:</span><br><span class=\"line\">    RT[s] <span class=\"keyword\">extends</span> (input: <span class=\"built_in\">Promise</span>&lt;infer T&gt;) =&gt; <span class=\"built_in\">Promise</span>&lt;Action&lt;infer U&gt;&gt; ?</span><br><span class=\"line\">    (input: T) =&gt; Action&lt;U&gt; : (</span><br><span class=\"line\">        RT[s] <span class=\"keyword\">extends</span> (action: Action&lt;infer T&gt;) =&gt; Action&lt;infer U&gt; ? <span class=\"function\">(<span class=\"params\">action: T</span>) =&gt;</span> Action&lt;U&gt; : never</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> connectedResultType = ReturnType&lt;Connect&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> result = TransformResultType&lt;connectedResultType&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; &#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模块VS命名空间\"><a href=\"#模块VS命名空间\" class=\"headerlink\" title=\"模块VS命名空间\"></a>模块VS命名空间</h2><h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><ul>\n<li>模块是TS中外部模块的简称，侧重于代码和复用</li>\n<li>模块在期自身的作用域里执行，而不是在全局作用域里</li>\n<li>一个模块里的变量、函数、类等在外部是不可见的，除非你把它导出</li>\n<li>如果想要使用一个模块里导出的变量，则需要导入</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> name, &#123; a, b &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./1'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name, a, b);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><ul>\n<li>在代码量较大的情况下，为了避免命名空间冲突，可以将相似的函数、类、接口放置到命名空间内</li>\n<li>命名空间可以将代码包裹起来，只对外暴露需要在外部访问的对象，命名空间内通过export向外导出</li>\n<li>命名空间是内部模块，主要用于组织代码，避免命名冲突</li>\n</ul>\n<h3 id=\"内部划分\"><a href=\"#内部划分\" class=\"headerlink\" title=\"内部划分\"></a>内部划分</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> zoo &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Dog &#123; eat() &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'zoo dog'</span>); &#125; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> home &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Dog &#123; eat() &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'home dog'</span>); &#125; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog_of_zoo = <span class=\"keyword\">new</span> zoo.Dog();</span><br><span class=\"line\">dog_of_zoo.eat();</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog_of_home = <span class=\"keyword\">new</span> home.Dog();</span><br><span class=\"line\">dog_of_home.eat();</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; zoo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./3'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog_of_zoo = <span class=\"keyword\">new</span> zoo.Dog();</span><br><span class=\"line\">dog_of_zoo.eat();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类型声明\"><a href=\"#类型声明\" class=\"headerlink\" title=\"类型声明\"></a>类型声明</h2><ul>\n<li>声明文件可以让我们不需要将JS重构为TS，只需要加上声明文件就可以使用系统</li>\n<li>类型声明在编译的时候都会被删除，不会影响真正的代码</li>\n</ul>\n<h3 id=\"普通类型声明\"><a href=\"#普通类型声明\" class=\"headerlink\" title=\"普通类型声明\"></a>普通类型声明</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> $: <span class=\"function\">(<span class=\"params\">selector: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123; <span class=\"comment\">//变量</span></span><br><span class=\"line\">    click(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">    width(length: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">$(<span class=\"string\">'#root'</span>).click();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log($(<span class=\"string\">'#root'</span>).width);</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span>;  <span class=\"comment\">//变量</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">let</span> age: <span class=\"built_in\">number</span>;  <span class=\"comment\">//变量</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\"></span>): <span class=\"title\">string</span></span>;  <span class=\"comment\">//方法</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">class</span> Animal &#123; name: <span class=\"built_in\">string</span> &#125;  <span class=\"comment\">//类</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name, age);</span><br><span class=\"line\">getName();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外部枚举\"><a href=\"#外部枚举\" class=\"headerlink\" title=\"外部枚举\"></a>外部枚举</h3><ul>\n<li>外部枚举是使用declare enum定义的枚举类型</li>\n<li>外部枚举用来描述已经存在的枚举类型的形状</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">enum</span> Seasons &#123;</span><br><span class=\"line\">    Spring,</span><br><span class=\"line\">    Summer,</span><br><span class=\"line\">    Autumn,</span><br><span class=\"line\">    Winter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> seasons = [</span><br><span class=\"line\">    Seasons.Spring,</span><br><span class=\"line\">    Seasons.Summer,</span><br><span class=\"line\">    Seasons.Autumn,</span><br><span class=\"line\">    Seasons.Winter</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">declare</span> 定义的类型只会用于编译时的检查，编译结果中会被删除。上例的编译结果如下</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> seasons = [</span><br><span class=\"line\">    Seasons.Spring,</span><br><span class=\"line\">    Seasons.Summer,</span><br><span class=\"line\">    Seasons.Autumn,</span><br><span class=\"line\">    Seasons.Winter</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以同时使用declare 和 const</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Seasons &#123;</span><br><span class=\"line\">    Spring,</span><br><span class=\"line\">    Summer,</span><br><span class=\"line\">    Autumn,</span><br><span class=\"line\">    Winter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> seasons = [</span><br><span class=\"line\">    Seasons.Spring,</span><br><span class=\"line\">    Seasons.Summer,</span><br><span class=\"line\">    Seasons.Autumn,</span><br><span class=\"line\">    Seasons.Winter</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> seasons = [</span><br><span class=\"line\">    <span class=\"number\">0</span> <span class=\"comment\">/* Spring */</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"comment\">/* Summer */</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span> <span class=\"comment\">/* Autumn */</span>,</span><br><span class=\"line\">    <span class=\"number\">3</span> <span class=\"comment\">/* Winter */</span></span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"namespace\"><a href=\"#namespace\" class=\"headerlink\" title=\"namespace\"></a>namespace</h2><ul>\n<li>如果一个全局变量包括了很多子属性，可能使用namespace</li>\n<li>在声明文件中的namespace表示一个全局变量包含很多子属性</li>\n<li>在命名空间内部不需要使用 declare 声明属性或方法</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> $&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url:<span class=\"built_in\">string</span>,settings:<span class=\"built_in\">any</span></span>):<span class=\"title\">void</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">namespace</span> fn &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">object:<span class=\"built_in\">any</span></span>):<span class=\"title\">void</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$.ajax(<span class=\"string\">'/api/users'</span>,&#123;&#125;);</span><br><span class=\"line\">$.fn.extend(&#123;</span><br><span class=\"line\">    log:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message:<span class=\"built_in\">any</span></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型声明文件\"><a href=\"#类型声明文件\" class=\"headerlink\" title=\"类型声明文件\"></a>类型声明文件</h3><ul>\n<li>我们可以把类型声明放在一个单独的类型声明文件中</li>\n<li>可以在类型声明文件中使用类型声明</li>\n<li>文件命名规范为*.d.ts</li>\n<li>观看类型声明文件有助于了解库的使用方式</li>\n</ul>\n<h4 id=\"jquery-d-ts\"><a href=\"#jquery-d-ts\" class=\"headerlink\" title=\"jquery.d.ts\"></a>jquery.d.ts</h4><p>typings\\jquery.d.ts</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> $:<span class=\"function\">(<span class=\"params\">selector:<span class=\"built_in\">string</span></span>)=&gt;</span>&#123;</span><br><span class=\"line\">    click():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">    width(length:<span class=\"built_in\">number</span>):<span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tsconfig-json\"><a href=\"#tsconfig-json\" class=\"headerlink\" title=\"tsconfig.json\"></a>tsconfig.json</h3><p>tsconfig.json</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"compilerOptions\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"module\"</span>: <span class=\"string\">\"commonjs\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"target\"</span>: <span class=\"string\">\"ES2015\"</span>,  </span><br><span class=\"line\">    <span class=\"string\">\"outDir\"</span>:<span class=\"string\">\"lib\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"include\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"src/**/*\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"typings/**/*\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"test-js\"><a href=\"#test-js\" class=\"headerlink\" title=\"test.js\"></a>test.js</h4><p>src\\test.ts</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'#button'</span>).click();</span><br><span class=\"line\">$(<span class=\"string\">'#button'</span>).width(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第三方声明文件\"><a href=\"#第三方声明文件\" class=\"headerlink\" title=\"第三方声明文件\"></a>第三方声明文件</h2><ul>\n<li>可以安装使用第三方的声明文件</li>\n<li>@types是一个约定的前缀，所有的第三方声明的类型库都会带有这样的前缀</li>\n<li>JavaScript 中有很多内置对象，它们可以在 TypeScript 中被当做声明好了的类型</li>\n<li>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准</li>\n<li>这些内置对象的类型声明文件，就包含在TypeScript 核心库的类型声明文件中</li>\n</ul>\n<h3 id=\"使用jquery\"><a href=\"#使用jquery\" class=\"headerlink\" title=\"使用jquery\"></a>使用jquery</h3><p>cnpm i jquery -S<br>对于common.js风格的模块必须使用 import * as<br>import * as jQuery from ‘jquery’;<br>jQuery.ajax(‘/user/1’);</p>\n<h3 id=\"安装声明文件\"><a href=\"#安装声明文件\" class=\"headerlink\" title=\"安装声明文件\"></a>安装声明文件</h3><p>cnpm i @types/jquery -S</p>\n<h3 id=\"自己编写声明文件\"><a href=\"#自己编写声明文件\" class=\"headerlink\" title=\"自己编写声明文件\"></a>自己编写声明文件</h3><ul>\n<li>模块查找规则</li>\n<li>`node_modules@types\\jquery/index.d.ts</li>\n<li>我们可以自己编写声明文件并配置tsconfig.json</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.d.ts</span></span><br><span class=\"line\"><span class=\"comment\">// types\\jquery\\index.d.ts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jQuery</span>(<span class=\"params\">selector:<span class=\"built_in\">string</span></span>):<span class=\"title\">HTMLElement</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> jQuery&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url:<span class=\"built_in\">string</span></span>):<span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">export</span> <span class=\"title\">default</span> <span class=\"title\">jQuery</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tsconfig-json-1\"><a href=\"#tsconfig-json-1\" class=\"headerlink\" title=\"tsconfig.json\"></a>tsconfig.json</h3><ul>\n<li>如果配置了paths,那么在引入包的的时候会自动去paths目录里找类型声明文件</li>\n<li>在 tsconfig.json 中，我们通过 compilerOptions 里的 paths 属性来配置路径映射</li>\n<li>paths是模块名到基于baseUrl的路径映射的列表</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"string\">\"baseUrl\"</span>: <span class=\"string\">\"./\"</span>,<span class=\"comment\">// 使用 paths 属性的话必须要指定 baseUrl 的值</span></span><br><span class=\"line\"><span class=\"string\">\"paths\"</span>: &#123;</span><br><span class=\"line\"><span class=\"string\">\"*\"</span>:[<span class=\"string\">\"types/*\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"npm声明文件可能的位置\"><a href=\"#npm声明文件可能的位置\" class=\"headerlink\" title=\"npm声明文件可能的位置\"></a>npm声明文件可能的位置</h3><p>node_modules/jquery/package.json<br>“types”:”types/xxx.d.ts”<br>node_modules/jquery/index.d.ts<br>node_modules/@types/jquery/index.d.ts</p>\n<h3 id=\"扩展全局变量的类型\"><a href=\"#扩展全局变量的类型\" class=\"headerlink\" title=\"扩展全局变量的类型\"></a>扩展全局变量的类型</h3><h4 id=\"扩展局部变量类型\"><a href=\"#扩展局部变量类型\" class=\"headerlink\" title=\"扩展局部变量类型\"></a>扩展局部变量类型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> <span class=\"built_in\">String</span>: StringConstructor;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> StringConstructor &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>(value?: <span class=\"built_in\">any</span>): <span class=\"built_in\">String</span>;</span><br><span class=\"line\">    (value?: <span class=\"built_in\">any</span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    readonly prototype: <span class=\"built_in\">String</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> String &#123;</span><br><span class=\"line\">    toString(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//扩展类的原型</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> String &#123;</span><br><span class=\"line\">    double():<span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span>.prototype.double = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>+<span class=\"string\">'+'</span>+<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>.double());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//扩展类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Window&#123;</span><br><span class=\"line\">    myname:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.myname);</span><br><span class=\"line\"><span class=\"comment\">//export &#123;&#125; 没有导出就是全局扩展</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模块内全局扩展\"><a href=\"#模块内全局扩展\" class=\"headerlink\" title=\"模块内全局扩展\"></a>模块内全局扩展</h3><p>types\\global\\index.d.ts</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> global&#123;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> String &#123;</span><br><span class=\"line\">        double():<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> Window&#123;</span><br><span class=\"line\">        myname:<span class=\"built_in\">string</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span>  &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"合并声明\"><a href=\"#合并声明\" class=\"headerlink\" title=\"合并声明\"></a>合并声明</h2><ul>\n<li>同一名称的两个独立声明会被合并成一个单一声明</li>\n<li>合并后的声明拥有原先两个声明的特性  </li>\n</ul>\n<p>关键字|作为类型使用|作为值使用<br>class|yes|yes<br>enum|yes|yes<br>interface|yes|no<br>type|yes|no<br>function|no|yes<br>var,let,const|no|yes</p>\n<ul>\n<li>类既可以作为类型使用，也可以作为值使用，接口只能作为类型使用</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Person&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>=<span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1:Person;<span class=\"comment\">//作为类型使用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> Person();<span class=\"comment\">//作为值使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Animal&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a1:Animal;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a2 = Animal;<span class=\"comment\">//接口类型不能用作值</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并类型声明\"><a href=\"#合并类型声明\" class=\"headerlink\" title=\"合并类型声明\"></a>合并类型声明</h3><ul>\n<li>可以通过接口合并的特性给一个第三方为扩展类型声明<br>use.js</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Animal&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a1:Animal=&#123;name:<span class=\"string\">'zf'</span>,age:<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a1.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a1.age);</span><br><span class=\"line\"><span class=\"comment\">//注意不要加export &#123;&#125; ,这是全局的</span></span><br><span class=\"line\">types\\animal\\index.d.ts</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Animal&#123;</span><br><span class=\"line\">    age:<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用命名空间扩展类\"><a href=\"#使用命名空间扩展类\" class=\"headerlink\" title=\"使用命名空间扩展类\"></a>使用命名空间扩展类</h3><ul>\n<li>我们可以使用 namespace 来扩展类，用于表示内部类</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Form &#123;</span><br><span class=\"line\">  username: Form.Item=<span class=\"string\">''</span>;</span><br><span class=\"line\">  password: Form.Item=<span class=\"string\">''</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Item为Form的内部类</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Form &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Item &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> item:Form.Item = <span class=\"keyword\">new</span> Form.Item();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用命名空间扩展函数\"><a href=\"#使用命名空间扩展函数\" class=\"headerlink\" title=\"使用命名空间扩展函数\"></a>使用命名空间扩展函数</h3><ul>\n<li>我们也可以使用 namespace 来扩展函数</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeting</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> greeting.words+name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> greeting &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> words = <span class=\"string\">\"Hello,\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeting(<span class=\"string\">'zf'</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用命名空间扩展枚举类型\"><a href=\"#使用命名空间扩展枚举类型\" class=\"headerlink\" title=\"使用命名空间扩展枚举类型\"></a>使用命名空间扩展枚举类型</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    red = <span class=\"number\">1</span>,</span><br><span class=\"line\">    yellow = <span class=\"number\">2</span>,</span><br><span class=\"line\">    blue = <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Color &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">const</span> green=<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">const</span> purple=<span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color.green)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"扩展Store\"><a href=\"#扩展Store\" class=\"headerlink\" title=\"扩展Store\"></a>扩展Store</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, Store &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> StoreExt = Store &amp; &#123;</span><br><span class=\"line\">    ext: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store: StoreExt = createStore(<span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state);</span><br><span class=\"line\">store.ext = <span class=\"string\">'hello'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生成声明文件\"><a href=\"#生成声明文件\" class=\"headerlink\" title=\"生成声明文件\"></a>生成声明文件</h3><ul>\n<li>把TS编译成JS后丢失类型声明，我们可以在编译的时候自动生成一份JS文件</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"compilerOptions\"</span>: &#123;</span><br><span class=\"line\">     <span class=\"string\">\"declaration\"</span>: <span class=\"literal\">true</span>, <span class=\"comment\">/* Generates corresponding '.d.ts' file.*/</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"结构类型系统\"><a href=\"#结构类型系统\" class=\"headerlink\" title=\"结构类型系统\"></a>结构类型系统</h2><h3 id=\"接口的兼容性\"><a href=\"#接口的兼容性\" class=\"headerlink\" title=\"接口的兼容性\"></a>接口的兼容性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">- 如果传入的变量和声明的类型不匹配，TS就会进行兼容性检查</span><br><span class=\"line\">- 原理是Duck-Check,就是说只要目标类型中声明的属性变量在源类型中都存在就是兼容的</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Animal &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    gender: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 要判断目标类型`Person`是否能够兼容输入的源类型`Animal`</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">animal: Animal</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> animal.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'zf'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">10</span>,</span><br><span class=\"line\">    gender: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getName(p);</span><br><span class=\"line\"><span class=\"comment\">//只有在传参的时候两个变量之间才会进行兼容性的比较，赋值的时候并不会比较,会直接报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: Animal = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'zf'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">10</span>,</span><br><span class=\"line\">    gender: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本类型的兼容性\"><a href=\"#基本类型的兼容性\" class=\"headerlink\" title=\"基本类型的兼容性\"></a>基本类型的兼容性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本数据类型也有兼容性判断</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num : <span class=\"built_in\">string</span>|<span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> str:<span class=\"built_in\">string</span>=<span class=\"string\">'zf'</span>;</span><br><span class=\"line\">num = str;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//只要有toString()方法就可以赋给字符串变量</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num2 : &#123;</span><br><span class=\"line\">  toString():<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> str2:<span class=\"built_in\">string</span>=<span class=\"string\">'jiagou'</span>;</span><br><span class=\"line\">num2 = str2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类的兼容性\"><a href=\"#类的兼容性\" class=\"headerlink\" title=\"类的兼容性\"></a>类的兼容性</h3><p>在TS中是结构类型系统，只会对比结构而不在意类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Bird <span class=\"keyword\">extends</span> Animal&#123;</span><br><span class=\"line\">   swing:<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a:Animal;</span><br><span class=\"line\">a = <span class=\"keyword\">new</span> Bird();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b:Bird;</span><br><span class=\"line\"><span class=\"comment\">//并不是父类兼容子类，子类不兼容父类</span></span><br><span class=\"line\">b = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果父类和子类结构一样，也可以的</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Bird <span class=\"keyword\">extends</span> Animal&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a:Animal;</span><br><span class=\"line\">a = <span class=\"keyword\">new</span> Bird();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b:Bird;</span><br><span class=\"line\">b = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//甚至没有关系的两个类的实例也是可以的</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Animal&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Bird&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a:Animal ;</span><br><span class=\"line\">a = <span class=\"keyword\">new</span> Bird();</span><br><span class=\"line\"><span class=\"keyword\">let</span> b:Bird;</span><br><span class=\"line\">b = <span class=\"keyword\">new</span> Animal();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数的兼容性\"><a href=\"#函数的兼容性\" class=\"headerlink\" title=\"函数的兼容性\"></a>函数的兼容性</h3><p>比较函数的时候是要先比较函数的参数，再比较函数的返回值</p>\n<h4 id=\"比较参数\"><a href=\"#比较参数\" class=\"headerlink\" title=\"比较参数\"></a>比较参数</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> sumFunc = <span class=\"function\">(<span class=\"params\">a:<span class=\"built_in\">number</span>,b:<span class=\"built_in\">number</span></span>)=&gt;</span><span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sum:sumFunc;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">a:<span class=\"built_in\">number</span>,b:<span class=\"built_in\">number</span></span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum = f1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可以省略一个参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\">a:<span class=\"built_in\">number</span></span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum = f2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可以省略二个参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f3</span>(<span class=\"params\"></span>):<span class=\"title\">number</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum = f3;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//多一个参数可不行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f4</span>(<span class=\"params\">a:<span class=\"built_in\">number</span>,b:<span class=\"built_in\">number</span>,c:<span class=\"built_in\">number</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b+c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum = f4;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"比较返回值\"><a href=\"#比较返回值\" class=\"headerlink\" title=\"比较返回值\"></a>比较返回值</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> GetPerson = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> getPerson:GetPerson;</span><br><span class=\"line\"><span class=\"comment\">//返回值一样可以</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;name:<span class=\"string\">'zf'</span>,age:<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getPerson = g1;</span><br><span class=\"line\"><span class=\"comment\">//返回值多一个属性也可以</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;name:<span class=\"string\">'zf'</span>,age:<span class=\"number\">10</span>,gender:<span class=\"string\">'male'</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getPerson = g2;</span><br><span class=\"line\"><span class=\"comment\">//返回值少一个属性可不行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g3</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;name:<span class=\"string\">'zf'</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getPerson = g3;</span><br><span class=\"line\"><span class=\"comment\">//因为有可能要调用返回值上的方法</span></span><br><span class=\"line\">getPerson().age.toFixed();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数参数的协变\"><a href=\"#函数参数的协变\" class=\"headerlink\" title=\"函数参数的协变\"></a>函数参数的协变</h3><p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"strictFunctionTypes\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sourceFunc = <span class=\"function\">(<span class=\"params\">args: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) =&gt;</span> &#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> target1Func = <span class=\"function\">(<span class=\"params\">args: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) =&gt;</span> &#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> target2Func = <span class=\"function\">(<span class=\"params\">args: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span> | <span class=\"built_in\">boolean</span></span>) =&gt;</span> &#123; &#125;</span><br><span class=\"line\">sourceFunc = target1Func;</span><br><span class=\"line\">sourceFunc = target2Func;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Event &#123;</span><br><span class=\"line\">    timestamp: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> MouseEvent <span class=\"keyword\">extends</span> Event &#123;</span><br><span class=\"line\">    eventX: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    eventY: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> KeyEvent <span class=\"keyword\">extends</span> Event &#123;</span><br><span class=\"line\">    keyCode: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEventListener</span>(<span class=\"params\">eventType: EventType, handler: (n: Event) =&gt; <span class=\"built_in\">void</span></span>) </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener(EventType.Mouse, <span class=\"function\">(<span class=\"params\">e: MouseEvent</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(e.eventX + <span class=\"string\">', '</span> + e.eventY));</span><br><span class=\"line\">addEventListener(EventType.Mouse, &lt;<span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;<span class=\"function\">(<span class=\"params\">(<span class=\"params\">e: MouseEvent</span>) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"params\">e.eventX + ', ' + e.eventY</span>)</span>));</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型的兼容性\"><a href=\"#泛型的兼容性\" class=\"headerlink\" title=\"泛型的兼容性\"></a>泛型的兼容性</h3><p>泛型在判断兼容性的时候会先判断具体的类型,然后再进行兼容性判断</p>\n<ol>\n<li>接口内容为空没用到泛型的时候是可以的</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Empty&lt;T&gt;&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x!:Empty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y!:Empty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">x = y;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>接口内容不为空的时候不可以</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NotEmpty&lt;T&gt;&#123;</span><br><span class=\"line\">  data:T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x1!:NotEmpty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y1!:NotEmpty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">x1 = y1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现原理如下,称判断具体的类型再判断兼容性</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> NotEmptyString&#123;</span><br><span class=\"line\">    data:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> NotEmptyNumber&#123;</span><br><span class=\"line\">    data:<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> xx2!:NotEmptyString;</span><br><span class=\"line\"><span class=\"keyword\">let</span> yy2!:NotEmptyNumber;</span><br><span class=\"line\">xx2 = yy2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"枚举的兼容性\"><a href=\"#枚举的兼容性\" class=\"headerlink\" title=\"枚举的兼容性\"></a>枚举的兼容性</h3><ul>\n<li>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容</li>\n<li>不同枚举类型之间是不兼容的</li>\n</ul>\n<p>//数字可以赋给枚举</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Colors &#123;Red,Yellow&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c:Colors;</span><br><span class=\"line\">c = Colors.Red;</span><br><span class=\"line\">c = <span class=\"number\">1</span>;</span><br><span class=\"line\">c = <span class=\"string\">'1'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//枚举值可以赋给数字</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">n = <span class=\"number\">1</span>;</span><br><span class=\"line\">n = Colors.Red;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类型保护\"><a href=\"#类型保护\" class=\"headerlink\" title=\"类型保护\"></a>类型保护</h2><ul>\n<li>类型保护就是一些表达式，他们在编译的时候就能通过类型信息确保某个作用域内变量的类型</li>\n<li>类型保护就是能够通过关键字判断出分支中的类型</li>\n</ul>\n<h3 id=\"typeof-类型保护\"><a href=\"#typeof-类型保护\" class=\"headerlink\" title=\"typeof 类型保护\"></a>typeof 类型保护</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">input: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> input === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> input + input;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> input === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input * <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> !input;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"instanceof类型保护\"><a href=\"#instanceof类型保护\" class=\"headerlink\" title=\"instanceof类型保护\"></a>instanceof类型保护</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    name!: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Bird <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">    swing!: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">animal: Animal</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (animal <span class=\"keyword\">instanceof</span> Bird) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(animal.swing);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(animal.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"null保护\"><a href=\"#null保护\" class=\"headerlink\" title=\"null保护\"></a>null保护</h3><p>如果开启了strictNullChecks选项，那么对于可能为null的变量不能调用它上面的方法和属性</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFirstLetter</span>(<span class=\"params\">s: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//第一种方式是加上null判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">''</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//第二种处理是增加一个或的处理</span></span><br><span class=\"line\">    s = s || <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//它并不能处理一些复杂的判断，需要加非空断言操作符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFirstLetter2</span>(<span class=\"params\">s: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(s!.trim());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = s || <span class=\"string\">''</span>;</span><br><span class=\"line\">    log();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"链判断运算符\"><a href=\"#链判断运算符\" class=\"headerlink\" title=\"链判断运算符\"></a>链判断运算符</h3><ul>\n<li>链判断运算符是一种先检查属性是否存在，再尝试访问该属性的运算符，其符号为 ?.</li>\n<li>如果运算符左侧的操作数 ?. 计算为 undefined 或 null，则表达式求值为 undefined 。否则，正常触发目标属性访问，方法或函数调用。</li>\n<li>链判断运算符 还处于 stage1 阶段,TS 也暂时不支持</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">a?.b; <span class=\"comment\">//如果a是null/undefined,那么返回undefined，否则返回a.b的值.</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a.b;</span><br><span class=\"line\"></span><br><span class=\"line\">a?.[x]; <span class=\"comment\">//如果a是null/undefined,那么返回undefined，否则返回a[x]的值</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a[x];</span><br><span class=\"line\"></span><br><span class=\"line\">a?.b(); <span class=\"comment\">// 如果a是null/undefined,那么返回undefined</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a.b(); <span class=\"comment\">//如果a.b不函数的话抛类型错误异常,否则计算a.b()的结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">a?.(); <span class=\"comment\">//如果a是null/undefined,那么返回undefined</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a(); <span class=\"comment\">//如果A不是函数会抛出类型错误</span></span><br><span class=\"line\"><span class=\"comment\">//否则 调用a这个函数</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可辨识的联合类型\"><a href=\"#可辨识的联合类型\" class=\"headerlink\" title=\"可辨识的联合类型\"></a>可辨识的联合类型</h3><ul>\n<li>就是利用联合类型中的共有字段进行类型保护的一种技巧</li>\n<li>相同字段的不同取值就是可辨识</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> WarningButton&#123;</span><br><span class=\"line\">  <span class=\"keyword\">class</span>:<span class=\"string\">'warning'</span>,</span><br><span class=\"line\">  text1:<span class=\"string\">'修改'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> DangerButton&#123;</span><br><span class=\"line\">  <span class=\"keyword\">class</span>:<span class=\"string\">'danger'</span>,</span><br><span class=\"line\">  text2:<span class=\"string\">'删除'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Button = WarningButton|DangerButton;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getButton</span>(<span class=\"params\">button:Button</span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(button.class==<span class=\"string\">'warning'</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(button.text1);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(button.class==<span class=\"string\">'danger'</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(button.text2);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"in操作符\"><a href=\"#in操作符\" class=\"headerlink\" title=\"in操作符\"></a>in操作符</h3><p>in 运算符可以被用于参数类型的判断</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    swing: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Dog &#123;</span><br><span class=\"line\">    leg: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getNumber</span>(<span class=\"params\">x: Bird | Dog</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"swing\"</span> <span class=\"keyword\">in</span> x) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> x.swing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.leg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义的类型保护\"><a href=\"#自定义的类型保护\" class=\"headerlink\" title=\"自定义的类型保护\"></a>自定义的类型保护</h3><ul>\n<li>TypeScript 里的类型保护本质上就是一些表达式，它们会在运行时检查类型信息，以确保在某个作用域里的类型是符合预期的</li>\n<li>type is Type1Class就是类型谓词</li>\n<li>谓词为 parameterName is Type这种形式,parameterName必须是来自于当前函数签名里的一个参数名</li>\n<li>每当使用一些变量调用isType1时，如果原始类型兼容，TypeScript会将该变量缩小到该特定类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isType1</span>(<span class=\"params\"><span class=\"keyword\">type</span>: Type1Class | Type2Class</span>): <span class=\"title\">type</span> <span class=\"title\">is</span> <span class=\"title\">Type1Class</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (&lt;Type1Class&gt;<span class=\"keyword\">type</span>).func1 !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  swing: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Dog &#123;</span><br><span class=\"line\">  leg: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//没有相同字段可以定义一个类型保护函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isBird</span>(<span class=\"params\">x:Bird|Dog</span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">Bird</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (&lt;Bird&gt;x).swing == <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"comment\">//return (x as Bird).swing == 2;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAnimal</span>(<span class=\"params\">x: Bird | Dog</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isBird(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.swing;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.leg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"unknown\"><a href=\"#unknown\" class=\"headerlink\" title=\"unknown\"></a>unknown</h3><ul>\n<li>TypeScript 3.0 引入了新的unknown 类型，它是 any 类型对应的安全类型</li>\n<li>unknown 和 any 的主要区别是 unknown 类型会更加严格：在对 unknown 类型的值执行大多数操作之前，我们必须进行某种形式的检查。而在对 any 类型的值执行操作之前，我们不必进行任何检查</li>\n</ul>\n<h4 id=\"any-类型\"><a href=\"#any-类型\" class=\"headerlink\" title=\"any 类型\"></a>any 类型</h4><ul>\n<li>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的 顶级类型 (也被称作 全局超级类型)。</li>\n<li>TypeScript允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> value: <span class=\"built_in\">any</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">value = <span class=\"literal\">true</span>;             <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"number\">42</span>;               <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"string\">\"Hello World\"</span>;    <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = [];               <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = &#123;&#125;;               <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"built_in\">Math</span>.random;      <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"literal\">null</span>;             <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"literal\">undefined</span>;        <span class=\"comment\">// OK</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> value: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">value.foo.bar;  <span class=\"comment\">// OK</span></span><br><span class=\"line\">value.trim();   <span class=\"comment\">// OK</span></span><br><span class=\"line\">value();        <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> value();    <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"unknown-类型\"><a href=\"#unknown-类型\" class=\"headerlink\" title=\"unknown 类型\"></a>unknown 类型</h4><ul>\n<li>就像所有类型都可以被归为 any，所有类型也都可以被归为 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）</li>\n<li>任何类型都可以赋值给unknown类型</li>\n<li><code>unknown</code>类型只能被赋值给<code>any</code>类型和<code>unknown</code>类型本身</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> value: unknown;</span><br><span class=\"line\">value = <span class=\"literal\">true</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"number\">42</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"string\">\"Hello World\"</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = []; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = &#123;&#125;; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"built_in\">Math</span>.random; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"literal\">null</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"literal\">undefined</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">value = <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> value: unknown;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> value1: unknown = value;   <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value2: <span class=\"built_in\">any</span> = value;       <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value3: <span class=\"built_in\">boolean</span> = value;   <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value4: <span class=\"built_in\">number</span> = value;    <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value5: <span class=\"built_in\">string</span> = value;    <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value6: object = value;    <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value7: <span class=\"built_in\">any</span>[] = value;     <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value8: <span class=\"built_in\">Function</span> = value;  <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"缩小-unknown-类型范围\"><a href=\"#缩小-unknown-类型范围\" class=\"headerlink\" title=\"缩小 unknown 类型范围\"></a>缩小 unknown 类型范围</h3><ul>\n<li>如果没有类型断言或类型细化时，不能在unknown上面进行任何操作</li>\n<li>typeof</li>\n<li>instanceof</li>\n<li>自定义类型保护函数</li>\n<li>可以对 unknown 类型使用类型断言</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value: unknown = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> someString: <span class=\"built_in\">string</span> = value <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"联合类型中的-unknown-类型\"><a href=\"#联合类型中的-unknown-类型\" class=\"headerlink\" title=\"联合类型中的 unknown 类型\"></a>联合类型中的 unknown 类型</h3><p>在联合类型中，unknown 类型会吸收任何类型。这就意味着如果任一组成类型是 unknown，联合类型也会相当于 unknown：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> UnionType1 = unknown | <span class=\"literal\">null</span>;       <span class=\"comment\">// unknown</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> UnionType2 = unknown | <span class=\"literal\">undefined</span>;  <span class=\"comment\">// unknown</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> UnionType3 = unknown | <span class=\"built_in\">string</span>;     <span class=\"comment\">// unknown</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> UnionType4 = unknown | <span class=\"built_in\">number</span>[];   <span class=\"comment\">// unknown</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"交叉类型中的-unknown-类型\"><a href=\"#交叉类型中的-unknown-类型\" class=\"headerlink\" title=\"交叉类型中的 unknown 类型\"></a>交叉类型中的 unknown 类型</h3><p>在交叉类型中，任何类型都可以吸收 unknown 类型。这意味着将任何类型与 unknown 相交不会改变结果类型</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IntersectionType1 = unknown &amp; <span class=\"literal\">null</span>;       <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IntersectionType2 = unknown &amp; <span class=\"literal\">undefined</span>;  <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IntersectionType3 = unknown &amp; <span class=\"built_in\">string</span>;     <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IntersectionType4 = unknown &amp; <span class=\"built_in\">number</span>[];   <span class=\"comment\">// number[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> IntersectionType5 = unknown &amp; <span class=\"built_in\">any</span>;        <span class=\"comment\">// any</span></span><br><span class=\"line\"><span class=\"comment\">// never是unknown的子类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> isNever = never <span class=\"keyword\">extends</span> unknown ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">// keyof unknown 等于never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> key = keyof unknown;</span><br><span class=\"line\"><span class=\"comment\">// 只能对unknown进行等或不等操作，不能进行其它操作</span></span><br><span class=\"line\">un1===un2;</span><br><span class=\"line\">un1!==un2;</span><br><span class=\"line\">un1 += un2;</span><br><span class=\"line\"><span class=\"comment\">// 不能做任何操作</span></span><br><span class=\"line\"><span class=\"comment\">// 不能访问属性</span></span><br><span class=\"line\"><span class=\"comment\">// 不能作为函数调用</span></span><br><span class=\"line\"><span class=\"comment\">// 不能当作类的构造函数不能创建实例</span></span><br><span class=\"line\">un.name</span><br><span class=\"line\">un();</span><br><span class=\"line\"><span class=\"keyword\">new</span> un();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射属性\"><a href=\"#映射属性\" class=\"headerlink\" title=\"映射属性\"></a>映射属性</h3><ul>\n<li>如果映射类型遍历的时候是unknown,不会映射属性</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> getType&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]:<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> t = getType&lt;unknown&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类型变换\"><a href=\"#类型变换\" class=\"headerlink\" title=\"类型变换\"></a>类型变换</h2><h3 id=\"交叉类型\"><a href=\"#交叉类型\" class=\"headerlink\" title=\"交叉类型\"></a>交叉类型</h3><ul>\n<li>交叉类型（Intersection Types）表示将多个类型合并为一个类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">    fly(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">    talk(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> BirdPerson = Bird &amp; Person;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p: BirdPerson = &#123; name: <span class=\"string\">'zf'</span>, fly() &#123; &#125;, talk() &#123; &#125; &#125;;</span><br><span class=\"line\">p.fly;</span><br><span class=\"line\">p.name</span><br><span class=\"line\">p.talk;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h3><ul>\n<li>可以获取一个变量的类型</li>\n<li>先定义类型，再定义变量</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> People = &#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>,</span><br><span class=\"line\">    age:<span class=\"built_in\">number</span>,</span><br><span class=\"line\">    gender:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1:People = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">'zf'</span>,</span><br><span class=\"line\">    age:<span class=\"number\">10</span>,</span><br><span class=\"line\">    gender:<span class=\"string\">'male'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//先定义变量，再定义类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">'zf'</span>,</span><br><span class=\"line\">    age:<span class=\"number\">10</span>,</span><br><span class=\"line\">    gender:<span class=\"string\">'male'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> People = <span class=\"keyword\">typeof</span> p1;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">p:People</span>):<span class=\"title\">string</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getName(p1);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"索引访问操作符\"><a href=\"#索引访问操作符\" class=\"headerlink\" title=\"索引访问操作符\"></a>索引访问操作符</h3><ul>\n<li>可以通过[]获取一个类型的子类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">    job:&#123;</span><br><span class=\"line\">        name:<span class=\"built_in\">string</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    interests:&#123;name:<span class=\"built_in\">string</span>,level:<span class=\"built_in\">number</span>&#125;[]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> FrontEndJob:Person[<span class=\"string\">'job'</span>] = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">'前端工程师'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> interestLevel:Person[<span class=\"string\">'interests'</span>][<span class=\"number\">0</span>][<span class=\"string\">'level'</span>] = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"keyof\"><a href=\"#keyof\" class=\"headerlink\" title=\"keyof\"></a>keyof</h3><ul>\n<li>索引类型查询操作符</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">  gender:<span class=\"string\">'male'</span>|<span class=\"string\">'female'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//type PersonKey = 'name'|'age'|'gender';</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PersonKey = keyof Person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getValueByKey</span>(<span class=\"params\">p:Person,key:PersonKey</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> val = getValueByKey(&#123;name:<span class=\"string\">'zf'</span>,age:<span class=\"number\">10</span>,gender:<span class=\"string\">'male'</span>&#125;,<span class=\"string\">'name'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(val);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射类型\"><a href=\"#映射类型\" class=\"headerlink\" title=\"映射类型\"></a>映射类型</h3><ul>\n<li>在定义的时候用in操作符去批量定义类型中的属性</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">  gender:<span class=\"string\">'male'</span>|<span class=\"string\">'female'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//批量把一个接口中的属性都变成可选的</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PartPerson = &#123;</span><br><span class=\"line\">  [Key <span class=\"keyword\">in</span> keyof Person]?:Person[Key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p1:PartPerson=&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//也可以使用泛型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Part&lt;T&gt; = &#123;</span><br><span class=\"line\">  [key <span class=\"keyword\">in</span> keyof T]?:T[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p2:Part&lt;Person&gt;=&#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内置工具类型\"><a href=\"#内置工具类型\" class=\"headerlink\" title=\"内置工具类型\"></a>内置工具类型</h3><ul>\n<li>TS 中内置了一些工具类型来帮助我们更好地使用类型系统</li>\n</ul>\n<p>符号| 含义<br>+?|变为可远<br>-&gt;|变为必选</p>\n<h4 id=\"Partial\"><a href=\"#Partial\" class=\"headerlink\" title=\"Partial\"></a>Partial</h4><ul>\n<li>Partial 可以将传入的属性由非可选变为可选，具体使用如下：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Partial&lt;T&gt; = &#123; [P <span class=\"keyword\">in</span> keyof T]?: T[P] &#125;;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> A &#123;</span><br><span class=\"line\">  a1: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  a2: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  a3: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> aPartial = Partial&lt;A&gt;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a: aPartial = &#123;&#125;; <span class=\"comment\">// 不会报错</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Required\"><a href=\"#Required\" class=\"headerlink\" title=\"Required\"></a>Required</h4><ul>\n<li>Required 可以将传入的属性中的可选项变为必选项，这里用了 -? 修饰符来实现。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">  gender?:<span class=\"string\">'male'</span>|<span class=\"string\">'female'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * type Require&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p:Required&lt;Person&gt; = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">'zf'</span>,</span><br><span class=\"line\">  age:<span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"comment\">//gender:'male'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Readonly\"><a href=\"#Readonly\" class=\"headerlink\" title=\"Readonly\"></a>Readonly</h4><ul>\n<li>Readonly 通过为传入的属性每一项都加上 readonly 修饰符来实现。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">  name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">  gender?:<span class=\"string\">'male'</span>|<span class=\"string\">'female'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p:Readonly&lt;Person&gt; = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">'zf'</span>,</span><br><span class=\"line\">  age:<span class=\"number\">10</span>,</span><br><span class=\"line\">  gender:<span class=\"string\">'male'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p.age = <span class=\"number\">11</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Pick\"><a href=\"#Pick\" class=\"headerlink\" title=\"Pick\"></a>Pick</h4><ul>\n<li>Pick 能够帮助我们从传入的属性中摘取某一项返回</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Animal &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  gender:<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * From T pick a set of properties K</span></span><br><span class=\"line\"><span class=\"comment\"> * type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P] &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 摘取 Animal 中的 name 属性</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    married: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pick</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">obj: T, keys: K[]</span>): <span class=\"title\">Pick</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result: <span class=\"built_in\">any</span> = &#123;&#125;;</span><br><span class=\"line\">    keys.map(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">        result[key] = obj[key];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> person: Person = &#123; name: <span class=\"string\">'zf'</span>, age: <span class=\"number\">10</span>, married: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result: Pick&lt;Person, <span class=\"string\">'name'</span> | <span class=\"string\">'age'</span>&gt; = pick&lt;Person, <span class=\"string\">'name'</span> | <span class=\"string\">'age'</span>&gt;(person, [<span class=\"string\">'name'</span>, <span class=\"string\">'age'</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Record\"><a href=\"#Record\" class=\"headerlink\" title=\"Record\"></a>Record</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapObject</span>&lt;<span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">string</span> | <span class=\"title\">number</span>, <span class=\"title\">T</span>, <span class=\"title\">U</span>&gt;(<span class=\"params\">obj: Record&lt;K, T&gt;, map: (x: T) =&gt; U</span>): <span class=\"title\">Record</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">U</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result: <span class=\"built_in\">any</span> = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        result[key] = map(obj[key]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> names = &#123; <span class=\"number\">0</span>: <span class=\"string\">'hello'</span>, <span class=\"number\">1</span>: <span class=\"string\">'world'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> lengths = mapObject&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>&gt;<span class=\"function\">(<span class=\"params\">names, (<span class=\"params\">s: <span class=\"built_in\">string</span></span>) =&gt; s.length</span>);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">console</span>.<span class=\"params\">log</span>(<span class=\"params\">lengths</span>);//&#123; '0': 5, '1': 5 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Proxy&lt;T&gt; = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>(): T;</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(value: T): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Proxify&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]: Proxy&lt;T[P]&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">proxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">obj: T</span>): <span class=\"title\">Proxify</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> Proxify&lt;T&gt;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        result[key] = &#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> obj[key],</span><br><span class=\"line\">            <span class=\"keyword\">set</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> obj[key] = value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> props = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'zf'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyProps = proxify(props);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(proxyProps);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unProxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">t: Proxify&lt;T&gt;</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> T;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> t) &#123;</span><br><span class=\"line\">        result[k] = t[k].get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> originProps = unProxify(proxyProps);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(originProps);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射类型修饰符的控制\"><a href=\"#映射类型修饰符的控制\" class=\"headerlink\" title=\"映射类型修饰符的控制\"></a>映射类型修饰符的控制</h3><ul>\n<li>TypeScript中增加了对映射类型修饰符的控制</li>\n<li>具体而言，一个 readonly 或 ? 修饰符在一个映射类型里可以用前缀 + 或-来表示这个修饰符应该被添加或移除</li>\n<li>TS 中部分内置工具类型就利用了这个特性（Partial、Required、Readonly…），这里我们可以参考 Partial、Required 的实现</li>\n</ul>\n<h2 id=\"条件类型\"><a href=\"#条件类型\" class=\"headerlink\" title=\"条件类型\"></a>条件类型</h2><ul>\n<li>在定义泛型的时候能够添加进逻辑分支，以后泛型更加灵活<br>utility-types</li>\n</ul>\n<h3 id=\"定义条件类型\"><a href=\"#定义条件类型\" class=\"headerlink\" title=\"定义条件类型\"></a>定义条件类型</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Water &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Sky &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//三元运算符</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Condition&lt;T&gt; = T <span class=\"keyword\">extends</span> Fish ? Water : Sky;</span><br><span class=\"line\"><span class=\"keyword\">let</span> condition: Condition&lt;Fish&gt; = &#123; name: <span class=\"string\">'水'</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件类型的分发\"><a href=\"#条件类型的分发\" class=\"headerlink\" title=\"条件类型的分发\"></a>条件类型的分发</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">    fish: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Water &#123;</span><br><span class=\"line\">    water: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">    bird: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Sky &#123;</span><br><span class=\"line\">    sky: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Condition&lt;T&gt; = T <span class=\"keyword\">extends</span> Fish ? Water : Sky;</span><br><span class=\"line\"><span class=\"comment\">//(Fish extends Fish ? Water : Sky) | (Bird extends Fish ? Water : Sky)</span></span><br><span class=\"line\"><span class=\"comment\">// Water|Sky</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> condition1: Condition&lt;Fish | Bird&gt; = &#123; water: <span class=\"string\">'水'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> condition2: Condition&lt;Fish | Bird&gt; = &#123; sky: <span class=\"string\">'天空'</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内置条件类型\"><a href=\"#内置条件类型\" class=\"headerlink\" title=\"内置条件类型\"></a>内置条件类型</h3><ul>\n<li>TS 在内置了一些常用的条件类型，可以在 lib.es5.d.ts 中查看：</li>\n<li>infer最早出现在此 PR 中，表示在 extends 条件语句中待推断的类型变量</li>\n</ul>\n<h4 id=\"Exclude\"><a href=\"#Exclude\" class=\"headerlink\" title=\"Exclude\"></a>Exclude</h4><ul>\n<li>从 T 可分配给的类型中排除 U `js type Exclude&lt;T, U&gt; = T extends U ? never : T;</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> E = Exclude&lt;<span class=\"built_in\">string</span>|<span class=\"built_in\">number</span>,<span class=\"built_in\">string</span>&gt;; <span class=\"keyword\">let</span> e:E = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Extract-lt-T-U-gt\"><a href=\"#Extract-lt-T-U-gt\" class=\"headerlink\" title=\"Extract&lt;T, U&gt;\"></a>Extract&lt;T, U&gt;</h4><ul>\n<li>从 T 可分配的类型中提取 U</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Extract&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? T : never;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span>  E = Extract&lt;<span class=\"built_in\">string</span>|<span class=\"built_in\">number</span>,<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> e:E = <span class=\"string\">'1'</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NonNullable\"><a href=\"#NonNullable\" class=\"headerlink\" title=\"NonNullable\"></a>NonNullable</h4><ul>\n<li>从 T 中排除 null 和 undefined</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> NonNullable&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span> ? never : T;</span><br><span class=\"line\"><span class=\"keyword\">type</span>  E = NonNullable&lt;<span class=\"built_in\">string</span>|<span class=\"built_in\">number</span>|<span class=\"literal\">null</span>|<span class=\"literal\">undefined</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> e:E = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ReturnType\"><a href=\"#ReturnType\" class=\"headerlink\" title=\"ReturnType\"></a>ReturnType</h4><ul>\n<li>获取函数类型的返回类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserInfo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; name: <span class=\"string\">\"zf\"</span>, age: <span class=\"number\">10</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过 ReturnType 将 getUserInfo 的返回值类型赋给了 UserInfo</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> UserInfo = ReturnType&lt;<span class=\"keyword\">typeof</span> getUserInfo&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> userA: UserInfo = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"zf\"</span>,</span><br><span class=\"line\">  age: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ReturnType2&lt;T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> AnyFunction = <span class=\"function\">(<span class=\"params\">...args: <span class=\"built_in\">any</span>[]</span>) =&gt;</span> <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ReturnType2&lt;T <span class=\"keyword\">extends</span> AnyFunction&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Parameters\"><a href=\"#Parameters\" class=\"headerlink\" title=\"Parameters\"></a>Parameters</h4><p>Constructs a tuple type of the types of the parameters of a function type T<br>Parameters</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare function f1(arg: &#123; a: number, b: string &#125;): void</span><br><span class=\"line\">type T0 &#x3D; Parameters2&lt;() &#x3D;&gt; string&gt;;  &#x2F;&#x2F; []</span><br><span class=\"line\">type T1 &#x3D; Parameters2&lt;(s: string) &#x3D;&gt; void&gt;;  &#x2F;&#x2F; [string]</span><br><span class=\"line\">type T2 &#x3D; Parameters2&lt;(&lt;T&gt;(arg: T) &#x3D;&gt; T)&gt;;  &#x2F;&#x2F; [unknown]</span><br><span class=\"line\">type AnyFunction &#x3D; (...args: any[]) &#x3D;&gt; any;</span><br><span class=\"line\">&#x2F;&#x2F;type ReturnType2&lt;T extends AnyFunction&gt; &#x3D; T extends (...args: any[]) &#x3D;&gt; infer R ? R : any;</span><br><span class=\"line\">type Parameters2&lt;T extends AnyFunction&gt; &#x3D; T extends (...args: infer R) &#x3D;&gt; any ? R : any;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"InstanceType\"><a href=\"#InstanceType\" class=\"headerlink\" title=\"InstanceType\"></a>InstanceType</h4><ul>\n<li>获取构造函数类型的实例类型</li>\n<li>InstanceType</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    getName() &#123; <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> constructorParameters = ConstructorParameters&lt;<span class=\"keyword\">typeof</span> Person&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> params: constructorParameters = [<span class=\"string\">'zf'</span>]</span><br><span class=\"line\"><span class=\"keyword\">type</span> Instance = InstanceType&lt;<span class=\"keyword\">typeof</span> Person&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> instance: Instance = &#123; name: <span class=\"string\">'zf'</span>, getName() &#123; &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Constructor = <span class=\"keyword\">new</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ConstructorParameters&lt;T <span class=\"keyword\">extends</span> Constructor&gt; = T <span class=\"keyword\">extends</span> <span class=\"keyword\">new</span> (...args: infer P) =&gt; <span class=\"built_in\">any</span> ? P : never;</span><br><span class=\"line\"><span class=\"keyword\">type</span> InstanceType&lt;T <span class=\"keyword\">extends</span> Constructor&gt; = T <span class=\"keyword\">extends</span> <span class=\"keyword\">new</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"infer\"><a href=\"#infer\" class=\"headerlink\" title=\"infer\"></a>infer</h4><ul>\n<li>typescript_zh</li>\n<li>codesandbox</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ElementType&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[] ? T[<span class=\"built_in\">number</span>] : T;</span><br><span class=\"line\"><span class=\"keyword\">type</span> e1 = ElementType&lt;<span class=\"built_in\">string</span>[]&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> e2 = ElementType&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> GetElementType&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">Array</span>&lt;infer U&gt; ? U : T;</span><br><span class=\"line\"><span class=\"keyword\">type</span> e3 = GetElementType&lt;<span class=\"built_in\">string</span>[]&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> e4 = GetElementType&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Action&lt;T&gt; &#123;</span><br><span class=\"line\">    payload?: T</span><br><span class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> EffectModule &#123;</span><br><span class=\"line\">  count = <span class=\"number\">1</span>;</span><br><span class=\"line\">  message = <span class=\"string\">\"hello!\"</span>;</span><br><span class=\"line\">  delay(input: <span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">number</span>&gt;) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> input.then(<span class=\"function\"><span class=\"params\">i</span> =&gt;</span> (&#123;</span><br><span class=\"line\">          payload: <span class=\"string\">`hello <span class=\"subst\">$&#123;i&#125;</span>!`</span>,</span><br><span class=\"line\">          <span class=\"keyword\">type</span>: <span class=\"string\">'delay'</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setMessage(action: Action&lt;<span class=\"built_in\">Date</span>&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        payload: action.payload!.getMilliseconds(),</span><br><span class=\"line\">        <span class=\"keyword\">type</span>: <span class=\"string\">\"set-message\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> FuncName&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]: T[P] <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span> ? P : never;</span><br><span class=\"line\">&#125;[keyof T];</span><br><span class=\"line\"><span class=\"keyword\">type</span> ts = FuncName&lt;EffectModule&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Connect = <span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span>: EffectModule</span>) =&gt;</span> &#123; [T <span class=\"keyword\">in</span> FuncName&lt;EffectModule&gt;]: EffectModule[T] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> TransformResultType&lt;RT&gt; = &#123;</span><br><span class=\"line\">    [s <span class=\"keyword\">in</span> keyof RT]:</span><br><span class=\"line\">    RT[s] <span class=\"keyword\">extends</span> (input: <span class=\"built_in\">Promise</span>&lt;infer T&gt;) =&gt; <span class=\"built_in\">Promise</span>&lt;Action&lt;infer U&gt;&gt; ?</span><br><span class=\"line\">    (input: T) =&gt; Action&lt;U&gt; : (</span><br><span class=\"line\">        RT[s] <span class=\"keyword\">extends</span> (action: Action&lt;infer T&gt;) =&gt; Action&lt;infer U&gt; ? <span class=\"function\">(<span class=\"params\">action: T</span>) =&gt;</span> Action&lt;U&gt; : never</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> connectedResultType = ReturnType&lt;Connect&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> result = TransformResultType&lt;connectedResultType&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; &#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模块VS命名空间\"><a href=\"#模块VS命名空间\" class=\"headerlink\" title=\"模块VS命名空间\"></a>模块VS命名空间</h2><h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><ul>\n<li>模块是TS中外部模块的简称，侧重于代码和复用</li>\n<li>模块在期自身的作用域里执行，而不是在全局作用域里</li>\n<li>一个模块里的变量、函数、类等在外部是不可见的，除非你把它导出</li>\n<li>如果想要使用一个模块里导出的变量，则需要导入</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"string\">'zf'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> name, &#123; a, b &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./1'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name, a, b);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><ul>\n<li>在代码量较大的情况下，为了避免命名空间冲突，可以将相似的函数、类、接口放置到命名空间内</li>\n<li>命名空间可以将代码包裹起来，只对外暴露需要在外部访问的对象，命名空间内通过export向外导出</li>\n<li>命名空间是内部模块，主要用于组织代码，避免命名冲突</li>\n</ul>\n<h3 id=\"内部划分\"><a href=\"#内部划分\" class=\"headerlink\" title=\"内部划分\"></a>内部划分</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> zoo &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Dog &#123; eat() &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'zoo dog'</span>); &#125; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> home &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Dog &#123; eat() &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'home dog'</span>); &#125; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog_of_zoo = <span class=\"keyword\">new</span> zoo.Dog();</span><br><span class=\"line\">dog_of_zoo.eat();</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog_of_home = <span class=\"keyword\">new</span> home.Dog();</span><br><span class=\"line\">dog_of_home.eat();</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; zoo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./3'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog_of_zoo = <span class=\"keyword\">new</span> zoo.Dog();</span><br><span class=\"line\">dog_of_zoo.eat();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类型声明\"><a href=\"#类型声明\" class=\"headerlink\" title=\"类型声明\"></a>类型声明</h2><ul>\n<li>声明文件可以让我们不需要将JS重构为TS，只需要加上声明文件就可以使用系统</li>\n<li>类型声明在编译的时候都会被删除，不会影响真正的代码</li>\n</ul>\n<h3 id=\"普通类型声明\"><a href=\"#普通类型声明\" class=\"headerlink\" title=\"普通类型声明\"></a>普通类型声明</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> $: <span class=\"function\">(<span class=\"params\">selector: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123; <span class=\"comment\">//变量</span></span><br><span class=\"line\">    click(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">    width(length: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">$(<span class=\"string\">'#root'</span>).click();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log($(<span class=\"string\">'#root'</span>).width);</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span>;  <span class=\"comment\">//变量</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">let</span> age: <span class=\"built_in\">number</span>;  <span class=\"comment\">//变量</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\"></span>): <span class=\"title\">string</span></span>;  <span class=\"comment\">//方法</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">class</span> Animal &#123; name: <span class=\"built_in\">string</span> &#125;  <span class=\"comment\">//类</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name, age);</span><br><span class=\"line\">getName();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外部枚举\"><a href=\"#外部枚举\" class=\"headerlink\" title=\"外部枚举\"></a>外部枚举</h3><ul>\n<li>外部枚举是使用declare enum定义的枚举类型</li>\n<li>外部枚举用来描述已经存在的枚举类型的形状</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">enum</span> Seasons &#123;</span><br><span class=\"line\">    Spring,</span><br><span class=\"line\">    Summer,</span><br><span class=\"line\">    Autumn,</span><br><span class=\"line\">    Winter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> seasons = [</span><br><span class=\"line\">    Seasons.Spring,</span><br><span class=\"line\">    Seasons.Summer,</span><br><span class=\"line\">    Seasons.Autumn,</span><br><span class=\"line\">    Seasons.Winter</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">declare</span> 定义的类型只会用于编译时的检查，编译结果中会被删除。上例的编译结果如下</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> seasons = [</span><br><span class=\"line\">    Seasons.Spring,</span><br><span class=\"line\">    Seasons.Summer,</span><br><span class=\"line\">    Seasons.Autumn,</span><br><span class=\"line\">    Seasons.Winter</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以同时使用declare 和 const</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> Seasons &#123;</span><br><span class=\"line\">    Spring,</span><br><span class=\"line\">    Summer,</span><br><span class=\"line\">    Autumn,</span><br><span class=\"line\">    Winter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> seasons = [</span><br><span class=\"line\">    Seasons.Spring,</span><br><span class=\"line\">    Seasons.Summer,</span><br><span class=\"line\">    Seasons.Autumn,</span><br><span class=\"line\">    Seasons.Winter</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> seasons = [</span><br><span class=\"line\">    <span class=\"number\">0</span> <span class=\"comment\">/* Spring */</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"comment\">/* Summer */</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span> <span class=\"comment\">/* Autumn */</span>,</span><br><span class=\"line\">    <span class=\"number\">3</span> <span class=\"comment\">/* Winter */</span></span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"namespace\"><a href=\"#namespace\" class=\"headerlink\" title=\"namespace\"></a>namespace</h2><ul>\n<li>如果一个全局变量包括了很多子属性，可能使用namespace</li>\n<li>在声明文件中的namespace表示一个全局变量包含很多子属性</li>\n<li>在命名空间内部不需要使用 declare 声明属性或方法</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> $&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url:<span class=\"built_in\">string</span>,settings:<span class=\"built_in\">any</span></span>):<span class=\"title\">void</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">namespace</span> fn &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">object:<span class=\"built_in\">any</span></span>):<span class=\"title\">void</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$.ajax(<span class=\"string\">'/api/users'</span>,&#123;&#125;);</span><br><span class=\"line\">$.fn.extend(&#123;</span><br><span class=\"line\">    log:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message:<span class=\"built_in\">any</span></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型声明文件\"><a href=\"#类型声明文件\" class=\"headerlink\" title=\"类型声明文件\"></a>类型声明文件</h3><ul>\n<li>我们可以把类型声明放在一个单独的类型声明文件中</li>\n<li>可以在类型声明文件中使用类型声明</li>\n<li>文件命名规范为*.d.ts</li>\n<li>观看类型声明文件有助于了解库的使用方式</li>\n</ul>\n<h4 id=\"jquery-d-ts\"><a href=\"#jquery-d-ts\" class=\"headerlink\" title=\"jquery.d.ts\"></a>jquery.d.ts</h4><p>typings\\jquery.d.ts</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> $:<span class=\"function\">(<span class=\"params\">selector:<span class=\"built_in\">string</span></span>)=&gt;</span>&#123;</span><br><span class=\"line\">    click():<span class=\"built_in\">void</span>;</span><br><span class=\"line\">    width(length:<span class=\"built_in\">number</span>):<span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tsconfig-json\"><a href=\"#tsconfig-json\" class=\"headerlink\" title=\"tsconfig.json\"></a>tsconfig.json</h3><p>tsconfig.json</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"compilerOptions\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"module\"</span>: <span class=\"string\">\"commonjs\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"target\"</span>: <span class=\"string\">\"ES2015\"</span>,  </span><br><span class=\"line\">    <span class=\"string\">\"outDir\"</span>:<span class=\"string\">\"lib\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"include\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"src/**/*\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"typings/**/*\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"test-js\"><a href=\"#test-js\" class=\"headerlink\" title=\"test.js\"></a>test.js</h4><p>src\\test.ts</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'#button'</span>).click();</span><br><span class=\"line\">$(<span class=\"string\">'#button'</span>).width(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第三方声明文件\"><a href=\"#第三方声明文件\" class=\"headerlink\" title=\"第三方声明文件\"></a>第三方声明文件</h2><ul>\n<li>可以安装使用第三方的声明文件</li>\n<li>@types是一个约定的前缀，所有的第三方声明的类型库都会带有这样的前缀</li>\n<li>JavaScript 中有很多内置对象，它们可以在 TypeScript 中被当做声明好了的类型</li>\n<li>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准</li>\n<li>这些内置对象的类型声明文件，就包含在TypeScript 核心库的类型声明文件中</li>\n</ul>\n<h3 id=\"使用jquery\"><a href=\"#使用jquery\" class=\"headerlink\" title=\"使用jquery\"></a>使用jquery</h3><p>cnpm i jquery -S<br>对于common.js风格的模块必须使用 import * as<br>import * as jQuery from ‘jquery’;<br>jQuery.ajax(‘/user/1’);</p>\n<h3 id=\"安装声明文件\"><a href=\"#安装声明文件\" class=\"headerlink\" title=\"安装声明文件\"></a>安装声明文件</h3><p>cnpm i @types/jquery -S</p>\n<h3 id=\"自己编写声明文件\"><a href=\"#自己编写声明文件\" class=\"headerlink\" title=\"自己编写声明文件\"></a>自己编写声明文件</h3><ul>\n<li>模块查找规则</li>\n<li>`node_modules@types\\jquery/index.d.ts</li>\n<li>我们可以自己编写声明文件并配置tsconfig.json</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.d.ts</span></span><br><span class=\"line\"><span class=\"comment\">// types\\jquery\\index.d.ts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jQuery</span>(<span class=\"params\">selector:<span class=\"built_in\">string</span></span>):<span class=\"title\">HTMLElement</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> jQuery&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url:<span class=\"built_in\">string</span></span>):<span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">export</span> <span class=\"title\">default</span> <span class=\"title\">jQuery</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tsconfig-json-1\"><a href=\"#tsconfig-json-1\" class=\"headerlink\" title=\"tsconfig.json\"></a>tsconfig.json</h3><ul>\n<li>如果配置了paths,那么在引入包的的时候会自动去paths目录里找类型声明文件</li>\n<li>在 tsconfig.json 中，我们通过 compilerOptions 里的 paths 属性来配置路径映射</li>\n<li>paths是模块名到基于baseUrl的路径映射的列表</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"string\">\"baseUrl\"</span>: <span class=\"string\">\"./\"</span>,<span class=\"comment\">// 使用 paths 属性的话必须要指定 baseUrl 的值</span></span><br><span class=\"line\"><span class=\"string\">\"paths\"</span>: &#123;</span><br><span class=\"line\"><span class=\"string\">\"*\"</span>:[<span class=\"string\">\"types/*\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"npm声明文件可能的位置\"><a href=\"#npm声明文件可能的位置\" class=\"headerlink\" title=\"npm声明文件可能的位置\"></a>npm声明文件可能的位置</h3><p>node_modules/jquery/package.json<br>“types”:”types/xxx.d.ts”<br>node_modules/jquery/index.d.ts<br>node_modules/@types/jquery/index.d.ts</p>\n<h3 id=\"扩展全局变量的类型\"><a href=\"#扩展全局变量的类型\" class=\"headerlink\" title=\"扩展全局变量的类型\"></a>扩展全局变量的类型</h3><h4 id=\"扩展局部变量类型\"><a href=\"#扩展局部变量类型\" class=\"headerlink\" title=\"扩展局部变量类型\"></a>扩展局部变量类型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> <span class=\"built_in\">String</span>: StringConstructor;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> StringConstructor &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>(value?: <span class=\"built_in\">any</span>): <span class=\"built_in\">String</span>;</span><br><span class=\"line\">    (value?: <span class=\"built_in\">any</span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    readonly prototype: <span class=\"built_in\">String</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> String &#123;</span><br><span class=\"line\">    toString(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//扩展类的原型</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> String &#123;</span><br><span class=\"line\">    double():<span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span>.prototype.double = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>+<span class=\"string\">'+'</span>+<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>.double());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//扩展类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Window&#123;</span><br><span class=\"line\">    myname:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.myname);</span><br><span class=\"line\"><span class=\"comment\">//export &#123;&#125; 没有导出就是全局扩展</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模块内全局扩展\"><a href=\"#模块内全局扩展\" class=\"headerlink\" title=\"模块内全局扩展\"></a>模块内全局扩展</h3><p>types\\global\\index.d.ts</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> global&#123;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> String &#123;</span><br><span class=\"line\">        double():<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">interface</span> Window&#123;</span><br><span class=\"line\">        myname:<span class=\"built_in\">string</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span>  &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"合并声明\"><a href=\"#合并声明\" class=\"headerlink\" title=\"合并声明\"></a>合并声明</h2><ul>\n<li>同一名称的两个独立声明会被合并成一个单一声明</li>\n<li>合并后的声明拥有原先两个声明的特性  </li>\n</ul>\n<p>关键字|作为类型使用|作为值使用<br>class|yes|yes<br>enum|yes|yes<br>interface|yes|no<br>type|yes|no<br>function|no|yes<br>var,let,const|no|yes</p>\n<ul>\n<li>类既可以作为类型使用，也可以作为值使用，接口只能作为类型使用</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Person&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>=<span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1:Person;<span class=\"comment\">//作为类型使用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> Person();<span class=\"comment\">//作为值使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Animal&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a1:Animal;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a2 = Animal;<span class=\"comment\">//接口类型不能用作值</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并类型声明\"><a href=\"#合并类型声明\" class=\"headerlink\" title=\"合并类型声明\"></a>合并类型声明</h3><ul>\n<li>可以通过接口合并的特性给一个第三方为扩展类型声明<br>use.js</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Animal&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a1:Animal=&#123;name:<span class=\"string\">'zf'</span>,age:<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a1.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a1.age);</span><br><span class=\"line\"><span class=\"comment\">//注意不要加export &#123;&#125; ,这是全局的</span></span><br><span class=\"line\">types\\animal\\index.d.ts</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Animal&#123;</span><br><span class=\"line\">    age:<span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用命名空间扩展类\"><a href=\"#使用命名空间扩展类\" class=\"headerlink\" title=\"使用命名空间扩展类\"></a>使用命名空间扩展类</h3><ul>\n<li>我们可以使用 namespace 来扩展类，用于表示内部类</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Form &#123;</span><br><span class=\"line\">  username: Form.Item=<span class=\"string\">''</span>;</span><br><span class=\"line\">  password: Form.Item=<span class=\"string\">''</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Item为Form的内部类</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Form &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> Item &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> item:Form.Item = <span class=\"keyword\">new</span> Form.Item();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用命名空间扩展函数\"><a href=\"#使用命名空间扩展函数\" class=\"headerlink\" title=\"使用命名空间扩展函数\"></a>使用命名空间扩展函数</h3><ul>\n<li>我们也可以使用 namespace 来扩展函数</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeting</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> greeting.words+name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> greeting &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> words = <span class=\"string\">\"Hello,\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeting(<span class=\"string\">'zf'</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用命名空间扩展枚举类型\"><a href=\"#使用命名空间扩展枚举类型\" class=\"headerlink\" title=\"使用命名空间扩展枚举类型\"></a>使用命名空间扩展枚举类型</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;</span><br><span class=\"line\">    red = <span class=\"number\">1</span>,</span><br><span class=\"line\">    yellow = <span class=\"number\">2</span>,</span><br><span class=\"line\">    blue = <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Color &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">const</span> green=<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">const</span> purple=<span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Color.green)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"扩展Store\"><a href=\"#扩展Store\" class=\"headerlink\" title=\"扩展Store\"></a>扩展Store</h3><figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, Store &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> StoreExt = Store &amp; &#123;</span><br><span class=\"line\">    ext: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store: StoreExt = createStore(<span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state);</span><br><span class=\"line\">store.ext = <span class=\"string\">'hello'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生成声明文件\"><a href=\"#生成声明文件\" class=\"headerlink\" title=\"生成声明文件\"></a>生成声明文件</h3><ul>\n<li>把TS编译成JS后丢失类型声明，我们可以在编译的时候自动生成一份JS文件</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"compilerOptions\"</span>: &#123;</span><br><span class=\"line\">     <span class=\"string\">\"declaration\"</span>: <span class=\"literal\">true</span>, <span class=\"comment\">/* Generates corresponding '.d.ts' file.*/</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckbw73ckj00081gsx7k2s98b7","category_id":"ckbw73ckg00051gsxftz9g4v0","_id":"ckbw73ckm000d1gsx0hz1gb9d"},{"post_id":"ckbw73ckc00031gsx2bqm6zwx","category_id":"ckbw73ckg00051gsxftz9g4v0","_id":"ckbw73cko000h1gsx33rbccd7"},{"post_id":"ckbw73ckf00041gsx27ry2cni","category_id":"ckbw73ckg00051gsxftz9g4v0","_id":"ckbw73cko000i1gsxh8dwgkss"},{"post_id":"ckbw73cki00071gsxe6bkg5j8","category_id":"ckbw73ckg00051gsxftz9g4v0","_id":"ckbw73ckp000k1gsx8zldf7ag"},{"post_id":"ckdydrm4d00004tiv0rwk27e3","category_id":"ckbw73ckg00051gsxftz9g4v0","_id":"ckdydrm5000044tiv8197epw4"},{"post_id":"ckdydrm4u00014tiva9gp6vry","category_id":"ckbw73ckg00051gsxftz9g4v0","_id":"ckdydrm5000054tivasbo4pa4"}],"PostTag":[{"post_id":"ckbw73ckj00081gsx7k2s98b7","tag_id":"ckbw73ckh00061gsx50zc7ift","_id":"ckbw73ckm000b1gsxb61u6myi"},{"post_id":"ckbw73ckc00031gsx2bqm6zwx","tag_id":"ckbw73ckh00061gsx50zc7ift","_id":"ckbw73ckm000c1gsxhx2naak4"},{"post_id":"ckbw73ckf00041gsx27ry2cni","tag_id":"ckbw73ckh00061gsx50zc7ift","_id":"ckbw73cko000g1gsx10ch57b5"},{"post_id":"ckbw73cki00071gsxe6bkg5j8","tag_id":"ckbw73ckh00061gsx50zc7ift","_id":"ckbw73ckp000j1gsx9qgn6fou"},{"post_id":"ckdydrm4d00004tiv0rwk27e3","tag_id":"ckbw73ckh00061gsx50zc7ift","_id":"ckdydrm4y00024tiv4ynm8f12"},{"post_id":"ckdydrm4u00014tiva9gp6vry","tag_id":"ckbw73ckh00061gsx50zc7ift","_id":"ckdydrm5000034tiv43mb09fv"}],"Tag":[{"name":"typescript","_id":"ckbw73ckh00061gsx50zc7ift"}]}}